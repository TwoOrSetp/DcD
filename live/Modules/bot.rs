#[cfg(not(feature = "geode"))]
use crate::{game::PlayLayer, hooks};

use crate::{
    clickpack::{Button, ClickType, Clickpack, LoadClickpackFor, Pitch, Timings, VolumeSettings},
    utils,
};

// Import the new modules
pub mod config;
pub mod environment;
pub mod audio;
pub mod events;
pub mod ui_components;
pub mod console;

pub use config::*;
pub use environment::*;
pub use audio::*;
pub use events::*;
pub use ui_components::*;
pub use console::*;
use anyhow::Result;
use egui::{
    emath, epaint::Shadow, vec2, Color32, DragValue, Key, KeyboardShortcut, Modifiers, RichText,
};
use egui_clickpack_db::ClickpackDb;
use egui_keybind::{Bind, Keybind, Shortcut};
use egui_modal::{Icon, Modal};
use egui_notify::{Toast, Toasts};
use kittyaudio::{Device, Mixer, PlaybackRate, SoundHandle, StreamSettings};
use once_cell::sync::Lazy;
use parking_lot::Mutex;
use rfd::FileDialog;
use serde::{Deserialize, Serialize};
use std::{
    ops::RangeInclusive,
    path::{Path, PathBuf},
    process::Command,
    sync::{
        atomic::{AtomicBool, Ordering},
        Arc,
    },
    time::{Duration, Instant},
};

#[cfg(not(feature = "geode"))]
use windows::Win32::System::Console::{AllocConsole, FreeConsole};

/// Global bot state
pub static mut BOT: Lazy<Box<Bot>> = Lazy::new(Box::<Bot>::default);

const UI_SCALE_RANGE: RangeInclusive<f32> = 0.3..=5.0;

pub mod built_info {
    // generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/built.rs"));
}




pub struct Bot {
    pub conf: Config,
    pub prev_conf: Config,
    pub last_conf_save: Instant,
    pub audio_system: AudioSystem,
    #[cfg(not(feature = "geode"))]
    pub playlayer: PlayLayer,
    pub event_handler: EventHandler,
    pub is_loading_clickpack: Arc<AtomicBool>,
    pub prev_pitch: f64,
    pub prev_volume: f64,
    pub prev_spam_offset: f64,
    pub buffer_size_changed: bool,
    pub clickpacks: Vec<String>,
    pub last_clickpack_reload: Instant,
    pub env: Env,
    pub toast_manager: ToastManager,
    pub show_fmod_buffersize_warn: bool,
    pub startup_buffer_size: u32,
    pub clickpack: Clickpack,
    pub first_launch_dialog_timeout: f32,
    pub clickpack_db: ClickpackDb,
    pub clickpack_db_open: bool,
    pub prev_scale_factor: f32,
    pub console_manager: ConsoleManager,
}

impl Default for Bot {
    fn default() -> Self {
        let conf = Config::load().unwrap_or_default().fixup();
        let startup_buffer_size = conf.buffer_size;
        let now = Instant::now();
        Self {
            conf: conf.clone(),
            prev_conf: conf,
            last_conf_save: now,
            audio_system: AudioSystem::new(),
            #[cfg(not(feature = "geode"))]
            playlayer: PlayLayer::NULL,
            event_handler: EventHandler::new(),
            is_loading_clickpack: Arc::new(AtomicBool::new(false)),
            prev_pitch: f64::NAN,
            prev_volume: f64::NAN,
            prev_spam_offset: f64::NAN,
            buffer_size_changed: false,
            clickpacks: vec![],
            last_clickpack_reload: now,
            env: Env::load(),
            toast_manager: ToastManager::new(),
            show_fmod_buffersize_warn: false,
            startup_buffer_size,
            clickpack: Clickpack::default(),
            first_launch_dialog_timeout: 3.0,
            clickpack_db: ClickpackDb::default(),
            clickpack_db_open: false,
            prev_scale_factor: 1.0,
            console_manager: ConsoleManager::new(),
        }
    }
}



/// Value is always min clamped with 1.
fn u32_edit_field_min1(ui: &mut egui::Ui, value: &mut u32) -> egui::Response {
    let mut tmp_value = format!("{value}");
    let res = ui.text_edit_singleline(&mut tmp_value);
    if let Ok(result) = tmp_value.parse::<u32>() {
        *value = result.max(1);
    }
    res
}

/*
#[inline]
fn gd_audio_pitch() -> f32 {
    let mut pitch = 1.0f32;
    unsafe {
        let _ = FMOD_Channel_GetPitch(
            FMODAudioEngine::shared().current_sound_channel(),
            &mut pitch,
        );
    };
    pitch
}
*/

fn show_error_dialog(modal: Arc<Mutex<Modal>>, title: &str, body: &str) {
    log::error!("{title}: {body}");
    modal
        .lock()
        .dialog()
        .with_title(title)
        .with_body(utils::capitalize_first_letter(body))
        .with_icon(Icon::Error)
        .open();
}

fn drag_value<Num: emath::Numeric>(
    ui: &mut egui::Ui,
    value: &mut Num,
    text: impl Into<String>,
    clamp_range: RangeInclusive<Num>,
    help: &str,
) -> egui::Response {
    let mut resp = None;
    help_text(ui, help, |ui| {
        resp = Some(
            ui.add(
                DragValue::new(value)
                    .clamp_range(clamp_range.clone())
                    .speed(0.01),
            ),
        );
        ui.label(
            if resp.as_ref().unwrap().dragged()
                && (clamp_range.start() == value || clamp_range.end() == value)
            {
                RichText::new(text).color(Color32::LIGHT_RED)
            } else {
                RichText::new(text)
            },
        );
    });
    resp.unwrap()
}

const USER_AGENT: &str = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/37.0.2062.94 Chrome/37.0.2062.94 Safari/537.36";

fn ureq_agent() -> ureq::Agent {
    ureq::AgentBuilder::new()
        .timeout_read(Duration::from_secs(15))
        .timeout_write(Duration::from_secs(15))
        .user_agent(USER_AGENT)
        .build()
}

fn ureq_get(url: &str) -> Result<Vec<u8>, String> {
    let mut buf = Vec::new();
    ureq_agent()
        .get(url)
        .call()
        .map_err(|e| e.to_string())?
        .into_reader()
        .read_to_end(&mut buf)
        .map_err(|_| "failed to read body".to_string())?;
    Ok(buf)
}

impl Bot {
    fn maybe_init_kittyaudio(&mut self) {
        if self.conf.use_fmod {
            return;
        }
        log::debug!("starting kittyaudio playback thread");
        self.audio_system.mixer = Mixer::new();
        let device = self.get_device();

        self.audio_system.mixer.init_ex(
            device,
            StreamSettings {
                buffer_size: Some(self.conf.buffer_size),
                ..Default::default()
            },
        );
    }

    pub unsafe fn init_fmod(&mut self) -> Result<()> {
        /*
        const SYSTEM_SAMPLERATE: i32 = 48_000;
        log::info!("initializing fmod system");
        if !self.system.is_null() {
            self.release_fmod();
        }

        FMOD_System_Create(&mut self.system, FMOD_VERSION).fmod_result()?;
        let extra_driver_data = FMODAudioEngine::shared().extra_driver_data();

        FMOD_System_SetSoftwareFormat(self.system, SYSTEM_SAMPLERATE, FMOD_SPEAKERMODE_STEREO, 0)
            .fmod_result()?;

        // set buffer size
        /*
        FMOD_System_SetStreamBufferSize(self.system, self.conf.buffer_size, FMOD_TIMEUNIT_PCM)
            .fmod_result()?;

        let mut numbuffers = 0i32;
        let mut bufferlength = 0u32;
        FMOD_System_GetDSPBufferSize(self.system, &mut bufferlength, &mut numbuffers)
            .fmod_result()?;
        log::info!(
            "FMOD_System_GetDSPBufferSize: bufferlength: {bufferlength}, numbuffers: {numbuffers}"
        );
        FMOD_System_SetDSPBufferSize(self.system, self.conf.buffer_size, numbuffers)
            .fmod_result()?;
        */

        // init system
        self.fmod_apply_buffer_size()?;
        FMOD_System_Init(self.system, 2048, FMOD_INIT_NORMAL, extra_driver_data).fmod_result()?;

        log::info!("successfully initialized fmod system, samplerate: {SYSTEM_SAMPLERATE}");
        */
        Ok(())
    }

    //fn fmod_apply_buffer_size(&self) -> Result<()> {
    //    /*
    //    unsafe {
    //        FMOD_System_SetStreamBufferSize(self.system, self.conf.buffer_size, FMOD_TIMEUNIT_PCM)
    //            .fmod_result()?;
    //
    //        let mut numbuffers = 0i32;
    //        let mut bufferlength = 0u32;
    //        FMOD_System_GetDSPBufferSize(self.system, &mut bufferlength, &mut numbuffers)
    //            .fmod_result()?;
    //        log::info!(
    //            "FMOD_System_GetDSPBufferSize: bufferlength: {bufferlength}, numbuffers: {numbuffers}"
    //        );
    //        FMOD_System_SetDSPBufferSize(self.system, self.conf.buffer_size, numbuffers)
    //            .fmod_result()?;
    //    }
    //    */
    //    Ok(())
    //}

    pub fn release_fmod(&mut self) {
        /*
        let _ = unsafe {
            FMOD_System_Release(self.system)
                .fmod_result()
                .map_err(|e| log::error!("failed to release fmod system: {e}"))
        };
        self.system = std::ptr::null_mut();
        */
    }

    pub fn init(&mut self) {
        {
            let devices_arc = self.audio_system.devices.clone();
            std::thread::spawn(move || {
                let mut prev_devices = vec![];
                loop {
                    if unsafe { BOT.conf.use_fmod } {
                        continue;
                    }
                    if let Ok(devices) = kittyaudio::device_names() {
                        // only lock when device lists do not match
                        if devices != prev_devices {
                            log::trace!("updated device list: {devices:?}");
                            *devices_arc.lock() = devices.clone();
                            prev_devices = devices;
                        }
                    }
                    std::thread::sleep(Duration::from_secs(4));
                }
            });
        }

        // init audio playback
        if !self.conf.use_fmod {
            self.maybe_init_kittyaudio();
        }
        unsafe {
            let _ = self
                .init_fmod()
                .map_err(|e| log::error!("failed to init fmod: {e}"));
        };

        // reload clickpacks
        let _ = self
            .reload_clickpacks()
            .map_err(|e| log::error!("failed to reload clickpacks: {e}"));

        // preload clickpack
        self.preload_clickpack();

        // init game hooks
        #[cfg(not(feature = "geode"))]
        {
            log::debug!("initializing hooks");
            unsafe { hooks::init_hooks().unwrap() };
        }
    }

    fn preload_clickpack(&mut self) {
        log::info!("preloading clickpack, order: {:?}", self.env.clickpack_ord);
        use std::thread::JoinHandle;

        let preload_clickpack = |path: PathBuf,
                                 toasts: Arc<Mutex<Toasts>>,
                                 join_handle: Option<JoinHandle<()>>,
                                 load_for: LoadClickpackFor|
         -> JoinHandle<()> {
            // wait for the last spawned thread finish first; order is important here
            // (clickpack loading is not threadsafe)
            if let Some(handle) = join_handle {
                log::info!("waiting for other preload thread to finish");
                handle.join().unwrap();
                log::info!("other preload thread finished, continuing");
            }

            let is_loading_clickpack = self.is_loading_clickpack.clone();
            std::thread::spawn(move || {
                Self::load_clickpack_thread(
                    |e| {
                        toasts
                            .lock()
                            .add(Toast::error(format!("Failed to preload clickpack: {e}")));
                    },
                    &path,
                    is_loading_clickpack,
                    load_for,
                )
            })
        };

        let mut prev_join_handle: Option<JoinHandle<()>> = None;
        for (clickpack_env, load_for) in &self.env.clickpack_ord {
            log::info!("preloading clickpack {clickpack_env:?} for {load_for:?}");
            match clickpack_env {
                ClickpackEnv::Name(name) => {
                    let mut found = false;
                    for dirname in &self.clickpacks {
                        if dirname == name {
                            prev_join_handle = Some(preload_clickpack(
                                PathBuf::from(".dcd").join("clickpacks").join(dirname),
                                self.toast_manager.toasts.clone(),
                                prev_join_handle,
                                *load_for,
                            ));
                            found = true;
                            break;
                        }
                    }
                    if !found {
                        self.toast_manager.toasts
                            .lock()
                            .error(&format!("Clickpack \"{name}\" not found"));
                    }
                }
                ClickpackEnv::Path(path) => {
                    prev_join_handle = Some(preload_clickpack(
                        path.clone(),
                        self.toast_manager.toasts.clone(),
                        prev_join_handle,
                        *load_for,
                    ));
                }
                ClickpackEnv::None => log::info!("env.json doesn't specify a clickpack"),
            }
        }
        if let Some(handle) = prev_join_handle {
            std::thread::spawn(|| {
                handle.join().unwrap();
                log::info!("all clickpacks preloaded, playing noise (if any)");
                unsafe { BOT.play_noise() };
            });
        }
    }

    fn get_pitch(&self) -> f64 {
        if self.conf.pitch_enabled {
            utils::f64_range(self.conf.pitch.from..=self.conf.pitch.to)
        } else {
            1.0
        }
    }

    #[allow(unused_variables)]
    pub fn on_init(&mut self, playlayer: usize) {
        #[cfg(not(feature = "geode"))]
        {
            self.playlayer.addr = playlayer;
        }

        self.event_handler.prev_times = ClickTimes::default();
        self.prev_pitch = 0.0;
        self.prev_volume = self.conf.volume_settings.global_volume;
        self.prev_spam_offset = 0.0;
        self.event_handler.is_in_level = true;
        self.event_handler.level_start = Instant::now();
        self.event_handler.dead_timer = f32::NAN;
    }

    pub fn on_reset(&mut self) {
        self.event_handler.level_start = Instant::now();
        //for dir in [
        //    &mut self.prev_times.jump,
        //    &mut self.prev_times.left,
        //    &mut self.prev_times.right,
        //] {
        //    for t in dir {
        //        t.time = 0.0;
        //        t.typ = ClickType::None;
        //    }
        //}
        self.event_handler.prev_times = ClickTimes::default();
        self.event_handler.dead_timer = f32::NAN;
    }

    pub fn on_exit(&mut self) {
        self.on_init(0);
        self.event_handler.is_in_level = false;
        self.event_handler.dead_timer = f32::NAN;
    }

    unsafe fn release_buttons(&mut self) {
        log::info!("releasing buttons on death");
        for (button, t) in [
            (Button::Jump, self.event_handler.prev_times.jump),
            (Button::Left, self.event_handler.prev_times.left),
            (Button::Right, self.event_handler.prev_times.right),
        ] {
            for (player, time) in t.iter().enumerate() {
                if time.typ.is_click() && time.time != 0.0 {
                    self.on_action(button, player == 1, false);
                }
            }
        }
    }

    pub unsafe fn on_death(&mut self) {
        if !self.conf.release_buttons_on_death {
            return;
        }

        let mut release_delay = self.conf.death_release_delay;
        let offset = self.conf.death_release_delay_offset;

        // release all buttons that are still pressed (or do that in the future)
        if release_delay == 0.0 && offset == 0.0 {
            self.release_buttons();
        } else {
            if offset != 0.0 {
                if self.conf.death_release_delay_neg {
                    release_delay += utils::f64_range(-offset..=offset);
                } else {
                    release_delay += utils::f64_range(0.0..=offset);
                }
            }
            if release_delay <= 0.0 {
                self.release_buttons();
                return;
            }
            self.event_handler.dead_timer_limit = release_delay as f32;
            self.event_handler.dead_timer = 0.0;
        }
    }

    pub unsafe fn on_update(&mut self, dt: f32) {
        if !self.event_handler.dead_timer.is_nan() {
            self.event_handler.dead_timer += dt;
            if self.event_handler.dead_timer >= self.event_handler.dead_timer_limit {
                self.event_handler.dead_timer = f32::NAN;
                self.release_buttons();
            }
        }
    }

    #[allow(unused_mut)]
    pub unsafe fn on_action(&mut self, button: Button, mut player2: bool, push: bool) {
        if self.clickpack.num_sounds == 0 || !self.event_handler.is_in_level || !self.conf.enabled {
            return;
        }
        #[cfg(not(feature = "geode"))]
        if player2 && !self.playlayer.is_null()
        /* FIXME(2.206): && !self.playlayer.level_settings().is_2player() */
        {
            player2 = self.conf.force_player2_sounds;
        }
        #[cfg(not(feature = "geode"))]
        if !self.playlayer.is_null() {
            return;
        }
        if button.is_platformer()
            && !self.conf.force_playing_platformer
            && !self.clickpack.has_platformer_sounds
        {
            return;
        }

        let now = self.time();
        if now == 0.0 {
            return;
        }
        let prev_time =
            self.event_handler.prev_times
                .get_prev_time(button, player2, self.conf.decouple_platformer);
        if prev_time.typ.is_click() && push {
            return;
        }
        let dt = (now - prev_time.time).abs();
        let click_type = ClickType::from_time(push, dt, &self.conf.timings);
        if self.conf.ignored_click_types.is_ignored(click_type) {
            return;
        }
        let use_fmod = self.conf.use_fmod;

        // get click
        let mut click = self
            .clickpack
            .get_random_click(click_type, player2, button)
            .sound
            .clone();
        let pitch = self.get_pitch() * self.conf.click_speedhack;
        // if self.conf.sync_speed_with_game {
        //     pitch *= gd_audio_pitch() as f64;
        // }
        if !use_fmod {
            click.set_playback_rate(PlaybackRate::Factor(pitch));
        }

        // compute & change volume
        {
            let vol = &self.conf.volume_settings;
            let mut volume = 1.0;
            if vol.volume_var != 0.0 {
                volume += utils::f64_range(-vol.volume_var..=vol.volume_var);
            }

            // calculate spam volume change
            if (push || vol.change_releases_volume) && dt < vol.spam_time && vol.enabled {
                let offset = (vol.spam_time - dt) * vol.spam_vol_offset_factor;
                self.prev_spam_offset = offset;
                volume -= offset.min(vol.max_spam_vol_offset);
            } else {
                self.prev_spam_offset = 0.0;
            }

            if button.is_platformer() {
                volume *= vol.platformer_volume_factor;
            }

            // multiply by global volume after all of the changes
            volume *= vol.global_volume;

            if !use_fmod {
                // blehh
                click.set_volume(volume as f32);
            }
            self.prev_volume = volume;
        }

        // stop all playing sounds (acb behaviour)
        if !use_fmod
            && self.conf.cut_sounds
            && (!click_type.is_release() || self.conf.cut_by_releases)
        {
            for sound in &self.audio_system.mixer.renderer.guard().sounds {
                // check if this is the noise sound, we don't want to stop it
                let sound_len = sound.guard().frames.len();
                if let Some(noise_sound) = &self.audio_system.noise_sound {
                    if noise_sound.guard().frames.len() == sound_len {
                        continue;
                    }
                }

                // kis!!
                sound.seek_to_end();
            }
        }
        // FIXME: temporary 2.2 fix
        self.audio_system.mixer.play(click);
        /*
        if !use_fmod {
            self.mixer.play(click);
        } else {
            /*
            unsafe {
                FMOD_System_PlaySound(
                    self.system,
                    click.fmod_sound,
                    std::ptr::null_mut(),
                    0,
                    &mut self.channel,
                );
                FMOD_Channel_SetPitch(self.channel, pitch as f32);
                FMOD_Channel_SetVolume(self.channel, self.prev_volume);
                FMOD_System_Update(self.system);
            }
            */
        }
        */
        self.event_handler.prev_times.set_time(
            button,
            player2,
            ClickTime {
                time: now,
                typ: click_type,
            },
            self.conf.decouple_platformer,
        );
        self.prev_pitch = pitch;
    }

    #[inline]
    fn time(&self) -> f64 {
        #[cfg(feature = "geode")]
        if self.playlayer_time != 0.0 && self.conf.use_ingame_time {
            self.playlayer_time
        } else {
            self.level_start.elapsed().as_secs_f64()
        }
        #[cfg(not(feature = "geode"))]
        if !self.playlayer.is_null() && self.conf.use_ingame_time {
            self.playlayer.time()
        } else {
            self.event_handler.level_start.elapsed().as_secs_f64()
        }
    }

    fn open_clickbot_toggle_toast(&self) {
        self.toast_manager.toasts.lock().info(if self.conf.enabled {
            "Enabled clickbot"
        } else {
            "Disabled clickbot"
        }));
    }

    fn reload_clickpacks(&mut self) -> Result<()> {
        let path = Path::new(".dcd/clickpacks");
        std::fs::create_dir_all(path)?;
        let dir = path.read_dir()?;
        let prev_clickpacks = std::mem::take(&mut self.clickpacks);
        for entry in dir {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                let name = path.file_name().unwrap().to_string_lossy().to_string();
                self.clickpack_db.mark_downloaded(&name, path, true);
                self.clickpacks.push(name);
            }
        }
        for prev in &prev_clickpacks {
            if !self.clickpacks.contains(prev) {
                self.clickpack_db
                    .mark_downloaded(prev, path.to_path_buf(), false);
            }
        }
        Ok(())
    }

    pub fn draw_ui(&mut self, ctx: &egui::Context) {
        // process hotkeys
        let wants_keyboard = ctx.wants_keyboard_input();
        let (toggle_menu, toggle_bot, toggle_noise) = ctx.input_mut(|i| {
            // for some reason it deadlocks when i put `ctx.wants_keyboard_input()` here?
            if wants_keyboard {
                (false, false, false)
            } else {
                (
                    self.conf.shortcuts.toggle_menu.pressed(i),
                    self.conf.shortcuts.toggle_bot.pressed(i),
                    self.conf.shortcuts.toggle_noise.pressed(i),
                )
            }
        });
        if toggle_menu {
            self.conf.hidden = !self.conf.hidden;
        }
        if toggle_bot {
            self.conf.enabled = !self.conf.enabled;
        }
        if toggle_noise {
            self.conf.play_noise = !self.conf.play_noise;
            self.play_noise();
        }

        // autosave config
        if self.conf != self.prev_conf && self.last_conf_save.elapsed() > Duration::from_secs(5) {
            self.last_conf_save = Instant::now();
            self.conf.save();
            self.prev_conf = self.conf.clone();
        }

        // change ui scale if needed
        ctx.set_zoom_factor(
            self.conf
                .ui_scale
                .clamp(*UI_SCALE_RANGE.start(), *UI_SCALE_RANGE.end()),
        );

        // dialog on first launch
        if self.env.is_first_launch() {
            let modal = Modal::new(ctx, "first_launch_dialog");
            modal.show(|ui| {
                modal.title(ui, "Welcome to dcd Live!");
                modal.body_and_icon(
                    ui,
                    "This seems to be your first time using dcd Live.\n\
                    • Press 1 to open the menu\n\
                    • Press 2 to toggle the clickbot\n\
                    • Explore ClickpackDB to download new clickpacks\n\
                    You can change the hotkeys in the Options section",
                    Icon::Info,
                );
                modal.buttons(ui, |ui| {
                    if self.first_launch_dialog_timeout > 0.0 {
                        ui.add_enabled_ui(false, |ui| {
                            let _ = ui
                                .button(format!("{:.0}…", self.first_launch_dialog_timeout.ceil()));
                        });
                        self.first_launch_dialog_timeout -= ctx.input(|i| i.unstable_dt);
                    } else if ui.button("Got it").clicked() {
                        self.env.set_first_launch(false);
                        self.env.save();
                        modal.close();
                    }
                    ui.hyperlink_to("Join the Discord server!", "https://discord.gg/BRVVVzxESu");
                });
            });
            modal.open();
        }

        // process toasts, even if not open
        if toggle_bot {
            self.open_clickbot_toggle_toast();
            self.play_noise();
        }
        if toggle_noise {
            self.open_noise_toggle_toast();
        }

        // don't draw and don't reload clickpacks if not open
        if self.conf.hidden {
            if matches!(self.conf.toast_visibility, ToastVisibility::AlwaysVisible) {
                self.toast_manager.toasts.lock().show(ctx); // but still draw toast queue
            }
            return;
        }

        // clickpack reloading
        if self.last_clickpack_reload.elapsed() > Duration::from_secs(5) {
            let _ = self
                .reload_clickpacks()
                .map_err(|e| log::error!("failed to reload clickpacks: {e}"));
            self.last_clickpack_reload = Instant::now();
        }

        // draw overlay
        let modal = Arc::new(Mutex::new(Modal::new(ctx, "global_modal")));

        // remove tooltip delay
        ctx.style_mut(|s| {
            s.interaction.tooltip_delay = 0.0;
            let shadow = Shadow {
                offset: [6.0, 8.0].into(),
                blur: 32.0,
                spread: 0.0,
                color: egui::Color32::from_black_alpha(120),
            };
            s.visuals.popup_shadow = shadow;
            s.visuals.window_shadow = shadow;
        });

        egui::Window::new("dcd Live").show(ctx, |ui| {
            ui.horizontal(|ui| {
                ui.selectable_value(&mut self.conf.stage, Stage::Clickpack, "Clickpack");
                ui.selectable_value(&mut self.conf.stage, Stage::Audio, "Audio");
                ui.selectable_value(&mut self.conf.stage, Stage::Options, "Options");
                // ui.selectable_value(&mut self.conf.stage, Stage::Cheats, "Cheats");
            });
            ui.separator();

            egui::ScrollArea::both().show(ui, |ui| {
                match self.conf.stage {
                    Stage::Clickpack => self.show_clickpack_window(ui, modal.clone()),
                    Stage::Audio => {
                        if ui
                            .checkbox(&mut self.conf.enabled, "Enable clickbot")
                            .changed()
                        {
                            self.open_clickbot_toggle_toast();
                            self.play_noise();
                        }

                        // ui.separator();
                        ui.add_enabled_ui(self.conf.enabled, |ui| {
                            self.show_audio_window(ui);
                        });
                    }
                    Stage::Options => self.show_options_window(ui, ctx, modal.clone()),
                };
            });
        });

        // show clickpackdb, if open
        self.show_clickpackdb_window(ctx, modal.clone());

        // show modal & toast queue
        modal.lock().show_dialog();
        if matches!(
            self.conf.toast_visibility,
            ToastVisibility::AlwaysVisible | ToastVisibility::VisibleWhenOpen
        ) {
            self.toast_manager.toasts.lock().show(ctx);
        }
    }

    #[cfg(not(feature = "geode"))]
    pub fn maybe_alloc_console(&self) {
        if self.conf.show_console && unsafe { AllocConsole() }.is_ok() {
            use std::sync::Once;
            static INIT_ONCE: Once = Once::new();
            INIT_ONCE.call_once(|| {
                simple_logger::SimpleLogger::new()
                    .init()
                    .expect("failed to initialize simple_logger");
            });
        } else {
            unsafe {
                let _ = FreeConsole();
            }
        }
    }

    fn show_options_window(
        &mut self,
        ui: &mut egui::Ui,
        ctx: &egui::Context,
        modal: Arc<Mutex<Modal>>,
    ) {
        ui.collapsing("Shortcuts", |ui| {
            let mut show_shortcut = |shortcut: &mut Shortcut, id: &'static str, name: &str| {
                ui.horizontal(|ui| {
                    ui.vertical(|ui| ui.add(Keybind::new(shortcut, id).with_text(name)));
                    if *shortcut != Shortcut::NONE
                        && ui
                            .button("Clear")
                            .on_hover_text("Set the shortcut to none")
                            .clicked()
                    {
                        *shortcut = Shortcut::NONE;
                    }
                });
            };
            show_shortcut(
                &mut self.conf.shortcuts.toggle_menu,
                "toggle_menu_keybind",
                "Toggle menu",
            );
            show_shortcut(
                &mut self.conf.shortcuts.toggle_bot,
                "toggle_bot_keybind",
                "Toggle bot",
            );
            show_shortcut(
                &mut self.conf.shortcuts.toggle_noise,
                "toggle_noise_keybind",
                "Toggle noise",
            );
        });
        ui.collapsing("Configuration", |ui| {
            ui.horizontal(|ui| {
                let slider = ui.add(
                    egui::Slider::new(&mut self.conf.ui_scale, UI_SCALE_RANGE)
                        .step_by(0.001)
                        .text("UI Scale"),
                );
                if slider.clicked() {
                    self.prev_scale_factor = ctx.zoom_factor();
                }
                egui_gl_hook::set_changing_scale(
                    slider.changed()
                        || slider.clicked()
                        || slider.dragged()
                        || slider.drag_stopped()
                        || slider.has_focus(),
                    self.prev_scale_factor,
                );
                if self.conf.ui_scale != 1.0
                    && ui
                        .button("Reset")
                        .on_hover_text("Reset to 100% scale")
                        .clicked()
                {
                    self.conf.ui_scale = 1.0;
                }
            });
            // #[cfg(not(feature = "geode"))]
            ui.horizontal(|ui| {
                help_text(
                    ui,
                    "Use an alternate button hook for bot compatibility",
                    |ui| ui.checkbox(&mut self.conf.use_alternate_hook, "Use alternate hook"),
                );
            });
            #[cfg(not(feature = "geode"))]
            help_text(ui, "Show debug console", |ui| {
                if ui
                    .checkbox(&mut self.conf.show_console, "Show console")
                    .changed()
                {
                    if self.conf.show_console {
                        self.maybe_alloc_console();
                    } else {
                        let _ = unsafe { FreeConsole() };
                    }
                }
            });
            help_text(
                ui,
                "Automatically save configuration changes every 5 seconds.\n\
                If this is disabled, the config will still be saved on graceful exit",
                |ui| ui.checkbox(&mut self.conf.autosave_config, "Auto-save config"),
            );

            egui::ComboBox::from_label("Toast Visibility")
                .selected_text(self.conf.toast_visibility.text())
                .show_ui(ui, |ui| {
                    ui.selectable_value(
                        &mut self.conf.toast_visibility,
                        ToastVisibility::AlwaysVisible,
                        ToastVisibility::AlwaysVisible.text(),
                    );
                    ui.selectable_value(
                        &mut self.conf.toast_visibility,
                        ToastVisibility::VisibleWhenOpen,
                        ToastVisibility::VisibleWhenOpen.text(),
                    );
                    ui.selectable_value(
                        &mut self.conf.toast_visibility,
                        ToastVisibility::NeverVisible,
                        ToastVisibility::NeverVisible.text(),
                    );
                });

            ui.horizontal(|ui| {
                ui.style_mut().spacing.item_spacing.x = 4.0;
                if ui
                    .button("Save")
                    .on_hover_text("Save the current configuration")
                    .clicked()
                {
                    self.conf.save();
                    self.toast_manager.toasts
                        .lock()
                        .success("Saved configuration to .dcd/config.json");
                }
                ui.style_mut().spacing.item_spacing.x = 4.0;
                if ui
                    .button("Load")
                    .on_hover_text("Load the config from .dcd/config.json")
                    .clicked()
                {
                    let conf = Config::load();
                    if let Ok(conf) = conf {
                        self.conf = conf;
                        self.apply_config();
                        self.toast_manager.toasts
                            .lock()
                            .success("Loaded configuration from .dcd/config.json");
                    } else if let Err(e) = conf {
                        show_error_dialog(modal.clone(), "Failed to load config!", &e.to_string());
                    }
                }
                ui.style_mut().spacing.item_spacing.x = 4.0;
                if ui
                    .button("Reset")
                    .on_hover_text("Reset the current configuration to defaults")
                    .clicked()
                {
                    let prev_stage = self.conf.stage;
                    self.conf = Config::default();
                    self.conf.stage = prev_stage; // don't switch current tab
                    self.apply_config();
                    self.toasts
                        .lock()
                        .add(Toast::info("Reset configuration to defaults"));
                }
                if ui
                    .button("Open folder")
                    .on_hover_text("Open .dcd folder")
                    .clicked()
                {
                    let _ = std::fs::create_dir_all(".dcd")
                        .map_err(|e| log::error!("failed to create .dcd: {e}"));
                    let _ = Command::new("explorer").arg(".dcd").spawn().map_err(|e| {
                        show_error_dialog(modal, "Failed to open folder!", &e.to_string());
                    });
                }
            });
        });
        ui.hyperlink_to("Join the Discord server!", "https://discord.gg/BRVVVzxESu");
        ui.allocate_space(ui.available_size() - vec2(0.0, 280.0));
    }

    fn get_device(&mut self) -> Device {
        Device::from_name(&self.env.selected_device).unwrap_or_default()
    }

    fn show_device_switcher(&mut self, ui: &mut egui::Ui) {
        ui.horizontal(|ui| {
            egui::ComboBox::from_label("Output device")
                .selected_text(&self.env.selected_device)
                .show_ui(ui, |ui| {
                    let devices = self.devices.lock().clone();
                    for device in &devices {
                        let is_selected = &self.env.selected_device == device;
                        if ui
                            .selectable_value(&mut self.env.selected_device, device.clone(), device)
                            .clicked()
                            && !is_selected
                        {
                            // start a new mixer on new device
                            log::info!("switching audio device to \"{device}\"");
                            self.maybe_init_kittyaudio();
                            self.play_noise();
                            self.env.save();
                            self.toasts
                                .lock()
                                .add(Toast::success(format!("Switched device to \"{device}\"")));
                            //kind: ToastKind::Success,
                            //text: format!("Switched device to \"{device}\"").into(),
                            //options: ToastOptions::default().duration_in_seconds(3.0),);
                        }
                    }
                })
                .response
                .on_disabled_hover_text("Not available with FMOD");
            if ui
                .button("Reset")
                .on_hover_text("Reset to the default audio device")
                .clicked()
            {
                self.mixer = Mixer::new();
                self.mixer.init();
                if let Ok(name) = Device::Default.name() {
                    self.env.selected_device = name.clone();
                    self.toasts
                        .lock()
                        .add(Toast::success(format!("Switched device to \"{name}\"")));
                }
                self.play_noise();
                self.env.save();
                log::debug!("reset audio device");
            }
        });
    }

    fn play_noise(&mut self) {
        let stop_kittyaudio_noise = |noise_sound: &mut Option<SoundHandle>| {
            if let Some(noise_sound) = noise_sound {
                noise_sound.set_playback_rate(PlaybackRate::Factor(1.0));
                noise_sound.set_loop_enabled(false);
                noise_sound.seek_to_end();
            }
            *noise_sound = None;
        };
        // let stop_fmod_noise = |fmodn: &mut *mut FMOD_CHANNEL| {
        //     unsafe { FMOD_Channel_Stop(*fmodn) };
        //     *fmodn = std::ptr::null_mut();
        // };
        let mut start_kittyaudio_noise = |noise_sound: &mut Option<SoundHandle>| {
            if let Some(mut noise) = self.clickpack.noise.clone() {
                noise.set_volume(self.conf.noise_volume as f32);
                noise.set_loop_enabled(true);
                let frames = noise.frames.len().saturating_sub(1);
                noise.set_loop_index(0..=frames);
                noise.set_playback_rate(PlaybackRate::Factor(self.conf.noise_speedhack));
                *noise_sound = Some(self.mixer.play(noise.sound));
            }
        };
        /*
        let start_fmod_noise = |fmodn: &mut *mut FMOD_CHANNEL| unsafe {
            if let Some(noise) = self.noise.clone() {
                // get sound length
                // let mut length = 0u32;
                // FMOD_Sound_GetLength(noise.fmod_sound, &mut length, FMOD_TIMEUNIT_PCM);

                // set loop points for sound
                FMOD_Sound_SetLoopCount(noise.fmod_sound, i32::MAX);
                // FMOD_Sound_SetLoopPoints(
                //     noise.fmod_sound,
                //     0,
                //     FMOD_TIMEUNIT_PCM,
                //     length,
                //     FMOD_TIMEUNIT_PCM,
                // );

                // play the sound
                FMOD_System_PlaySound(
                    self.system,
                    noise.fmod_sound,
                    std::ptr::null_mut(),
                    0,
                    fmodn,
                );

                // update channel
                FMOD_Channel_SetVolume(*fmodn, self.conf.noise_volume);
                // FMOD_Channel_SetLoopPoints(*fmodn, 0, FMOD_TIMEUNIT_PCM, 1024, FMOD_TIMEUNIT_PCM);
                FMOD_Channel_SetLoopCount(*fmodn, i32::MAX);
                FMOD_Channel_SetPitch(*fmodn, self.conf.noise_speedhack as f32);
                FMOD_System_Update(self.system);
            }
        };
        */

        stop_kittyaudio_noise(&mut self.noise_sound);
        // stop_fmod_noise(&mut self.fmod_noise_sound);

        if self.conf.play_noise && (self.conf.enabled || self.conf.play_noise_when_disabled) {
            if self.conf.use_fmod {
                // start_fmod_noise(&mut self.fmod_noise_sound);
            } else {
                start_kittyaudio_noise(&mut self.noise_sound);
            }
        }
    }

    fn open_noise_toggle_toast(&self) {
        self.toasts.lock().add(Toast::info(if self.conf.play_noise {
            "Playing noise"
        } else {
            "Stopped playing noise"
        }));
    }

    #[inline]
    fn is_loading_clickpack(&self) -> bool {
        self.is_loading_clickpack.load(Ordering::Relaxed)
    }

    fn show_audio_window(&mut self, ui: &mut egui::Ui) {
        ui.add_enabled_ui(
            self.clickpack.has_noise() && !self.is_loading_clickpack(),
            |ui| {
                ui.horizontal(|ui| {
                    if ui
                        .checkbox(&mut self.conf.play_noise, "Play noise")
                        .on_disabled_hover_text("Your clickpack doesn't have a noise file")
                        .on_hover_text("Play the noise file")
                        .changed()
                    {
                        self.play_noise();
                        self.open_noise_toggle_toast();
                    }

                    if drag_value(
                        ui,
                        &mut self.conf.noise_volume,
                        "Noise volume",
                        0.0..=f64::INFINITY,
                        "",
                    )
                    .drag_stopped()
                    {
                        self.play_noise(); // restart noise
                    }
                });
            },
        );

        /*
        help_text(
            ui,
            "Use the internal audio engine for integration with internal recorders",
            |ui| {
                if ui.checkbox(&mut self.conf.use_fmod, "Use FMOD").changed() {
                    if self.conf.use_fmod {
                        log::info!("destroying kittyaudio mixer");
                        self.mixer = Mixer::new();
                    } else {
                        self.maybe_init_kittyaudio();
                    }
                    self.play_noise();
                }
            },
        );
        */
        ui.add_enabled_ui(!self.conf.use_fmod, |ui| self.show_device_switcher(ui));

        ui.separator();

        ui.collapsing("Timings", |ui| {
            let timings_copy = self.conf.timings.clone();
            let timings = &mut self.conf.timings;

            help_text(
                ui,
                "Use in-game level time instead of real time.\n\
                Less realistic with practice mode or speedhack",
                |ui| {
                    ui.checkbox(&mut self.conf.use_ingame_time, "Use in-game time");
                },
            );
            help_text(
                ui,
                "Plays platformer left/right sounds even if your clickpack doesn't have them",
                |ui| {
                    ui.checkbox(
                        &mut self.conf.force_playing_platformer,
                        "Force playing platformer sounds",
                    );
                },
            );
            help_text(
                ui,
                "Plays player 2 sounds outside 2-player levels.\n\
                This will not have any effect if you use alternate hook!",
                |ui| {
                    ui.checkbox(
                        &mut self.conf.force_player2_sounds,
                        "Force playing player 2 sounds",
                    );
                },
            );
            help_text(
                ui,
                "Makes both platformer sounds have separate timings. Usually sounds bad",
                |ui| {
                    ui.checkbox(
                        &mut self.conf.decouple_platformer,
                        "Decouple platformer sounds",
                    );
                },
            );
            help_text(ui, "Releases all held buttons on death", |ui| {
                ui.checkbox(
                    &mut self.conf.release_buttons_on_death,
                    "Release buttons on death",
                );
            });
            if self.conf.release_buttons_on_death {
                drag_value(
                    ui,
                    &mut self.conf.death_release_delay,
                    "Release delay (sec)",
                    0.0..=f64::INFINITY,
                    "Delay before releasing buttons on death in seconds",
                );
                ui.horizontal(|ui| {
                    drag_value(
                        ui,
                        &mut self.conf.death_release_delay_offset,
                        "+/- (sec)",
                        0.0..=f64::INFINITY,
                        "Random offset for the death release delay in seconds",
                    );
                    ui.checkbox(&mut self.conf.death_release_delay_neg, "Negative?");
                });
            }

            ui.separator();

            drag_value(
                ui,
                &mut timings.hard,
                "Hard timing",
                timings_copy.regular..=f64::INFINITY,
                "Anything above this time between clicks plays hardclicks/hardreleases",
            );
            drag_value(
                ui,
                &mut timings.regular,
                "Regular timing",
                timings_copy.soft..=timings_copy.hard,
                "Anything above this time between clicks plays clicks/releases",
            );
            drag_value(
                ui,
                &mut timings.soft,
                "Soft timing",
                0.0..=timings_copy.regular,
                "Anything above this time between clicks plays softclicks/softreleases",
            );
            ui.label(format!(
                "Any value smaller than {:.2?} plays microclicks/microreleases",
                Duration::from_secs_f64(timings.soft),
            ))
        });

        ui.collapsing("Ignored click types", |ui| {
            ui.label(
                "Ignored click types will not be played. This can be useful for \
                disabling microreleases, for example",
            );
            let i = &mut self.conf.ignored_click_types;
            ui.checkbox(&mut i.hardclicks, "Hardclicks");
            ui.checkbox(&mut i.hardreleases, "Hardreleases");
            ui.checkbox(&mut i.clicks, "Clicks");
            ui.checkbox(&mut i.releases, "Releases");
            ui.checkbox(&mut i.softclicks, "Softclicks");
            ui.checkbox(&mut i.softreleases, "Softreleases");
            ui.checkbox(&mut i.microclicks, "Microclicks");
            ui.checkbox(&mut i.microreleases, "Microreleases");
            if i.any_ignored() && ui.button("Reset").clicked() {
                *i = IgnoredClickTypes::default();
            }
        });

        ui.collapsing("Pitch variation", |ui| {
            ui.label(
                "Pitch variation can make clicks sound more realistic by \
                    changing their pitch randomly.",
            );
            ui.checkbox(&mut self.conf.pitch_enabled, "Enable pitch variation");
            ui.add_enabled_ui(self.conf.pitch_enabled, |ui| {
                let p = &mut self.conf.pitch;
                drag_value(
                    ui,
                    &mut p.from,
                    "Minimum pitch",
                    0.0..=p.to,
                    "Minimum pitch value, 1.0 means no change",
                );
                drag_value(
                    ui,
                    &mut p.to,
                    "Maximum pitch",
                    p.from..=f64::INFINITY,
                    "Maximum pitch value, 1.0 means no change",
                );
            });
        });

        ui.collapsing("Volume settings", |ui| {
            help_text(
                ui,
                "Cut overlapping click sounds,\n\
                changes the sound significantly in spams",
                |ui| ui.checkbox(&mut self.conf.cut_sounds, "Cut sounds"),
            );
            if self.conf.cut_sounds {
                help_text(ui, "Allow clicks to be cut by releases", |ui| {
                    ui.checkbox(&mut self.conf.cut_by_releases, "Cut by releases")
                });
            }
            let vol = &mut self.conf.volume_settings;
            drag_value(
                ui,
                &mut vol.global_volume,
                "Global volume",
                0.0..=f64::INFINITY,
                "Constant volume multiplier for all sounds",
            );
            drag_value(
                ui,
                &mut vol.volume_var,
                "Volume variation",
                0.0..=f64::INFINITY,
                "Random volume variation (+/-)",
            );
            drag_value(
                ui,
                &mut vol.platformer_volume_factor,
                "Platformer volume factor",
                f64::NEG_INFINITY..=f64::INFINITY,
                "Multiplier of the platformer sound volume. If this is 0.5, \
                platformer sounds will be played at half volume",
            );
        });

        ui.collapsing("Spam volume changes", |ui| {
            ui.label("This can be used to lower volume in spams");
            let vol = &mut self.conf.volume_settings;
            help_text(ui, "Apply this logic to releases", |ui| {
                ui.checkbox(&mut vol.change_releases_volume, "Change releases volume")
            });
            drag_value(
                ui,
                &mut vol.spam_time,
                "Spam time",
                0.0..=f64::INFINITY,
                "Time between clicks which are considered spam clicks",
            );
            drag_value(
                ui,
                &mut vol.spam_vol_offset_factor,
                "Spam volume offset factor",
                f64::NEG_INFINITY..=f64::INFINITY,
                "The value which the volume offset factor is multiplied by",
            );
            drag_value(
                ui,
                &mut vol.max_spam_vol_offset,
                "Maximum volume offset",
                f64::NEG_INFINITY..=f64::INFINITY,
                "The maximum value of the volume offset",
            );
        });

        ui.collapsing("Speed", |ui| {
            ui.label("Adjust audio speed/pitch");
            ui.horizontal(|ui| {
                drag_value(
                    ui,
                    &mut self.conf.click_speedhack,
                    "Click speed",
                    0.0..=f64::INFINITY,
                    "Speed multiplier for clicks/releases",
                );
                if self.conf.click_speedhack != 1.0 && ui.button("Reset").clicked() {
                    self.conf.click_speedhack = 1.0;
                }
            });
            ui.horizontal(|ui| {
                if drag_value(
                    ui,
                    &mut self.conf.noise_speedhack,
                    "Noise speed",
                    0.0..=f64::INFINITY,
                    "Speed multiplier for noise. Only useful if your clickpack has a noise file",
                )
                .drag_stopped()
                {
                    self.play_noise();
                }
                if self.conf.noise_speedhack != 1.0 && ui.button("Reset").clicked() {
                    self.conf.noise_speedhack = 1.0;
                    self.play_noise();
                }
            });
            // help_text(ui, "Synchronize click speedhack with game speed", |ui| {
            //     ui.checkbox(&mut self.conf.sync_speed_with_game, "Sync speed with game")
            // });
        });

        ui.collapsing("Advanced", |ui| {
            // let last_bufsize = self.mixer.renderer.guard().last_buffer_size;
            // ui.label(format!("Real buffer size: {last_bufsize}"));
            help_text(
                ui,
                "Keep playing noise even if the clickbot is disabled",
                |ui| {
                    ui.checkbox(&mut self.conf.play_noise_when_disabled, "Play noise when disabled");
                },
            );

            let prev_bufsize = self.conf.buffer_size;
            help_text(
                ui,
                "Audio buffer size in samples. Lower value means lower latency.\n\
                Click \"Apply\" below to apply changes (if any)",
                |ui| {
                    ui.label("Buffer size");
                },
            );
            if u32_edit_field_min1(ui, &mut self.conf.buffer_size).changed() {
                self.buffer_size_changed = prev_bufsize != self.conf.buffer_size;
            }

            if self.buffer_size_changed {
                ui.horizontal(|ui| {
                    if ui
                        .button("Apply")
                        .on_hover_text("Apply buffer size changes")
                        .clicked()
                    {
                        if !self.conf.use_fmod {
                            self.maybe_init_kittyaudio();
                            self.play_noise();
                        } else {
                            self.show_fmod_buffersize_warn = true;
                        }
                        self.buffer_size_changed = false;
                    }

                    if self.conf.buffer_size > 300_000 {
                        ui.label(
                            RichText::new("WARN: Using a high buffer size might cause instability")
                                .color(Color32::YELLOW),
                        );
                    }
                });
            }
            if self.show_fmod_buffersize_warn && self.conf.buffer_size != self.startup_buffer_size {
                ui.label(
                    RichText::new("WARN: Restart the game to apply FMOD buffer size changes")
                        .color(Color32::YELLOW),
                );
            }
            if self.conf.use_fmod && self.startup_buffer_size < 10 {
                ui.label(
                    "If you don't hear any audio, it might be because your buffer size is set too low. \
                    The recommended value for FMOD is 10."
                );
            }
        });

        ui.allocate_space(vec2(100.0, 0.0));
    }

    fn apply_config(&mut self) {
        self.maybe_init_kittyaudio();
        self.play_noise();

        #[cfg(not(feature = "geode"))]
        self.maybe_alloc_console();
    }

    fn unload_clickpack(&mut self) {
        self.clickpack = Clickpack::default();
        self.stop_noise();
    }

    fn stop_noise(&mut self) {
        let prev_play_noise = self.conf.play_noise;
        self.conf.play_noise = false;
        self.play_noise();
        self.conf.play_noise = prev_play_noise;
    }

    fn load_clickpack_thread(
        err_fn: impl Fn(anyhow::Error),
        dir: &Path,
        is_loading_clickpack: Arc<AtomicBool>,
        load_for: LoadClickpackFor,
    ) {
        unsafe {
            is_loading_clickpack.store(true, Ordering::Relaxed);
            if load_for == LoadClickpackFor::All {
                BOT.unload_clickpack();
            } else {
                BOT.stop_noise();
            }
            let _ = BOT.clickpack.load_from_path(dir, load_for).map_err(|e| {
                log::error!("failed to load clickpack: {e}");
                err_fn(e);
            });
            BOT.play_noise();
            is_loading_clickpack.store(false, Ordering::Relaxed);
        }
    }

    fn select_clickpack_combobox(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) {
        let ellipsis = if self.clickpack.name.len() <= 14 {
            self.clickpack.name.clone()
        } else {
            format!("{:.14}…", self.clickpack.name)
        };
        egui::ComboBox::from_label("Select clickpack")
            .selected_text(ellipsis)
            .show_ui(ui, |ui| {
                for dirname in &self.clickpacks {
                    let is_loading_clickpack = self.is_loading_clickpack.clone();
                    let load_for = self.conf.load_clickpack_for;
                    let path = PathBuf::from(".dcd").join("clickpacks").join(dirname);
                    if ui
                        .selectable_label(&self.clickpack.name == dirname, dirname)
                        .clicked()
                    {
                        let modal_moved = modal.clone();
                        let dirname_moved = dirname.to_string();
                        std::thread::spawn(move || {
                            Self::load_clickpack_thread(
                                |e| {
                                    show_error_dialog(
                                        modal_moved.clone(),
                                        "Failed to load clickpack!",
                                        &e.to_string(),
                                    );
                                },
                                &path,
                                is_loading_clickpack,
                                load_for,
                            );
                            unsafe { BOT.env.update(ClickpackEnv::Name(dirname_moved), load_for) };
                        });
                    }
                }
            });
    }

    fn select_clickpack_button(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) -> bool {
        if !self.clickpacks.is_empty() {
            self.select_clickpack_combobox(ui, modal);
            return true;
        }
        ui.horizontal(|ui| {
            if ui
                .button("Select clickpack")
                .on_disabled_hover_text("Please wait…")
                .clicked()
            {
                let is_loading_clickpack = self.is_loading_clickpack.clone();
                let load_for = self.conf.load_clickpack_for;
                std::thread::spawn(move || {
                    let Some(dir) = FileDialog::new().pick_folder() else {
                        return;
                    };
                    log::debug!("selected clickpack {dir:?}");
                    Self::load_clickpack_thread(
                        |e| {
                            show_error_dialog(
                                modal.clone(),
                                "Failed to load clickpack!",
                                &e.to_string(),
                            );
                        },
                        &dir,
                        is_loading_clickpack,
                        load_for,
                    );
                    unsafe {
                        BOT.env.update(ClickpackEnv::Path(dir), load_for);
                    }
                });
            }
            if self.clickpack.num_sounds != 0 {
                ui.label(format!("Selected clickpack: \"{}\"", self.clickpack.name));
            } else {
                ui.label("…or put clickpacks in .dcd/clickpacks");
            }
        });
        false
    }

    fn show_select_clickpack_for_combobox(&mut self, ui: &mut egui::Ui) {
        ui.horizontal(|ui| {
            ui.label("Select clickpack for:");
            help_text(
                ui,
                "Choose a player to load the clickpack for.\n\
                E.g. if you choose Left1, the clickpack will be used for platformer sounds",
                |ui| {
                    egui::ComboBox::new("select_clickpack_for_combobox", "")
                        .selected_text(format!("{:?}", self.conf.load_clickpack_for))
                        .show_ui(ui, |ui| {
                            for load_for in [
                                LoadClickpackFor::All,
                                LoadClickpackFor::Player1,
                                LoadClickpackFor::Player2,
                                LoadClickpackFor::Left1,
                                LoadClickpackFor::Left2,
                                LoadClickpackFor::Right1,
                                LoadClickpackFor::Right2,
                            ] {
                                ui.selectable_value(
                                    &mut self.conf.load_clickpack_for,
                                    load_for,
                                    format!("{load_for:?}"),
                                );
                            }
                        });
                },
            );
        });
    }

    fn show_clickpack_window(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) {
        let is_loading_clickpack = self.is_loading_clickpack();
        if is_loading_clickpack {
            ui.horizontal(|ui| {
                ui.label("Loading clickpack…");
                ui.add(egui::Spinner::new());
            });
        }

        ui.add_enabled_ui(!is_loading_clickpack, |ui| {
            if !self.clickpacks.is_empty() {
                help_text(
                    ui,
                    "If there's no folders inside .dcd/clickpacks,\n\
                    there will be an option to choose the clickpack manually",
                    |ui| {
                        ui.label("Put clickpacks in .dcd/clickpacks");
                    },
                );
            }

            let show_open_folder = |ui: &mut egui::Ui| {
                if ui
                    .button("Open folder")
                    .on_hover_text("Open .dcd/clickpacks")
                    .clicked()
                {
                    let _ = std::fs::create_dir_all(".dcd/clickpacks")
                        .map_err(|e| log::error!("failed to create .dcd/clickpacks: {e}"));
                    let _ = Command::new("explorer")
                        .arg(".dcd\\clickpacks")
                        .spawn()
                        .map_err(|e| log::error!("failed to open .dcd/clickpacks: {e}"));
                }
            };

            self.show_select_clickpack_for_combobox(ui);

            let mut is_combobox = false;
            ui.horizontal(|ui| {
                is_combobox = self.select_clickpack_button(ui, modal);
                if !self.clickpack.name.is_empty() {
                    ui.style_mut().spacing.item_spacing.x = 4.0;
                    if ui.button("🗙").on_hover_text("Unload clickpack").clicked() {
                        self.unload_clickpack();
                        self.env.update(ClickpackEnv::None, LoadClickpackFor::All);
                    }
                }
                if is_combobox {
                    show_open_folder(ui);
                }
            });
            if !is_combobox {
                show_open_folder(ui);
            }
        });

        if self.clickpack.num_sounds != 0 {
            help_text(
                ui,
                "To add player 2 sounds, make a folder called \"player2\" \
                and put sounds for the second player there,\n\
                or use \"Select clickpack for\" to select a \
                seperate clickpack for the second player",
                |ui| {
                    ui.label(format!("{} sounds", self.clickpack.num_sounds));
                },
            );
        }
        ui.separator();
        ui.collapsing("ClickpackDB", |ui| {
            ui.label(
                "ClickpackDB is a collection of 300+ clickpacks \
                that can be easily downloaded from within dcd Live.",
            );
            if self.clickpack_db_open {
                if ui
                    .button("Close ClickpackDB")
                    .on_hover_text("This can also be done by clicking ✖ on the ClickpackDB window")
                    .clicked()
                {
                    self.clickpack_db_open = false;
                }
            } else if ui.button("Open ClickpackDB…").clicked() {
                self.clickpack_db_open = true;
            }
        });
        // ui.hyperlink_to(
        //     "Get more clickpacks in the Discord server!",
        //     "https://discord.gg/BRVVVzxESu",
        // );

        if !is_loading_clickpack && self.is_in_level {
            ui.collapsing("Debug", |ui| {
                ui.label("Last click times and types:");
                egui::Grid::new("times_grid")
                    .num_columns(2)
                    .min_col_width(130.0)
                    .striped(true)
                    .show(ui, |ui| {
                        for times in [
                            self.prev_times.jump,
                            self.prev_times.left,
                            self.prev_times.right,
                        ] {
                            for t in times {
                                ui.label(format!("{:.3?} | {:?}", t.time, t.typ));
                            }
                            ui.end_row();
                        }
                    });
                ui.label(format!(
                    "Last pitch: {:.4} ({}..={})",
                    self.prev_pitch, self.conf.pitch.from, self.conf.pitch.to
                ));
                ui.label(format!(
                    "Last volume: {:.4} (+/- {} * {})",
                    self.prev_volume,
                    self.conf.volume_settings.volume_var,
                    self.conf.volume_settings.global_volume
                ));
                ui.label(format!(
                    "Last spam volume offset: -{:.4}",
                    self.prev_spam_offset
                ));

                let format_path_keep_root = |path: &Path| path.to_string_lossy().replace('\\', "/");

                ui.label(format!(
                    "Clickpack path: {:?}",
                    format_path_keep_root(&self.clickpack.path)
                ));
            });
        }
    }

    fn show_clickpackdb_window(&mut self, ctx: &egui::Context, modal: Arc<Mutex<Modal>>) {
        if !self.clickpack_db_open {
            return;
        }
        if std::mem::take(&mut self.clickpack_db.has_refreshed) {
            log::debug!("doing clickpack reload for clickpackdb");
            let _ = self
                .reload_clickpacks()
                .map_err(|e| log::error!("failed to reload clickpacks for clickpackdb: {e}"));
        }
        egui::Window::new("ClickpackDB")
            .open(&mut self.clickpack_db_open)
            .show(ctx, |ui| {
                self.clickpack_db.show(ui, &ureq_get);
                if let Some(select_path) =
                    std::mem::replace(&mut self.clickpack_db.select_clickpack, None)
                {
                    self.conf.load_clickpack_for = LoadClickpackFor::All;
                    let is_loading_clickpack = self.is_loading_clickpack.clone();
                    let modal_moved = modal.clone();
                    std::thread::spawn(move || {
                        Self::load_clickpack_thread(
                            |e| {
                                show_error_dialog(
                                    modal_moved.clone(),
                                    "Failed to load clickpack!",
                                    &e.to_string(),
                                );
                            },
                            &select_path,
                            is_loading_clickpack,
                            LoadClickpackFor::All,
                        );
                        unsafe {
                            BOT.env.update(
                                ClickpackEnv::Name(
                                    select_path
                                        .file_name()
                                        .unwrap_or_default()
                                        .to_string_lossy()
                                        .to_string(),
                                ),
                                LoadClickpackFor::All,
                            )
                        };
                    });
                }
            });
    }
}

impl Drop for Bot {
    fn drop(&mut self) {
        // self.unload_clickpack();
        self.release_fmod()
    }
}
