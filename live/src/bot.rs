#[cfg(not(feature = "geode"))]
use crate::{game::PlayLayer, hooks};

use crate::{
    clickpack::{Button, ClickType, Clickpack, LoadClickpackFor, Pitch, Timings, VolumeSettings, SoundFilterCriteria, SoundQuality, SoundWrapper},
    utils,
};
use anyhow::Result;
use egui::{
    emath, epaint::Shadow, vec2, Color32, DragValue, Key, KeyboardShortcut, Modifiers, RichText,
};
use egui_clickpack_db::ClickpackDb;
use egui_keybind::{Bind, Keybind, Shortcut};
use egui_modal::{Icon, Modal};
use egui_notify::{Toast, Toasts};
use kittyaudio::{Device, Mixer, PlaybackRate, SoundHandle, StreamSettings};
use once_cell::sync::Lazy;
use parking_lot::Mutex;
use rfd::FileDialog;
use serde::{Deserialize, Serialize};
use std::{
    ops::RangeInclusive,
    path::{Path, PathBuf},
    process::Command,
    sync::{
        atomic::{AtomicBool, Ordering},
        Arc, OnceLock,
    },
    time::{Duration, Instant},
};

#[cfg(not(feature = "geode"))]
use windows::Win32::System::Console::{AllocConsole, FreeConsole};

/// Global bot state - using OnceLock for thread-safe initialization
static BOT_INSTANCE: OnceLock<Arc<Mutex<Bot>>> = OnceLock::new();

/// Get the global bot instance
pub fn get_bot() -> &'static Arc<Mutex<Bot>> {
    BOT_INSTANCE.get_or_init(|| Arc::new(Mutex::new(Bot::default())))
}

/// Legacy BOT struct for compatibility - provides access to the bot instance
pub struct BotWrapper;

impl BotWrapper {
    pub fn init(&self) {
        get_bot().lock().init();
    }

    pub fn draw_ui(&self, ctx: &egui::Context) {
        get_bot().lock().draw_ui(ctx);
    }

    pub fn on_action(&self, button: crate::clickpack::Button, player2: bool, push: bool) {
        unsafe { get_bot().lock().on_action(button, player2, push); }
    }

    pub fn on_reset(&self) {
        get_bot().lock().on_reset();
    }

    pub fn on_init(&self, playlayer: usize) {
        get_bot().lock().on_init(playlayer);
    }

    pub fn on_exit(&self) {
        get_bot().lock().on_exit();
    }

    pub fn on_death(&self) {
        unsafe { get_bot().lock().on_death(); }
    }

    pub fn on_update(&self, dt: f32) {
        unsafe { get_bot().lock().on_update(dt); }
    }

    pub fn play_noise(&self) {
        get_bot().lock().play_noise();
    }

    // Field access methods
    pub fn maybe_alloc_console(&self) {
        get_bot().lock().maybe_alloc_console();
    }

    // Access to conf field
    pub fn conf(&self) -> parking_lot::MutexGuard<'_, Bot> {
        get_bot().lock()
    }

    // Access to env field
    pub fn env(&self) -> parking_lot::MutexGuard<'_, Bot> {
        get_bot().lock()
    }

    // Direct field access for compatibility
    pub fn set_is_in_level(&self, value: bool) {
        get_bot().lock().is_in_level = value;
    }

    pub fn set_playlayer_time(&self, value: f64) {
        get_bot().lock().playlayer_time = value;
    }

    pub fn get_conf_show_console(&self) -> bool {
        get_bot().lock().conf.show_console
    }

    pub fn get_conf_force_player2_sounds(&self) -> bool {
        get_bot().lock().conf.force_player2_sounds
    }

    pub fn get_conf_use_alternate_hook(&self) -> bool {
        get_bot().lock().conf.use_alternate_hook
    }

    pub fn unload_clickpack(&self) {
        get_bot().lock().unload_clickpack();
    }

    pub fn stop_noise(&self) {
        get_bot().lock().stop_noise();
    }

    // Access to clickpack field
    pub fn load_clickpack_from_path(&self, dir: &std::path::Path, load_for: LoadClickpackFor) -> anyhow::Result<()> {
        get_bot().lock().clickpack.load_from_path(dir, load_for)
    }
}

impl std::ops::Deref for BotWrapper {
    type Target = ();

    fn deref(&self) -> &Self::Target {
        &()
    }
}

/// Global bot wrapper instance
pub static BOT: BotWrapper = BotWrapper;

const UI_SCALE_RANGE: RangeInclusive<f32> = 0.3..=5.0;

pub mod built_info {
    // generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/built.rs"));
}

#[derive(Serialize, Deserialize, Clone, PartialEq)]
pub struct Shortcuts {
    pub toggle_menu: Shortcut,
    pub toggle_bot: Shortcut,
    pub toggle_noise: Shortcut,
}

impl Default for Shortcuts {
    fn default() -> Self {
        Self {
            toggle_menu: Shortcut::new(
                Some(KeyboardShortcut::new(Modifiers::NONE, Key::Num1)),
                None,
            ),
            toggle_bot: Shortcut::new(
                Some(KeyboardShortcut::new(Modifiers::NONE, Key::Num2)),
                None,
            ),
            toggle_noise: Shortcut::NONE,
        }
    }
}

fn skip_serializing_selected_device(device: &str) -> bool {
    let is_default = if let Ok(name) = Device::Default.name() {
        name == device
    } else {
        false
    };
    device.is_empty() || is_default
}

#[derive(Serialize, Deserialize, Default, Clone, Debug, PartialEq)]
pub enum ClickpackEnv {
    #[default]
    None,
    Name(String),
    Path(PathBuf),
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Env {
    version: String,
    clickpack_ord: Vec<(ClickpackEnv, LoadClickpackFor)>,
    is_first_launch: bool,
    #[serde(
        default = "String::new",
        skip_serializing_if = "skip_serializing_selected_device"
    )]
    pub selected_device: String,
}

impl Default for Env {
    fn default() -> Self {
        Self {
            version: built_info::PKG_VERSION.to_string(),
            clickpack_ord: vec![(ClickpackEnv::None, LoadClickpackFor::All)],
            is_first_launch: true, // overriden later
            selected_device: String::new(),
        }
    }
}

impl Env {
    pub fn load() -> Self {
        let _ = std::fs::create_dir_all(".dcd")
            .map_err(|e| log::error!("failed to create .dcd directory: {e}"));

        let path = Path::new(".dcd/env.json");
        if let Ok(f) = std::fs::File::open(path) {
            let env = serde_json::from_reader(f);
            if let Ok(env) = env {
                return env;
            } else if let Err(e) = env {
                log::error!("failed to deserialize env: {e}");
            }
        }

        // if we're here we failed
        log::warn!("failed to deserialize env, writing defaults");
        if let Ok(f) = std::fs::File::create(path) {
            let _ = serde_json::to_writer_pretty(f, &Self::default())
                .map_err(|e| log::error!("failed to write env: {e}"));
        }

        Self::default()
    }

    pub fn save(&self) {
        log::info!("writing .dcd/env.json");
        let mut env = self.clone();
        env.version = built_info::PKG_VERSION.to_string();
        if let Ok(f) = std::fs::File::create(".dcd/env.json") {
            let _ = serde_json::to_writer_pretty(f, &env)
                .map_err(|e| log::error!("failed to write env: {e}"));
        }
    }

    pub fn update(&mut self, clickpack_env: ClickpackEnv, load_for: LoadClickpackFor) {
        match load_for {
            LoadClickpackFor::All => self.clickpack_ord = vec![(clickpack_env, load_for)],
            _ => {
                self.clickpack_ord.retain(|ord| ord.1 != load_for);
                log::info!("pushing to ord: ({clickpack_env:?}, {load_for:?})");
                self.clickpack_ord.push((clickpack_env, load_for));
            }
        }
        self.save();
    }

    // fn is_selected_by_path(&self) -> bool {
    //     self.clickpack_ord
    //         .iter()
    //         .any(|c| matches!(c.0, ClickpackEnv::Path(_)))
    // }
}

const fn true_value() -> bool {
    true
}

const fn default_buffer_size() -> u32 {
    512
}

const fn default_sync_threshold() -> f64 {
    85.0 // Default sync quality threshold for enhanced recording
}

const fn default_audio_quality() -> u32 {
    3 // Default audio quality level (1-5 scale)
}

const fn default_audio_sample_rate() -> u32 {
    48000 // Default sample rate for enhanced audio
}

const fn default_sound_profile() -> u32 {
    2 // Default sound profile: 1=Bass, 2=Balanced, 3=Treble, 4=Custom
}

const fn default_recording_buffer_size() -> u32 {
    240 // 4 seconds at 60fps for recording mode
}

const fn default_live_play_buffer_size() -> u32 {
    60 // 1 second at 60fps for live play mode
}

const fn default_frame_time_history_size() -> u32 {
    180 // 3 seconds of frame time history for analysis
}

const fn default_sync_audio_buffer() -> u32 {
    64 // Small buffer for low latency sync audio
}

const fn default_sync_audio_latency() -> f64 {
    0.001 // 1ms latency for sync audio
}

#[inline]
fn float_one<Num: emath::Numeric>() -> Num {
    Num::from_f64(1.0)
}

// clickpack, options, audio
#[derive(Serialize, Deserialize, Clone, PartialEq, Default, Copy)]
pub enum Stage {
    #[default]
    Clickpack,
    Audio,
    Options,
}

#[derive(Serialize, Deserialize, Clone, PartialEq, Default)]
struct IgnoredClickTypes {
    hardclicks: bool,
    hardreleases: bool,
    softclicks: bool,
    softreleases: bool,
    clicks: bool,
    releases: bool,
    microclicks: bool,
    microreleases: bool,
}

impl IgnoredClickTypes {
    #[inline]
    const fn is_ignored(&self, typ: ClickType) -> bool {
        match typ {
            ClickType::HardClick => self.hardclicks,
            ClickType::HardRelease => self.hardreleases,
            ClickType::SoftClick => self.softclicks,
            ClickType::SoftRelease => self.softreleases,
            ClickType::Click => self.clicks,
            ClickType::Release => self.releases,
            ClickType::MicroClick => self.microclicks,
            ClickType::MicroRelease => self.microreleases,
            ClickType::None => true,
        }
    }

    #[inline]
    const fn any_ignored(&self) -> bool {
        self.hardclicks
            || self.hardreleases
            || self.softclicks
            || self.softreleases
            || self.clicks
            || self.releases
            || self.microclicks
            || self.microreleases
    }
}

const fn death_release_delay_default() -> f64 {
    0.001
}

const fn death_release_delay_offset_default() -> f64 {
    0.13
}

#[derive(Serialize, Deserialize, Clone, Copy, PartialEq, Default)]
pub enum ToastVisibility {
    #[default]
    AlwaysVisible,
    VisibleWhenOpen,
    NeverVisible,
}

impl ToastVisibility {
    #[inline]
    const fn text(self) -> &'static str {
        match self {
            ToastVisibility::AlwaysVisible => "Always Visible",
            ToastVisibility::VisibleWhenOpen => "Visible in Menu",
            ToastVisibility::NeverVisible => "Never Visible",
        }
    }
}

#[derive(Serialize, Deserialize, Clone, PartialEq)]
pub struct Config {
    pub pitch_enabled: bool,
    pub pitch: Pitch,
    pub timings: Timings,
    pub volume_settings: VolumeSettings,
    #[serde(default = "Shortcuts::default")]
    pub shortcuts: Shortcuts,
    #[serde(default = "true_value")]
    pub enabled: bool,
    #[serde(default = "bool::default")]
    pub hidden: bool,
    #[serde(default = "default_buffer_size")]
    pub buffer_size: u32,
    #[serde(default = "bool::default")]
    pub play_noise: bool,
    #[serde(default = "float_one")]
    pub noise_volume: f64,
    #[serde(default = "bool::default")]
    pub force_playing_platformer: bool,
    #[serde(default = "bool::default")]
    pub use_alternate_hook: bool,
    #[serde(default = "bool::default")]
    pub show_console: bool,
    #[serde(default = "Stage::default")]
    pub stage: Stage,
    #[serde(default = "bool::default")]
    pub use_fmod: bool,
    #[serde(default = "bool::default")]
    pub cut_sounds: bool,
    #[serde(default = "bool::default")]
    pub cut_by_releases: bool,
    #[serde(default = "float_one")]
    pub click_speedhack: f64,
    // #[serde(default = "true_value")]
    // pub sync_speed_with_game: bool,
    #[serde(default = "float_one")]
    pub noise_speedhack: f64,
    #[serde(default = "LoadClickpackFor::default")]
    pub load_clickpack_for: LoadClickpackFor,
    #[serde(default = "bool::default")]
    pub decouple_platformer: bool,
    #[serde(default = "true_value")]
    pub autosave_config: bool,
    #[serde(default = "true_value")]
    pub release_buttons_on_death: bool,
    #[serde(default = "death_release_delay_default")]
    pub death_release_delay: f64,
    #[serde(default = "death_release_delay_offset_default")]
    pub death_release_delay_offset: f64,
    #[serde(default = "bool::default")]
    pub death_release_delay_neg: bool,
    #[serde(default = "bool::default")]
    pub force_player2_sounds: bool,
    #[serde(default = "bool::default")]
    pub play_noise_when_disabled: bool,
    #[serde(default = "IgnoredClickTypes::default")]
    ignored_click_types: IgnoredClickTypes,
    #[serde(default = "bool::default")]
    pub use_ingame_time: bool,
    // Enhanced gametime and sync recording features
    #[serde(default = "bool::default")]
    pub instant_sync_mode: bool,
    #[serde(default = "bool::default")]
    pub enhanced_recording_sync: bool,
    #[serde(default = "bool::default")]
    pub adaptive_timing_correction: bool,
    #[serde(default = "bool::default")]
    pub real_time_sync_display: bool,
    #[serde(default = "default_sync_threshold")]
    pub sync_quality_threshold: f64,
    // Enhanced audio system features
    #[serde(default = "default_audio_quality")]
    pub audio_quality_level: u32,
    #[serde(default = "bool::default")]
    pub enhanced_audio_timing: bool,
    #[serde(default = "bool::default")]
    pub audio_sound_selection: bool,
    #[serde(default = "default_audio_sample_rate")]
    pub audio_sample_rate: u32,
    // Advanced audio sound selection features
    #[serde(default = "bool::default")]
    pub advanced_sound_filtering: bool,
    #[serde(default = "bool::default")]
    pub dynamic_sound_selection: bool,
    #[serde(default = "bool::default")]
    pub audio_enhancement_mode: bool,
    #[serde(default = "default_sound_profile")]
    pub sound_profile: u32,
    #[serde(default = "String::new")]
    pub preferred_audio_device: String,
    #[serde(default = "float_one")]
    pub ui_scale: f32,
    #[serde(default)]
    pub toast_visibility: ToastVisibility,
    // Enhanced recording and live play features
    #[serde(default = "bool::default")]
    pub recording_mode_optimization: bool,
    #[serde(default = "bool::default")]
    pub live_play_optimization: bool,
    #[serde(default = "bool::default")]
    pub frame_time_analysis: bool,
    #[serde(default = "bool::default")]
    pub sync_drift_monitoring: bool,
    #[serde(default = "bool::default")]
    pub real_time_performance_metrics: bool,
    #[serde(default = "default_recording_buffer_size")]
    pub recording_buffer_size: u32,
    #[serde(default = "default_live_play_buffer_size")]
    pub live_play_buffer_size: u32,
    #[serde(default = "default_frame_time_history_size")]
    pub frame_time_history_size: u32,
    // Enhanced sync recording features
    #[serde(default = "SyncMode::default")]
    pub sync_mode: SyncMode,
    #[serde(default = "bool::default")]
    pub auto_mode_detection: bool,
    #[serde(default = "bool::default")]
    pub sync_mode_indicators: bool,
    #[serde(default = "bool::default")]
    pub adaptive_buffer_sizing: bool,
    #[serde(default = "bool::default")]
    pub real_time_mode_switching: bool,
    // Enhanced audio system features for sync optimization
    #[serde(default = "bool::default")]
    pub sync_optimized_audio: bool,
    #[serde(default = "bool::default")]
    pub adaptive_audio_timing: bool,
    #[serde(default = "bool::default")]
    pub sync_aware_volume: bool,
    #[serde(default = "bool::default")]
    pub frame_perfect_audio: bool,
    #[serde(default = "default_sync_audio_buffer")]
    pub sync_audio_buffer: u32,
    #[serde(default = "default_sync_audio_latency")]
    pub sync_audio_latency: f64,
    #[serde(default = "bool::default")]
    pub real_time_audio_analysis: bool,
    #[serde(default = "bool::default")]
    pub audio_sync_correction: bool,
    // Audio visualization settings
    pub audio_visualization_enabled: bool,
    pub waveform_display_mode: WaveformDisplayMode,
    pub spectrum_display_mode: SpectrumDisplayMode,
    pub visualization_opacity: f32,
    pub visualization_scale: f32,
    pub show_audio_peaks: bool,
    pub audio_peak_threshold: f32,
    // Sync performance analytics
    pub sync_performance_history: Vec<SyncPerformanceData>,
    pub sync_analytics_enabled: bool,
    pub sync_quality_trends: Vec<f64>,
    pub sync_latency_trends: Vec<f64>,
    pub sync_accuracy_trends: Vec<f64>,
    pub sync_performance_score: f64,
    pub sync_improvement_rate: f64,
    pub sync_consistency_score: f64,
    // Plugin system
    pub plugins_enabled: bool,
    pub active_plugins: Vec<String>,
    pub plugin_configs: std::collections::HashMap<String, serde_json::Value>,
    pub plugin_hooks: Vec<PluginHook>,
    pub plugin_api_version: String,
}

impl Config {
    #[inline]
    pub fn fixup(mut self) -> Self {
        self.buffer_size = self.buffer_size.max(1);
        #[cfg(feature = "geode")]
        {
            self.show_console = false;
        }
        self.ui_scale = self
            .ui_scale
            .clamp(*UI_SCALE_RANGE.start(), *UI_SCALE_RANGE.end());
        self
    }
}

impl Default for Config {
    fn default() -> Self {
        Self {
            pitch_enabled: true,
            pitch: Pitch::default(),
            timings: Timings::default(),
            volume_settings: VolumeSettings::default(),
            shortcuts: Shortcuts::default(),
            enabled: true,
            hidden: false,
            buffer_size: default_buffer_size(),
            play_noise: false,
            noise_volume: 1.0,
            force_playing_platformer: false,
            use_alternate_hook: false,
            show_console: false,
            stage: Stage::default(),
            use_fmod: false,
            cut_sounds: false,
            cut_by_releases: false,
            click_speedhack: 1.0,
            noise_speedhack: 1.0,
            load_clickpack_for: LoadClickpackFor::All,
            decouple_platformer: false,
            autosave_config: true,
            release_buttons_on_death: true,
            death_release_delay: death_release_delay_default(),
            death_release_delay_offset: death_release_delay_offset_default(),
            death_release_delay_neg: false,
            force_player2_sounds: false,
            play_noise_when_disabled: false,
            ignored_click_types: IgnoredClickTypes::default(),
            use_ingame_time: false,
            // Enhanced gametime and sync recording features defaults
            instant_sync_mode: false,
            enhanced_recording_sync: false,
            adaptive_timing_correction: false,
            real_time_sync_display: false,
            sync_quality_threshold: default_sync_threshold(),
            // Enhanced audio system defaults
            audio_quality_level: default_audio_quality(),
            enhanced_audio_timing: false,
            audio_sound_selection: false,
            audio_sample_rate: default_audio_sample_rate(),
            ui_scale: 1.0,
            toast_visibility: ToastVisibility::default(),
            recording_mode_optimization: false,
            live_play_optimization: false,
            frame_time_analysis: false,
            sync_drift_monitoring: false,
            real_time_performance_metrics: false,
            recording_buffer_size: default_recording_buffer_size(),
            live_play_buffer_size: default_live_play_buffer_size(),
            frame_time_history_size: default_frame_time_history_size(),
            sync_mode: SyncMode::default(),
            auto_mode_detection: false,
            sync_mode_indicators: false,
            adaptive_buffer_sizing: false,
            real_time_mode_switching: false,
            sync_optimized_audio: false,
            adaptive_audio_timing: false,
            sync_aware_volume: false,
            frame_perfect_audio: false,
            sync_audio_buffer: default_sync_audio_buffer(),
            sync_audio_latency: default_sync_audio_latency(),
            real_time_audio_analysis: false,
            audio_sync_correction: false,
            advanced_sound_filtering: false,
            dynamic_sound_selection: false,
            audio_enhancement_mode: false,
            sound_profile: default_sound_profile(),
            preferred_audio_device: String::new(),
            audio_visualization_enabled: false,
            waveform_display_mode: WaveformDisplayMode::default(),
            spectrum_display_mode: SpectrumDisplayMode::default(),
            visualization_opacity: 1.0,
            visualization_scale: 1.0,
            show_audio_peaks: false,
            audio_peak_threshold: 0.0,
            sync_performance_history: Vec::new(),
            sync_analytics_enabled: false,
            sync_quality_trends: Vec::new(),
            sync_latency_trends: Vec::new(),
            sync_accuracy_trends: Vec::new(),
            sync_performance_score: 0.0,
            sync_improvement_rate: 0.0,
            sync_consistency_score: 0.0,
            plugins_enabled: false,
            active_plugins: Vec::new(),
            plugin_configs: std::collections::HashMap::new(),
            plugin_hooks: Vec::new(),
            plugin_api_version: String::new(),
        }
    }
}

impl Config {
    pub fn load() -> Result<Self> {
        let mut path = PathBuf::from(".dcd/");
        log::debug!("creating directory {path:?}");
        std::fs::create_dir_all(&path)?;
        path.push("config.json");

        // try to read config
        log::debug!("trying to read config at {path:?}");
        if let Ok(f) = std::fs::File::open(&path) {
            let config = serde_json::from_reader(f)
                .map_err(|e| log::error!("failed to deserialize config at {path:?}: {e}"));
            if let Ok(config) = config {
                log::debug!("successfully read config at {path:?}");
                return Ok(config);
            }
        }

        // failed to read config, write default config
        let config = Self::default();
        log::debug!("creating file {path:?}");
        let f = std::fs::File::create(&path)?;
        log::debug!("writing default config to {path:?}");
        serde_json::to_writer_pretty(f, &config)?;
        Ok(config)
    }

    pub fn save(&self) {
        let Ok(f) = std::fs::File::create(".dcd/config.json") else {
            log::error!("failed to create config.json!");
            return;
        };
        let _ = serde_json::to_writer_pretty(f, self)
            .map_err(|e| log::error!("failed to write config: {e}"))
            .map(|_| log::debug!("successfully saved config to \".dcd/config.json\""));
    }
}

#[derive(Default, Clone, Copy)]
struct ClickTime {
    time: f64,
    typ: ClickType,
}

#[derive(Default)]
pub struct ClickTimes {
    jump: [ClickTime; 2],  // 2 players
    left: [ClickTime; 2],  // 2 players
    right: [ClickTime; 2], // 2 players
}

impl ClickTimes {
    #[inline]
    fn set_time(&mut self, button: Button, player2: bool, t: ClickTime, decouple: bool) {
        match button {
            Button::Jump => self.jump[player2 as usize] = t,
            Button::Left => self.left[player2 as usize] = t,
            Button::Right => {
                // TODO:
                // WTF:  `(if decouple { self.right } else { self.left })[player2 as usize] = time``
                //       causes a Rust miscompilation if `decouple` is false???
                if decouple {
                    self.right[player2 as usize] = t;
                } else {
                    self.left[player2 as usize] = t;
                }
            }
        }
    }

    #[inline]
    const fn get_prev_time(&self, button: Button, player2: bool, decouple: bool) -> ClickTime {
        match button {
            Button::Jump => self.jump[player2 as usize],
            Button::Left => self.left[player2 as usize],
            Button::Right => {
                if decouple {
                    self.right[player2 as usize]
                } else {
                    self.left[player2 as usize]
                }
            }
        }
    }
}

pub struct Bot {
    pub conf: Config,
    pub prev_conf: Config,
    pub last_conf_save: Instant,
    pub mixer: Mixer,
    #[cfg(not(feature = "geode"))]
    pub playlayer: PlayLayer,
    pub prev_times: ClickTimes,
    pub is_loading_clickpack: Arc<AtomicBool>,
    pub prev_pitch: f64,
    pub prev_volume: f64,
    pub prev_spam_offset: f64,
    pub buffer_size_changed: bool,
    pub noise_sound: Option<SoundHandle>,
    pub clickpacks: Vec<String>,
    pub last_clickpack_reload: Instant,
    // pub system: *mut FMOD_SYSTEM,
    // pub channel: *mut FMOD_CHANNEL,
    pub env: Env,
    pub toasts: Arc<Mutex<Toasts>>,
    // pub fmod_noise_sound: *mut FMOD_CHANNEL,
    pub show_fmod_buffersize_warn: bool,
    pub startup_buffer_size: u32,
    pub is_in_level: bool,
    pub playlayer_time: f64,
    pub clickpack: Clickpack,
    pub first_launch_dialog_timeout: f32,
    pub level_start: Instant,
    pub clickpack_db: ClickpackDb,
    pub clickpack_db_open: bool,
    pub prev_scale_factor: f32,
    pub dead_timer: f32,
    pub dead_timer_limit: f32,
    pub devices: Arc<Mutex<Vec<String>>>,
    // Modal management to prevent duplication
    pub global_modal: Option<Arc<Mutex<Modal>>>,
    pub first_launch_modal: Option<Modal>,
    // Frame audio history for frame-perfect audio processing
    pub frame_audio_history: Vec<(ClickType, f64)>,
    // Audio performance history for real-time audio analysis
    pub audio_performance_history: Vec<f64>,
    pub audio_latency_history: Vec<f64>,
    // Audio visualization data
    pub audio_waveform_data: Vec<f32>,
    pub audio_spectrum_data: Vec<f32>,
    pub waveform_history: Vec<Vec<f32>>,
    pub spectrum_history: Vec<Vec<f32>>,
    pub visualization_fps: f32,
    pub visualization_smoothing: f32,
    // Sync performance analytics
    pub sync_performance_history: Vec<SyncPerformanceData>,
    pub sync_analytics_enabled: bool,
    pub sync_quality_trends: Vec<f64>,
    pub sync_latency_trends: Vec<f64>,
    pub sync_accuracy_trends: Vec<f64>,
    pub sync_performance_score: f64,
    pub sync_improvement_rate: f64,
    pub sync_consistency_score: f64,
    // Plugin system
    pub plugins_enabled: bool,
    pub active_plugins: Vec<String>,
    pub plugin_configs: std::collections::HashMap<String, serde_json::Value>,
    pub plugin_hooks: Vec<PluginHook>,
    pub plugin_api_version: String,
}

impl Default for Bot {
    fn default() -> Self {
        let conf = Config::load().unwrap_or_default().fixup();
        let startup_buffer_size = conf.buffer_size;
        let now = Instant::now();
        Self {
            conf: conf.clone(),
            prev_conf: conf,
            last_conf_save: now,
            mixer: Mixer::new(),
            #[cfg(not(feature = "geode"))]
            playlayer: PlayLayer::NULL,
            prev_times: ClickTimes::default(),
            is_loading_clickpack: Arc::new(AtomicBool::new(false)),
            prev_pitch: f64::NAN,
            prev_volume: f64::NAN,
            prev_spam_offset: f64::NAN,
            buffer_size_changed: false,
            noise_sound: None,
            clickpacks: vec![],
            last_clickpack_reload: now,
            // system: std::ptr::null_mut(),
            // channel: std::ptr::null_mut(),
            env: Env::load(),
            toasts: Arc::new(Mutex::new(Toasts::new())),
            // fmod_noise_sound: std::ptr::null_mut(),
            show_fmod_buffersize_warn: false,
            startup_buffer_size,
            is_in_level: false,
            playlayer_time: 0.0,
            clickpack: Clickpack::default(),
            first_launch_dialog_timeout: 3.0,
            level_start: now,
            clickpack_db: ClickpackDb::default(),
            clickpack_db_open: false,
            prev_scale_factor: 1.0,
            dead_timer: f32::NAN,
            dead_timer_limit: 0.0,
            devices: Arc::new(Mutex::new(vec![])),
            // Initialize modal fields as None - they will be created on first use
            global_modal: None,
            first_launch_modal: None,
            // Initialize frame audio history
            frame_audio_history: Vec::new(),
            // Initialize audio performance history
            audio_performance_history: Vec::new(),
            audio_latency_history: Vec::new(),
            audio_waveform_data: Vec::new(),
            audio_spectrum_data: Vec::new(),
            waveform_history: Vec::new(),
            spectrum_history: Vec::new(),
            visualization_fps: 60.0,
            visualization_smoothing: 0.8,
            // Initialize sync analytics
            sync_performance_history: Vec::new(),
            sync_analytics_enabled: false,
            sync_quality_trends: Vec::new(),
            sync_latency_trends: Vec::new(),
            sync_accuracy_trends: Vec::new(),
            sync_performance_score: 0.0,
            sync_improvement_rate: 0.0,
            sync_consistency_score: 0.0,
            // Initialize plugin system
            plugins_enabled: false,
            active_plugins: Vec::new(),
            plugin_configs: std::collections::HashMap::new(),
            plugin_hooks: Vec::new(),
            plugin_api_version: String::new(),
        }
    }
}

fn help_text<R>(ui: &mut egui::Ui, help: &str, add_contents: impl FnOnce(&mut egui::Ui) -> R) {
    if help.is_empty() {
        add_contents(ui); // don't show help icon if there's no help text
        return;
    }
    ui.horizontal(|ui| {
        add_contents(ui);
        ui.add_enabled_ui(false, |ui| ui.label("(?)").on_disabled_hover_text(help));
    });
}

/// Value is always min clamped with 1.
fn u32_edit_field_min1(ui: &mut egui::Ui, value: &mut u32) -> egui::Response {
    let mut tmp_value = format!("{value}");
    let res = ui.text_edit_singleline(&mut tmp_value);
    if let Ok(result) = tmp_value.parse::<u32>() {
        *value = result.max(1);
    }
    res
}

/*
#[inline]
fn gd_audio_pitch() -> f32 {
    let mut pitch = 1.0f32;
    unsafe {
        let _ = FMOD_Channel_GetPitch(
            FMODAudioEngine::shared().current_sound_channel(),
            &mut pitch,
        );
    };
    pitch
}
*/

fn show_error_dialog(modal: Arc<Mutex<Modal>>, title: &str, body: &str) {
    log::error!("{title}: {body}");
    modal
        .lock()
        .dialog()
        .with_title(title)
        .with_body(utils::capitalize_first_letter(body))
        .with_icon(Icon::Error)
        .open();
}

fn drag_value<Num: emath::Numeric>(
    ui: &mut egui::Ui,
    value: &mut Num,
    text: impl Into<String>,
    clamp_range: RangeInclusive<Num>,
    help: &str,
) -> egui::Response {
    let mut resp = None;
    help_text(ui, help, |ui| {
        resp = Some(
            ui.add(
                DragValue::new(value)
                    .clamp_range(clamp_range.clone())
                    .speed(0.01),
            ),
        );
        ui.label(
            if resp.as_ref().unwrap().dragged()
                && (clamp_range.start() == value || clamp_range.end() == value)
            {
                RichText::new(text).color(Color32::LIGHT_RED)
            } else {
                RichText::new(text)
            },
        );
    });
    resp.unwrap()
}

const USER_AGENT: &str = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/37.0.2062.94 Chrome/37.0.2062.94 Safari/537.36";

fn ureq_agent() -> ureq::Agent {
    ureq::AgentBuilder::new()
        .timeout_read(Duration::from_secs(15))
        .timeout_write(Duration::from_secs(15))
        .user_agent(USER_AGENT)
        .build()
}

fn ureq_get(url: &str) -> Result<Vec<u8>, String> {
    let mut buf = Vec::new();
    ureq_agent()
        .get(url)
        .call()
        .map_err(|e| e.to_string())?
        .into_reader()
        .read_to_end(&mut buf)
        .map_err(|_| "failed to read body".to_string())?;
    Ok(buf)
}

impl Bot {
    /// Reset UI state to prevent any lingering modal instances
    pub fn reset_ui_state(&mut self) {
        self.global_modal = None;
        self.first_launch_modal = None;
    }

    fn maybe_init_kittyaudio(&mut self) {
        if self.conf.use_fmod {
            return;
        }
        log::debug!("starting enhanced kittyaudio playback thread with quality level {}", self.conf.audio_quality_level);
        self.mixer = Mixer::new();
        let device = self.get_device();

        // Enhanced audio settings based on quality level
        let enhanced_buffer_size = if self.conf.enhanced_audio_timing {
            match self.conf.audio_quality_level {
                1 => self.conf.buffer_size * 2,      // Conservative
                2 => (self.conf.buffer_size * 3) / 2, // Balanced
                3 => self.conf.buffer_size,           // Standard
                4 => self.conf.buffer_size / 2,      // Performance
                5 => self.conf.buffer_size / 4,      // Ultra-low latency
                _ => self.conf.buffer_size,
            }
        } else {
            self.conf.buffer_size
        };

        self.mixer.init_ex(
            device,
            StreamSettings {
                buffer_size: Some(enhanced_buffer_size),
                sample_rate: if self.conf.audio_sound_selection {
                    Some(self.conf.audio_sample_rate)
                } else {
                    None
                },
                ..Default::default()
            },
        );

        log::info!("Enhanced audio initialized - Quality: {}, Buffer: {}, Sample Rate: {}",
                  self.conf.audio_quality_level, enhanced_buffer_size, self.conf.audio_sample_rate);
    }

    pub unsafe fn init_fmod(&mut self) -> Result<()> {
        /*
        const SYSTEM_SAMPLERATE: i32 = 48_000;
        log::info!("initializing fmod system");
        if !self.system.is_null() {
            self.release_fmod();
        }

        FMOD_System_Create(&mut self.system, FMOD_VERSION).fmod_result()?;
        let extra_driver_data = FMODAudioEngine::shared().extra_driver_data();

        FMOD_System_SetSoftwareFormat(self.system, SYSTEM_SAMPLERATE, FMOD_SPEAKERMODE_STEREO, 0)
            .fmod_result()?;

        // set buffer size
        /*
        FMOD_System_SetStreamBufferSize(self.system, self.conf.buffer_size, FMOD_TIMEUNIT_PCM)
            .fmod_result()?;

        let mut numbuffers = 0i32;
        let mut bufferlength = 0u32;
        FMOD_System_GetDSPBufferSize(self.system, &mut bufferlength, &mut numbuffers)
            .fmod_result()?;
        log::info!(
            "FMOD_System_GetDSPBufferSize: bufferlength: {bufferlength}, numbuffers: {numbuffers}"
        );
        FMOD_System_SetDSPBufferSize(self.system, self.conf.buffer_size, numbuffers)
            .fmod_result()?;
        */

        // init system
        self.fmod_apply_buffer_size()?;
        FMOD_System_Init(self.system, 2048, FMOD_INIT_NORMAL, extra_driver_data).fmod_result()?;

        log::info!("successfully initialized fmod system, samplerate: {SYSTEM_SAMPLERATE}");
        */
        Ok(())
    }

    //fn fmod_apply_buffer_size(&self) -> Result<()> {
    //    /*
    //    unsafe {
    //        FMOD_System_SetStreamBufferSize(self.system, self.conf.buffer_size, FMOD_TIMEUNIT_PCM)
    //            .fmod_result()?;
    //
    //        let mut numbuffers = 0i32;
    //        let mut bufferlength = 0u32;
    //        FMOD_System_GetDSPBufferSize(self.system, &mut bufferlength, &mut numbuffers)
    //            .fmod_result()?;
    //        log::info!(
    //            "FMOD_System_GetDSPBufferSize: bufferlength: {bufferlength}, numbuffers: {numbuffers}"
    //        );
    //        FMOD_System_SetDSPBufferSize(self.system, self.conf.buffer_size, numbuffers)
    //            .fmod_result()?;
    //    }
    //    */
    //    Ok(())
    //}

    pub fn release_fmod(&mut self) {
        /*
        let _ = unsafe {
            FMOD_System_Release(self.system)
                .fmod_result()
                .map_err(|e| log::error!("failed to release fmod system: {e}"))
        };
        self.system = std::ptr::null_mut();
        */
    }

    pub fn init(&mut self) {
        {
            let devices_arc = self.devices.clone();
            std::thread::spawn(move || {
                let mut prev_devices = vec![];
                loop {
                    if unsafe { BOT.conf().conf.use_fmod } {
                        continue;
                    }
                    if let Ok(devices) = kittyaudio::device_names() {
                        // only lock when device lists do not match
                        if devices != prev_devices {
                            log::trace!("updated device list: {devices:?}");
                            *devices_arc.lock() = devices.clone();
                            prev_devices = devices;
                        }
                    }
                    std::thread::sleep(Duration::from_secs(4));
                }
            });
        }

        // init audio playback
        if !self.conf.use_fmod {
            self.maybe_init_kittyaudio();
        }
        
        // init plugin system
        self.init_plugin_system();
        unsafe {
            let _ = self
                .init_fmod()
                .map_err(|e| log::error!("failed to init fmod: {e}"));
        };

        // reload clickpacks
        let _ = self
            .reload_clickpacks()
            .map_err(|e| log::error!("failed to reload clickpacks: {e}"));

        // preload clickpack
        self.preload_clickpack();

        // init game hooks
        #[cfg(not(feature = "geode"))]
        {
            log::debug!("initializing hooks");
            unsafe { hooks::init_hooks().unwrap() };
        }
    }

    fn preload_clickpack(&mut self) {
        log::info!("preloading clickpack, order: {:?}", self.env.clickpack_ord);
        use std::thread::JoinHandle;

        let preload_clickpack = |path: PathBuf,
                                 toasts: Arc<Mutex<Toasts>>,
                                 join_handle: Option<JoinHandle<()>>,
                                 load_for: LoadClickpackFor|
         -> JoinHandle<()> {
            // wait for the last spawned thread finish first; order is important here
            // (clickpack loading is not threadsafe)
            if let Some(handle) = join_handle {
                log::info!("waiting for other preload thread to finish");
                handle.join().unwrap();
                log::info!("other preload thread finished, continuing");
            }

            let is_loading_clickpack = self.is_loading_clickpack.clone();
            std::thread::spawn(move || {
                Self::load_clickpack_thread(
                    |e| {
                        toasts
                            .lock()
                            .add(Toast::error(format!("Failed to preload clickpack: {e}")));
                    },
                    &path,
                    is_loading_clickpack,
                    load_for,
                )
            })
        };

        let mut prev_join_handle: Option<JoinHandle<()>> = None;
        for (clickpack_env, load_for) in &self.env.clickpack_ord {
            log::info!("preloading clickpack {clickpack_env:?} for {load_for:?}");
            match clickpack_env {
                ClickpackEnv::Name(name) => {
                    let mut found = false;
                    for dirname in &self.clickpacks {
                        if dirname == name {
                            prev_join_handle = Some(preload_clickpack(
                                PathBuf::from(".dcd").join("clickpacks").join(dirname),
                                self.toasts.clone(),
                                prev_join_handle,
                                *load_for,
                            ));
                            found = true;
                            break;
                        }
                    }
                    if !found {
                        self.toasts
                            .lock()
                            .add(Toast::error(format!("Clickpack \"{name}\" not found")));
                    }
                }
                ClickpackEnv::Path(path) => {
                    prev_join_handle = Some(preload_clickpack(
                        path.clone(),
                        self.toasts.clone(),
                        prev_join_handle,
                        *load_for,
                    ));
                }
                ClickpackEnv::None => log::info!("env.json doesn't specify a clickpack"),
            }
        }
        if let Some(handle) = prev_join_handle {
            std::thread::spawn(|| {
                handle.join().unwrap();
                log::info!("all clickpacks preloaded, playing noise (if any)");
                get_bot().lock().play_noise();
            });
        }
    }

    fn get_pitch(&self) -> f64 {
        if self.conf.pitch_enabled {
            utils::f64_range(self.conf.pitch.from..=self.conf.pitch.to)
        } else {
            1.0
        }
    }

    #[allow(unused_variables)]
    pub fn on_init(&mut self, playlayer: usize) {
        #[cfg(not(feature = "geode"))]
        {
            self.playlayer.addr = playlayer;
        }

        self.prev_times = ClickTimes::default();
        self.prev_pitch = 0.0;
        self.prev_volume = self.conf.volume_settings.global_volume;
        self.prev_spam_offset = 0.0;
        self.is_in_level = true;
        self.level_start = Instant::now();
        self.dead_timer = f32::NAN;
    }

    pub fn on_reset(&mut self) {
        self.level_start = Instant::now();
        //for dir in [
        //    &mut self.prev_times.jump,
        //    &mut self.prev_times.left,
        //    &mut self.prev_times.right,
        //] {
        //    for t in dir {
        //        t.time = 0.0;
        //        t.typ = ClickType::None;
        //    }
        //}
        self.prev_times = ClickTimes::default();
        self.dead_timer = f32::NAN;
    }

    pub fn on_exit(&mut self) {
        self.on_init(0);
        self.is_in_level = false;
        self.dead_timer = f32::NAN;
    }

    unsafe fn release_buttons(&mut self) {
        log::info!("releasing buttons on death");
        for (button, t) in [
            (Button::Jump, self.prev_times.jump),
            (Button::Left, self.prev_times.left),
            (Button::Right, self.prev_times.right),
        ] {
            for (player, time) in t.iter().enumerate() {
                if time.typ.is_click() && time.time != 0.0 {
                    self.on_action(button, player == 1, false);
                }
            }
        }
    }

    pub unsafe fn on_death(&mut self) {
        if !self.conf.release_buttons_on_death {
            return;
        }

        let mut release_delay = self.conf.death_release_delay;
        let offset = self.conf.death_release_delay_offset;

        // release all buttons that are still pressed (or do that in the future)
        if release_delay == 0.0 && offset == 0.0 {
            self.release_buttons();
        } else {
            if offset != 0.0 {
                if self.conf.death_release_delay_neg {
                    release_delay += utils::f64_range(-offset..=offset);
                } else {
                    release_delay += utils::f64_range(0.0..=offset);
                }
            }
            if release_delay <= 0.0 {
                self.release_buttons();
                return;
            }
            self.dead_timer_limit = release_delay as f32;
            self.dead_timer = 0.0;
        }
    }

    pub unsafe fn on_update(&mut self, dt: f32) {
        if !self.dead_timer.is_nan() {
            self.dead_timer += dt;
            if self.dead_timer >= self.dead_timer_limit {
                self.dead_timer = f32::NAN;
                self.release_buttons();
            }
        }
        // Update audio visualization
        self.update_audio_visualization(dt as f64);
        
        // Update sync analytics
        self.update_sync_analytics(dt as f64);
    }

    #[allow(unused_mut)]
    pub unsafe fn on_action(&mut self, button: Button, mut player2: bool, push: bool) {
        if self.clickpack.num_sounds == 0 || !self.is_in_level || !self.conf.enabled {
            return;
        }
        #[cfg(not(feature = "geode"))]
        if player2 && !self.playlayer.is_null()
        /* FIXME(2.206): && !self.playlayer.level_settings().is_2player() */
        {
            player2 = self.conf.force_player2_sounds;
        }
        #[cfg(not(feature = "geode"))]
        if !self.playlayer.is_null() {
            return;
        }
        if button.is_platformer()
            && !self.conf.force_playing_platformer
            && !self.clickpack.has_platformer_sounds
        {
            return;
        }

        let now = self.time();
        if now == 0.0 {
            return;
        }
        let prev_time =
            self.prev_times
                .get_prev_time(button, player2, self.conf.decouple_platformer);
        if prev_time.typ.is_click() && push {
            return;
        }
        let dt = (now - prev_time.time).abs();
        let click_type = ClickType::from_time(push, dt, &self.conf.timings);
        if self.conf.ignored_click_types.is_ignored(click_type) {
            return;
        }
        let use_fmod = self.conf.use_fmod;

        // Enhanced audio sound selection with dynamic filtering
        let mut click = if self.conf.audio_sound_selection && self.conf.dynamic_sound_selection {
            // Create advanced filter criteria
            let filter_criteria = SoundFilterCriteria::new()
                .with_duration_range(0.01, 0.2) // 10ms to 200ms duration
                .with_quality(match self.conf.audio_quality_level {
                    1 => SoundQuality::Low,
                    2 => SoundQuality::Medium,
                    3 => SoundQuality::High,
                    4 | 5 => SoundQuality::Ultra,
                    _ => SoundQuality::High,
                });
            
            // Try to get filtered sound first
            if let Some(filtered_sound) = self.clickpack.get_filtered_click(
                click_type, 
                player2, 
                button, 
                &filter_criteria
            ) {
                filtered_sound
            } else {
                // Fallback to enhanced selection
                let timing_factor = if dt < self.conf.timings.soft {
                    0.8 // Prefer softer sounds for micro-timing
                } else if dt > self.conf.timings.hard {
                    1.2 // Prefer harder sounds for long holds
                } else {
                    1.0 // Normal timing
                };
                
                // Apply sound profile filtering
                let profile_filter = match self.conf.sound_profile {
                    1 => 0.9, // Bass preference
                    2 => 1.0, // Balanced
                    3 => 1.1, // Treble preference
                    4 => 1.0, // Custom (no change)
                    _ => 1.0,
                };
                
                // Get sound with enhanced selection criteria
                let mut selected_sound = self
                    .clickpack
                    .get_random_click(click_type, player2, button)
                    .sound
                    .clone();
                
                // Apply audio enhancement mode if enabled
                if self.conf.audio_enhancement_mode {
                    // Enhance audio quality based on settings
                    let quality_factor = match self.conf.audio_quality_level {
                        1 => 0.8, // Low quality
                        2 => 0.9, // Medium quality
                        3 => 1.0, // High quality
                        4 => 1.1, // Very high quality
                        5 => 1.2, // Ultra quality
                        _ => 1.0,
                    };
                    
                    // Apply quality adjustments
                    selected_sound.set_playback_rate(PlaybackRate::Factor(quality_factor));
                }
                
                SoundWrapper { sound: selected_sound }
            }
        } else {
            // Standard sound selection
            SoundWrapper { sound: self
                .clickpack
                .get_random_click(click_type, player2, button)
                .sound
                .clone() }
        };

        // Enhanced pitch calculation with adaptive timing and sync optimization
        let base_pitch = self.get_pitch() * self.conf.click_speedhack;
        let final_pitch = if self.conf.enhanced_audio_timing || self.conf.sync_optimized_audio {
            // Apply timing-based pitch adjustments
            let timing_adjustment = if dt < self.conf.timings.soft {
                0.95 // Slightly lower pitch for micro-timing
            } else if dt > self.conf.timings.hard {
                1.05 // Slightly higher pitch for long holds
            } else {
                1.0 // Normal pitch
            };
            
            // Apply sync-aware pitch correction
            let sync_correction = if self.conf.audio_sync_correction {
                let sync_drift = (dt - (1.0 / 60.0)).abs(); // Calculate drift from 60fps
                if sync_drift > 0.001 { // If drift is significant
                    1.0 + (sync_drift * 0.1) // Small pitch correction
                } else {
                    1.0
                }
            } else {
                1.0
            };
            
            base_pitch * timing_adjustment * sync_correction
        } else {
            base_pitch
        };

        if !use_fmod {
            click.set_playback_rate(PlaybackRate::Factor(final_pitch));
        }

        // Enhanced volume calculation with advanced features
        {
            let vol = &self.conf.volume_settings;
            let mut volume = 1.0;
            
            // Apply volume variation with enhanced randomness
            if vol.volume_var != 0.0 {
                let variation = if self.conf.advanced_sound_filtering {
                    // More sophisticated variation based on timing
                    let timing_factor = (dt / self.conf.timings.regular).clamp(0.1, 2.0);
                    utils::f64_range(-vol.volume_var..=vol.volume_var) * timing_factor
                } else {
                    utils::f64_range(-vol.volume_var..=vol.volume_var)
                };
                volume += variation;
            }

            // Enhanced spam volume calculation
            if (push || vol.change_releases_volume) && dt < vol.spam_time && vol.enabled {
                let offset = (vol.spam_time - dt) * vol.spam_vol_offset_factor;
                self.prev_spam_offset = offset;
                volume -= offset.min(vol.max_spam_vol_offset);
            } else {
                self.prev_spam_offset = 0.0;
            }

            // Platformer volume adjustment with enhanced logic
            if button.is_platformer() {
                volume *= vol.platformer_volume_factor;
                
                // Additional platformer-specific adjustments
                if self.conf.enhanced_audio_timing {
                    let platformer_timing = if dt < 0.1 {
                        1.1 // Boost volume for quick platformer movements
                    } else {
                        1.0
                    };
                    volume *= platformer_timing;
                }
            }

            // Apply global volume after all adjustments
            volume *= vol.global_volume;
            
            // Apply sync-aware volume adjustments
            if self.conf.sync_aware_volume {
                let sync_quality = self.calculate_sync_quality().1;
                let sync_volume_factor = if sync_quality > 90.0 {
                    1.1 // Boost volume for excellent sync
                } else if sync_quality > 80.0 {
                    1.05 // Slight boost for good sync
                } else if sync_quality < 50.0 {
                    0.9 // Reduce volume for poor sync
                } else {
                    1.0 // Normal volume
                };
                volume *= sync_volume_factor;
            }
            
            // Clamp volume to prevent distortion
            volume = volume.clamp(0.0, 2.0);

            if !use_fmod {
                click.set_volume(volume as f32);
            }
            self.prev_volume = volume;
        }

        // Enhanced sound cutting with better logic
        if !use_fmod
            && self.conf.cut_sounds
            && (!click_type.is_release() || self.conf.cut_by_releases)
        {
            for sound in &self.mixer.renderer.guard().sounds {
                // Enhanced noise sound detection
                let sound_len = sound.guard().frames.len();
                if let Some(noise_sound) = &self.noise_sound {
                    if noise_sound.guard().frames.len() == sound_len {
                        continue;
                    }
                }

                // Improved sound cutting with timing consideration
                if self.conf.enhanced_audio_timing {
                    // Only cut sounds that are older than a certain threshold
                    let sound_age = sound.guard().frames.len() as f64 / 48000.0; // Assuming 48kHz sample rate
                    if sound_age > 0.1 { // Only cut sounds older than 100ms
                        sound.seek_to_end();
                    }
                } else {
                    sound.seek_to_end();
                }
            }
        }

        // Play the enhanced sound
        self.mixer.play(click.sound);
        
        // Frame-perfect audio processing
        if self.conf.frame_perfect_audio {
            self.process_frame_perfect_audio(click_type, dt);
        }
        
        // Real-time audio analysis
        if self.conf.real_time_audio_analysis {
            self.analyze_audio_performance(dt);
        }
        
        // Update timing tracking with enhanced data
        self.prev_times.set_time(
            button,
            player2,
            ClickTime {
                time: now,
                typ: click_type,
            },
            self.conf.decouple_platformer,
        );
        self.prev_pitch = final_pitch;
    }

    // New method for frame-perfect audio processing
    fn process_frame_perfect_audio(&mut self, click_type: ClickType, dt: f64) {
        self.frame_audio_history.push((click_type, dt));

        // Keep history manageable
        if self.frame_audio_history.len() > 60 {
            self.frame_audio_history.remove(0);
        }

        // Analyze frame timing consistency
        if self.frame_audio_history.len() > 10 {
            let recent_frames = &self.frame_audio_history[self.frame_audio_history.len().saturating_sub(10)..];
            let avg_timing = recent_frames.iter().map(|(_, t)| t).sum::<f64>() / recent_frames.len() as f64;
            let timing_variance = recent_frames.iter()
                .map(|(_, t)| (t - avg_timing).powi(2))
                .sum::<f64>() / recent_frames.len() as f64;

            // Apply frame-perfect corrections if variance is high
            if timing_variance > 0.0001 {
                // Adjust audio buffer size dynamically
                if self.conf.adaptive_buffer_sizing {
                    let new_buffer_size = (self.conf.sync_audio_buffer as f64 * (1.0 + timing_variance * 10.0)) as u32;
                    self.conf.sync_audio_buffer = new_buffer_size.clamp(32, 256);
                }
            }
        }
    }

    // New method for real-time audio analysis
    fn analyze_audio_performance(&mut self, dt: f64) {
        self.audio_performance_history.push(dt);
        self.audio_latency_history.push(self.conf.sync_audio_latency);

        // Keep history manageable
        if self.audio_performance_history.len() > 30 {
            self.audio_performance_history.remove(0);
        }
        if self.audio_latency_history.len() > 30 {
            self.audio_latency_history.remove(0);
        }

        // Analyze audio performance trends
        if self.audio_performance_history.len() > 10 {
            let avg_performance = self.audio_performance_history.iter().sum::<f64>() / self.audio_performance_history.len() as f64;
            let performance_variance = self.audio_performance_history.iter()
                .map(|&t| (t - avg_performance).powi(2))
                .sum::<f64>() / self.audio_performance_history.len() as f64;

            // Adjust audio latency based on performance
            if self.conf.adaptive_audio_timing {
                let target_latency = if performance_variance > 0.001 {
                    self.conf.sync_audio_latency * 1.1 // Increase latency for stability
                } else if performance_variance < 0.0001 {
                    self.conf.sync_audio_latency * 0.9 // Decrease latency for responsiveness
                } else {
                    self.conf.sync_audio_latency
                };

                self.conf.sync_audio_latency = target_latency.clamp(0.0005, 0.005); // 0.5ms to 5ms
            }
        }
    }

    #[inline]
    fn time(&self) -> f64 {
        let base_time = {
            #[cfg(feature = "geode")]
            if self.playlayer_time != 0.0 && self.conf.use_ingame_time {
                self.playlayer_time
            } else {
                self.level_start.elapsed().as_secs_f64()
            }
            #[cfg(not(feature = "geode"))]
            if !self.playlayer.is_null() && self.conf.use_ingame_time {
                self.playlayer.time()
            } else {
                self.level_start.elapsed().as_secs_f64()
            }
        };

        // Enhanced sync mode with adaptive timing correction
        if self.conf.instant_sync_mode || self.conf.adaptive_timing_correction || self.conf.sync_mode != SyncMode::Auto {
            static mut LAST_TIME: f64 = 0.0;
            static mut TIME_CORRECTION: f64 = 0.0;
            static mut FRAME_TIME_BUFFER: Vec<f64> = Vec::new();
            static mut SYNC_DRIFT_ACCUMULATOR: f64 = 0.0;
            static mut CURRENT_SYNC_MODE: SyncMode = SyncMode::Auto;

            unsafe {
                // Auto mode detection
                if self.conf.auto_mode_detection && self.conf.sync_mode == SyncMode::Auto {
                    if LAST_TIME > 0.0 {
                        let frame_time = base_time - LAST_TIME;
                        FRAME_TIME_BUFFER.push(frame_time);
                        
                        // Keep buffer size manageable
                        let buffer_size = if FRAME_TIME_BUFFER.len() > 120 { 120 } else { FRAME_TIME_BUFFER.len() };
                        if FRAME_TIME_BUFFER.len() > buffer_size {
                            FRAME_TIME_BUFFER.remove(0);
                        }

                        // Detect mode based on timing patterns
                        if FRAME_TIME_BUFFER.len() > 30 {
                            let variance = FRAME_TIME_BUFFER.iter()
                                .map(|&x| (x - FRAME_TIME_BUFFER.iter().sum::<f64>() / FRAME_TIME_BUFFER.len() as f64).powi(2))
                                .sum::<f64>() / FRAME_TIME_BUFFER.len() as f64;
                            
                            CURRENT_SYNC_MODE = if variance < 0.0001 {
                                SyncMode::Recording
                            } else if variance > 0.001 {
                                SyncMode::LivePlay
                            } else {
                                SyncMode::Mixed
                            };
                        }
                    }
                } else {
                    CURRENT_SYNC_MODE = self.conf.sync_mode;
                }

                if LAST_TIME > 0.0 {
                    let frame_time = base_time - LAST_TIME;
                    FRAME_TIME_BUFFER.push(frame_time);
                    
                    // Use adaptive buffer sizing if enabled
                    let target_buffer_size = if self.conf.adaptive_buffer_sizing {
                        CURRENT_SYNC_MODE.get_buffer_size()
                    } else {
                        120 // Default buffer size
                    };
                    
                    if FRAME_TIME_BUFFER.len() > target_buffer_size as usize {
                        FRAME_TIME_BUFFER.remove(0);
                    }

                    if self.conf.adaptive_timing_correction {
                        let target_frame_time = 1.0 / 60.0;
                        let avg_frame_time = FRAME_TIME_BUFFER.iter().sum::<f64>() / FRAME_TIME_BUFFER.len() as f64;
                        
                        // Calculate drift and apply correction
                        let current_drift = avg_frame_time - target_frame_time;
                        SYNC_DRIFT_ACCUMULATOR += current_drift;
                        
                        // Use mode-specific correction factor
                        let correction_factor = CURRENT_SYNC_MODE.get_correction_factor();
                        TIME_CORRECTION = SYNC_DRIFT_ACCUMULATOR * correction_factor;
                        
                        // Clamp correction to prevent extreme values
                        TIME_CORRECTION = TIME_CORRECTION.clamp(-0.02, 0.02);
                    }
                }

                LAST_TIME = base_time;
                base_time + TIME_CORRECTION
            }
        } else {
            base_time
        }
    }

    fn calculate_sync_quality(&self) -> (String, f64) {
        // Enhanced real-time sync quality calculation for recording and live play
        let current_time = self.time();
        let target_frame_time = 1.0 / 60.0; // Base 60fps target

        // Advanced frame timing analysis with multiple metrics
        static mut LAST_FRAME_TIME: f64 = 0.0;
        static mut FRAME_TIME_HISTORY: Vec<f64> = Vec::new();
        static mut SYNC_DRIFT_HISTORY: Vec<f64> = Vec::new();
        static mut INSTANT_SYNC_SCORE: f64 = 100.0;
        static mut RECORDING_MODE_ACTIVE: bool = false;
        static mut LIVE_PLAY_MODE_ACTIVE: bool = false;
        static mut CURRENT_SYNC_MODE: SyncMode = SyncMode::Auto;

        unsafe {
            let frame_time = current_time - LAST_FRAME_TIME;
            if LAST_FRAME_TIME > 0.0 {
                FRAME_TIME_HISTORY.push(frame_time);
                if FRAME_TIME_HISTORY.len() > 120 { // Increased history for better analysis
                    FRAME_TIME_HISTORY.remove(0);
                }

                // Calculate instant sync drift with enhanced precision
                let instant_drift = (frame_time - target_frame_time).abs();
                SYNC_DRIFT_HISTORY.push(instant_drift);
                if SYNC_DRIFT_HISTORY.len() > 60 { // Increased for better trend analysis
                    SYNC_DRIFT_HISTORY.remove(0);
                }

                // Detect recording vs live play modes based on timing patterns
                let recent_variance = if FRAME_TIME_HISTORY.len() > 30 {
                    let recent_frames = &FRAME_TIME_HISTORY[FRAME_TIME_HISTORY.len().saturating_sub(30)..];
                    let avg = recent_frames.iter().sum::<f64>() / recent_frames.len() as f64;
                    recent_frames.iter().map(|&x| (x - avg).powi(2)).sum::<f64>() / recent_frames.len() as f64
                } else {
                    0.0
                };

                // Mode detection logic
                if recent_variance < 0.0001 { // Very stable timing
                    RECORDING_MODE_ACTIVE = true;
                    LIVE_PLAY_MODE_ACTIVE = false;
                } else if recent_variance > 0.001 { // Variable timing
                    LIVE_PLAY_MODE_ACTIVE = true;
                    RECORDING_MODE_ACTIVE = false;
                }

                // Update current sync mode based on auto detection
                if self.conf.auto_mode_detection && self.conf.sync_mode == SyncMode::Auto {
                    CURRENT_SYNC_MODE = if RECORDING_MODE_ACTIVE {
                        SyncMode::Recording
                    } else if LIVE_PLAY_MODE_ACTIVE {
                        SyncMode::LivePlay
                    } else {
                        SyncMode::Mixed
                    };
                } else {
                    CURRENT_SYNC_MODE = self.conf.sync_mode;
                }
            }
            LAST_FRAME_TIME = current_time;

            let avg_frame_time = if !FRAME_TIME_HISTORY.is_empty() {
                FRAME_TIME_HISTORY.iter().sum::<f64>() / FRAME_TIME_HISTORY.len() as f64
            } else {
                target_frame_time
            };

            // Enhanced sync quality calculation with multiple factors
            let sync_drift = (avg_frame_time - target_frame_time).abs();
            let base_quality = (1.0 - (sync_drift / target_frame_time).min(1.0)) * 100.0;

            // Calculate stability factor (lower variance = better stability)
            let stability_factor = if FRAME_TIME_HISTORY.len() > 20 {
                let variance = FRAME_TIME_HISTORY.iter()
                    .map(|&x| (x - avg_frame_time).powi(2))
                    .sum::<f64>() / FRAME_TIME_HISTORY.len() as f64;
                let stability = 1.0 - (variance.sqrt() / target_frame_time).min(1.0);
                stability * 100.0
            } else {
                100.0
            };

            // Instant responsiveness factor with mode-specific adjustments
            let instant_factor = if !SYNC_DRIFT_HISTORY.is_empty() {
                let recent_drift = SYNC_DRIFT_HISTORY.iter().rev().take(10).sum::<f64>() / 10.0;
                let base_instant = (1.0 - (recent_drift / target_frame_time).min(1.0)) * 100.0;
                
                // Apply mode-specific bonuses
                let mode_bonus = match CURRENT_SYNC_MODE {
                    SyncMode::Recording => 1.1, // 10% bonus for recording mode
                    SyncMode::LivePlay => 1.05, // 5% bonus for live play mode
                    SyncMode::UltraSync => 1.15, // 15% bonus for ultra sync mode
                    SyncMode::Performance => 1.02, // 2% bonus for performance mode
                    _ => 1.0,
                };
                base_instant * mode_bonus
            } else {
                100.0
            };

            // Recording-specific quality metrics
            let recording_bonus = if RECORDING_MODE_ACTIVE {
                let consistency_score = if FRAME_TIME_HISTORY.len() > 60 {
                    let recent_60 = &FRAME_TIME_HISTORY[FRAME_TIME_HISTORY.len().saturating_sub(60)..];
                    let consistency = 1.0 - (recent_60.iter().map(|&x| (x - target_frame_time).abs()).sum::<f64>() / 60.0) / target_frame_time;
                    consistency.clamp(0.0, 1.0) * 20.0 // Up to 20 bonus points
                } else {
                    0.0
                };
                consistency_score
            } else {
                0.0
            };

            // Live play specific metrics
            let live_play_bonus = if LIVE_PLAY_MODE_ACTIVE {
                let responsiveness_score = if SYNC_DRIFT_HISTORY.len() > 30 {
                    let recent_drifts = &SYNC_DRIFT_HISTORY[SYNC_DRIFT_HISTORY.len().saturating_sub(30)..];
                    let avg_recovery_time = recent_drifts.iter().take(5).sum::<f64>() / 5.0;
                    let responsiveness = 1.0 - (avg_recovery_time / target_frame_time).min(1.0);
                    responsiveness * 15.0 // Up to 15 bonus points
                } else {
                    0.0
                };
                responsiveness_score
            } else {
                0.0
            };

            // Combined sync quality score with weighted factors and mode bonuses
            let combined_score = (base_quality * 0.4) + (stability_factor * 0.25) + (instant_factor * 0.25) + recording_bonus + live_play_bonus;
            INSTANT_SYNC_SCORE = combined_score.clamp(0.0, 100.0);

            // Dynamic quality text based on comprehensive analysis and mode
            let mode_text = if self.conf.sync_mode_indicators {
                match CURRENT_SYNC_MODE {
                    SyncMode::Auto => "Auto",
                    SyncMode::LivePlay => "Live",
                    SyncMode::Recording => "Rec",
                    SyncMode::Mixed => "Mix",
                    SyncMode::UltraSync => "Ultra",
                    SyncMode::Performance => "Perf",
                }
            } else {
                ""
            };

            let quality_text = if combined_score >= 95.0 {
                if !mode_text.is_empty() {
                    format!(" Excellent ({})", mode_text)
                } else if RECORDING_MODE_ACTIVE {
                    " Excellent (Recording)".to_string()
                } else if LIVE_PLAY_MODE_ACTIVE {
                    " Excellent (Live)".to_string()
                } else {
                    " Excellent".to_string()
                }
            } else if combined_score >= 85.0 {
                if !mode_text.is_empty() {
                    format!(" Good ({})", mode_text)
                } else if RECORDING_MODE_ACTIVE {
                    " Good (Recording)".to_string()
                } else if LIVE_PLAY_MODE_ACTIVE {
                    " Good (Live)".to_string()
                } else {
                    " Good".to_string()
                }
            } else if combined_score >= 70.0 {
                " Fair".to_string()
            } else if combined_score >= 50.0 {
                " Poor".to_string()
            } else {
                " Critical".to_string()
            };

            (quality_text.to_string(), combined_score)
        }
    }

    fn open_clickbot_toggle_toast(&self) {
        self.toasts.lock().add(Toast::info(if self.conf.enabled {
            "Enabled clickbot"
        } else {
            "Disabled clickbot"
        }));
    }

    fn reload_clickpacks(&mut self) -> Result<()> {
        let path = Path::new(".dcd/clickpacks");
        std::fs::create_dir_all(path)?;
        let dir = path.read_dir()?;
        let prev_clickpacks = std::mem::take(&mut self.clickpacks);
        for entry in dir {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                let name = path.file_name().unwrap().to_string_lossy().to_string();
                self.clickpack_db.mark_downloaded(&name, path, true);
                self.clickpacks.push(name);
            }
        }
        for prev in &prev_clickpacks {
            if !self.clickpacks.contains(prev) {
                self.clickpack_db
                    .mark_downloaded(prev, path.to_path_buf(), false);
            }
        }
        Ok(())
    }

    pub fn draw_ui(&mut self, ctx: &egui::Context) {
        // process hotkeys
        let wants_keyboard = ctx.wants_keyboard_input();
        let (toggle_menu, toggle_bot, toggle_noise) = ctx.input_mut(|i| {
            // for some reason it deadlocks when i put `ctx.wants_keyboard_input()` here?
            if wants_keyboard {
                (false, false, false)
            } else {
                (
                    self.conf.shortcuts.toggle_menu.pressed(i),
                    self.conf.shortcuts.toggle_bot.pressed(i),
                    self.conf.shortcuts.toggle_noise.pressed(i),
                )
            }
        });
        if toggle_menu {
            self.conf.hidden = !self.conf.hidden;
        }
        if toggle_bot {
            self.conf.enabled = !self.conf.enabled;
        }
        if toggle_noise {
            self.conf.play_noise = !self.conf.play_noise;
            self.play_noise();
        }

        // autosave config
        if self.conf != self.prev_conf && self.last_conf_save.elapsed() > Duration::from_secs(5) {
            self.last_conf_save = Instant::now();
            self.conf.save();
            self.prev_conf = self.conf.clone();
        }

        // change ui scale if needed
        ctx.set_zoom_factor(
            self.conf
                .ui_scale
                .clamp(*UI_SCALE_RANGE.start(), *UI_SCALE_RANGE.end()),
        );

        // dialog on first launch
        if self.env.is_first_launch {
            // Create the modal only once and reuse it
            if self.first_launch_modal.is_none() {
                let modal = Modal::new(ctx, "first_launch_dialog");
                modal.open();
                self.first_launch_modal = Some(modal);
            }

            // Handle the modal logic with proper borrowing
            let mut should_close_modal = false;
            if let Some(ref modal) = self.first_launch_modal {
                modal.show(|ui| {
                    modal.title(ui, "Welcome to dcd Live!");
                    modal.body_and_icon(
                        ui,
                        "This seems to be your first time using dcd Live.\n\
                         Press 1 to open the menu\n\
                         Press 2 to toggle the clickbot\n\
                         Explore ClickpackDB to download new clickpacks\n\
                        You can change the hotkeys in the Options section",
                        Icon::Info,
                    );
                    modal.buttons(ui, |ui| {
                        if self.first_launch_dialog_timeout > 0.0 {
                            ui.add_enabled_ui(false, |ui| {
                                let _ = ui
                                    .button(format!("{:.0}", self.first_launch_dialog_timeout.ceil()));
                            });
                            self.first_launch_dialog_timeout -= ctx.input(|i| i.unstable_dt);
                        } else if ui.button("Got it").clicked() {
                            self.env.is_first_launch = false;
                            self.env.save();
                            modal.close();
                            should_close_modal = true;
                        }
                        ui.hyperlink_to("Join the Discord server!", "https://discord.gg/BRVVVzxESu");
                    });
                });
            }

            // Clear the modal after closing to prevent it from being shown again
            if should_close_modal {
                self.first_launch_modal = None;
            }
        }

        // process toasts, even if not open
        if toggle_bot {
            self.open_clickbot_toggle_toast();
            self.play_noise();
        }
        if toggle_noise {
            self.open_noise_toggle_toast();
        }

        // don't draw and don't reload clickpacks if not open
        if self.conf.hidden {
            if matches!(self.conf.toast_visibility, ToastVisibility::AlwaysVisible) {
                self.toasts.lock().show(ctx); // but still draw toast queue
            }
            return;
        }

        // clickpack reloading
        if self.last_clickpack_reload.elapsed() > Duration::from_secs(5) {
            let _ = self
                .reload_clickpacks()
                .map_err(|e| log::error!("failed to reload clickpacks: {e}"));
            self.last_clickpack_reload = Instant::now();
        }

        // draw overlay - create global modal only once and reuse it
        if self.global_modal.is_none() {
            self.global_modal = Some(Arc::new(Mutex::new(Modal::new(ctx, "global_modal"))));
        }
        let modal = self.global_modal.as_ref().unwrap().clone();

        // remove tooltip delay
        ctx.style_mut(|s| {
            s.interaction.tooltip_delay = 0.0;
            let shadow = Shadow {
                offset: [6.0, 8.0].into(),
                blur: 32.0,
                spread: 0.0,
                color: egui::Color32::from_black_alpha(120),
            };
            s.visuals.popup_shadow = shadow;
            s.visuals.window_shadow = shadow;
        });

        egui::Window::new("dcd Live").show(ctx, |ui| {
            ui.horizontal(|ui| {
                ui.selectable_value(&mut self.conf.stage, Stage::Clickpack, "Clickpack");
                ui.selectable_value(&mut self.conf.stage, Stage::Audio, "Audio");
                ui.selectable_value(&mut self.conf.stage, Stage::Options, "Options");
                // ui.selectable_value(&mut self.conf.stage, Stage::Cheats, "Cheats");
            });
            ui.separator();

            egui::ScrollArea::both().show(ui, |ui| {
                match self.conf.stage {
                    Stage::Clickpack => self.show_clickpack_window(ui, modal.clone()),
                    Stage::Audio => {
                        if ui
                            .checkbox(&mut self.conf.enabled, "Enable clickbot")
                            .changed()
                        {
                            self.open_clickbot_toggle_toast();
                            self.play_noise();
                        }

                        // ui.separator();
                        ui.add_enabled_ui(self.conf.enabled, |ui| {
                            self.show_audio_window(ui);
        self.draw_audio_visualization(ui);
        self.draw_sync_analytics(ui);
        self.draw_plugin_manager(ui);
                        });
                    }
                    Stage::Options => self.show_options_window(ui, ctx, modal.clone()),
                };
            });
        });

        // show clickpackdb, if open
        self.show_clickpackdb_window(ctx, modal.clone());

        // show modal & toast queue
        modal.lock().show_dialog();
        if matches!(
            self.conf.toast_visibility,
            ToastVisibility::AlwaysVisible | ToastVisibility::VisibleWhenOpen
        ) {
            self.toasts.lock().show(ctx);
        }
    }

    #[cfg(not(feature = "geode"))]
    pub fn maybe_alloc_console(&self) {
        if self.conf.show_console && unsafe { AllocConsole() }.is_ok() {
            use std::sync::Once;
            static INIT_ONCE: Once = Once::new();
            INIT_ONCE.call_once(|| {
                simple_logger::SimpleLogger::new()
                    .init()
                    .expect("failed to initialize simple_logger");
            });
        } else {
            unsafe {
                let _ = FreeConsole();
            }
        }
    }

    fn show_options_window(
        &mut self,
        ui: &mut egui::Ui,
        ctx: &egui::Context,
        modal: Arc<Mutex<Modal>>,
    ) {
        ui.collapsing("Shortcuts", |ui| {
            let mut show_shortcut = |shortcut: &mut Shortcut, id: &'static str, name: &str| {
                ui.horizontal(|ui| {
                    ui.vertical(|ui| ui.add(Keybind::new(shortcut, id).with_text(name)));
                    if *shortcut != Shortcut::NONE
                        && ui
                            .button("Clear")
                            .on_hover_text("Set the shortcut to none")
                            .clicked()
                    {
                        *shortcut = Shortcut::NONE;
                    }
                });
            };
            show_shortcut(
                &mut self.conf.shortcuts.toggle_menu,
                "toggle_menu_keybind",
                "Toggle menu",
            );
            show_shortcut(
                &mut self.conf.shortcuts.toggle_bot,
                "toggle_bot_keybind",
                "Toggle bot",
            );
            show_shortcut(
                &mut self.conf.shortcuts.toggle_noise,
                "toggle_noise_keybind",
                "Toggle noise",
            );
        });
        ui.collapsing("Configuration", |ui| {
            ui.horizontal(|ui| {
                let slider = ui.add(
                    egui::Slider::new(&mut self.conf.ui_scale, UI_SCALE_RANGE)
                        .step_by(0.001)
                        .text("UI Scale"),
                );
                if slider.clicked() {
                    self.prev_scale_factor = ctx.zoom_factor();
                }
                egui_gl_hook::set_changing_scale(
                    slider.changed()
                        || slider.clicked()
                        || slider.dragged()
                        || slider.drag_stopped()
                        || slider.has_focus(),
                    self.prev_scale_factor,
                );
                if self.conf.ui_scale != 1.0
                    && ui
                        .button("Reset")
                        .on_hover_text("Reset to 100% scale")
                        .clicked()
                {
                    self.conf.ui_scale = 1.0;
                }
            });
            // #[cfg(not(feature = "geode"))]
            ui.horizontal(|ui| {
                help_text(
                    ui,
                    "Use an alternate button hook for bot compatibility",
                    |ui| ui.checkbox(&mut self.conf.use_alternate_hook, "Use alternate hook"),
                );
            });
            #[cfg(not(feature = "geode"))]
            help_text(ui, "Show debug console", |ui| {
                if ui
                    .checkbox(&mut self.conf.show_console, "Show console")
                    .changed()
                {
                    if self.conf.show_console {
                        self.maybe_alloc_console();
                    } else {
                        let _ = unsafe { FreeConsole() };
                    }
                }
            });
            help_text(
                ui,
                "Automatically save configuration changes every 5 seconds.\n\
                If this is disabled, the config will still be saved on graceful exit",
                |ui| ui.checkbox(&mut self.conf.autosave_config, "Auto-save config"),
            );

            egui::ComboBox::from_label("Toast Visibility")
                .selected_text(self.conf.toast_visibility.text())
                .show_ui(ui, |ui| {
                    ui.selectable_value(
                        &mut self.conf.toast_visibility,
                        ToastVisibility::AlwaysVisible,
                        ToastVisibility::AlwaysVisible.text(),
                    );
                    ui.selectable_value(
                        &mut self.conf.toast_visibility,
                        ToastVisibility::VisibleWhenOpen,
                        ToastVisibility::VisibleWhenOpen.text(),
                    );
                    ui.selectable_value(
                        &mut self.conf.toast_visibility,
                        ToastVisibility::NeverVisible,
                        ToastVisibility::NeverVisible.text(),
                    );
                });

            ui.horizontal(|ui| {
                ui.style_mut().spacing.item_spacing.x = 4.0;
                if ui
                    .button("Save")
                    .on_hover_text("Save the current configuration")
                    .clicked()
                {
                    self.conf.save();
                    self.toasts
                        .lock()
                        .add(Toast::success("Saved configuration to .dcd/config.json"));
                }
                ui.style_mut().spacing.item_spacing.x = 4.0;
                if ui
                    .button("Load")
                    .on_hover_text("Load the config from .dcd/config.json")
                    .clicked()
                {
                    let conf = Config::load();
                    if let Ok(conf) = conf {
                        self.conf = conf;
                        self.apply_config();
                        self.toasts
                            .lock()
                            .add(Toast::success("Loaded configuration from .dcd/config.json"));
                    } else if let Err(e) = conf {
                        show_error_dialog(modal.clone(), "Failed to load config!", &e.to_string());
                    }
                }
                ui.style_mut().spacing.item_spacing.x = 4.0;
                if ui
                    .button("Reset")
                    .on_hover_text("Reset the current configuration to defaults")
                    .clicked()
                {
                    let prev_stage = self.conf.stage;
                    self.conf = Config::default();
                    self.conf.stage = prev_stage; // don't switch current tab
                    self.apply_config();
                    self.toasts
                        .lock()
                        .add(Toast::info("Reset configuration to defaults"));
                }
                if ui
                    .button("Open folder")
                    .on_hover_text("Open .dcd folder")
                    .clicked()
                {
                    let _ = std::fs::create_dir_all(".dcd")
                        .map_err(|e| log::error!("failed to create .dcd: {e}"));
                    let _ = Command::new("explorer").arg(".dcd").spawn().map_err(|e| {
                        show_error_dialog(modal, "Failed to open folder!", &e.to_string());
                    });
                }
            });
        });
        ui.hyperlink_to("Join the Discord server!", "https://discord.gg/BRVVVzxESu");
        ui.allocate_space(ui.available_size() - vec2(0.0, 280.0));
    }

    fn get_device(&mut self) -> Device {
        Device::from_name(&self.env.selected_device).unwrap_or_default()
    }

    fn show_device_switcher(&mut self, ui: &mut egui::Ui) {
        ui.horizontal(|ui| {
            egui::ComboBox::from_label("Output device")
                .selected_text(&self.env.selected_device)
                .show_ui(ui, |ui| {
                    let devices = self.devices.lock().clone();
                    for device in &devices {
                        let is_selected = &self.env.selected_device == device;
                        if ui
                            .selectable_value(&mut self.env.selected_device, device.clone(), device)
                            .clicked()
                            && !is_selected
                        {
                            // start a new mixer on new device
                            log::info!("switching audio device to \"{device}\"");
                            self.maybe_init_kittyaudio();
                            self.play_noise();
                            self.env.save();
                            self.toasts
                                .lock()
                                .add(Toast::success(format!("Switched device to \"{device}\"")));
                            //kind: ToastKind::Success,
                            //text: format!("Switched device to \"{device}\"").into(),
                            //options: ToastOptions::default().duration_in_seconds(3.0),);
                        }
                    }
                })
                .response
                .on_disabled_hover_text("Not available with FMOD");
            if ui
                .button("Reset")
                .on_hover_text("Reset to the default audio device")
                .clicked()
            {
                self.mixer = Mixer::new();
                self.mixer.init();
                if let Ok(name) = Device::Default.name() {
                    self.env.selected_device = name.clone();
                    self.toasts
                        .lock()
                        .add(Toast::success(format!("Switched device to \"{name}\"")));
                }
                self.play_noise();
                self.env.save();
                log::debug!("reset audio device");
            }
        });
    }

    fn play_noise(&mut self) {
        let stop_kittyaudio_noise = |noise_sound: &mut Option<SoundHandle>| {
            if let Some(noise_sound) = noise_sound {
                noise_sound.set_playback_rate(PlaybackRate::Factor(1.0));
                noise_sound.set_loop_enabled(false);
                noise_sound.seek_to_end();
            }
            *noise_sound = None;
        };
        // let stop_fmod_noise = |fmodn: &mut *mut FMOD_CHANNEL| {
        //     unsafe { FMOD_Channel_Stop(*fmodn) };
        //     *fmodn = std::ptr::null_mut();
        // };
        let mut start_kittyaudio_noise = |noise_sound: &mut Option<SoundHandle>| {
            if let Some(mut noise) = self.clickpack.noise.clone() {
                noise.set_volume(self.conf.noise_volume as f32);
                noise.set_loop_enabled(true);
                let frames = noise.frames.len().saturating_sub(1);
                noise.set_loop_index(0..=frames);
                noise.set_playback_rate(PlaybackRate::Factor(self.conf.noise_speedhack));
                *noise_sound = Some(self.mixer.play(noise.sound));
            }
        };
        /*
        let start_fmod_noise = |fmodn: &mut *mut FMOD_CHANNEL| unsafe {
            if let Some(noise) = self.noise.clone() {
                // get sound length
                // let mut length = 0u32;
                // FMOD_Sound_GetLength(noise.fmod_sound, &mut length, FMOD_TIMEUNIT_PCM);

                // set loop points for sound
                FMOD_Sound_SetLoopCount(noise.fmod_sound, i32::MAX);
                // FMOD_Sound_SetLoopPoints(
                //     noise.fmod_sound,
                //     0,
                //     FMOD_TIMEUNIT_PCM,
                //     length,
                //     FMOD_TIMEUNIT_PCM,
                // );

                // play the sound
                FMOD_System_PlaySound(
                    self.system,
                    noise.fmod_sound,
                    std::ptr::null_mut(),
                    0,
                    fmodn,
                );

                // update channel
                FMOD_Channel_SetVolume(*fmodn, self.conf.noise_volume);
                // FMOD_Channel_SetLoopPoints(*fmodn, 0, FMOD_TIMEUNIT_PCM, 1024, FMOD_TIMEUNIT_PCM);
                FMOD_Channel_SetLoopCount(*fmodn, i32::MAX);
                FMOD_Channel_SetPitch(*fmodn, self.conf.noise_speedhack as f32);
                FMOD_System_Update(self.system);
            }
        };
        */

        stop_kittyaudio_noise(&mut self.noise_sound);
        // stop_fmod_noise(&mut self.fmod_noise_sound);

        if self.conf.play_noise && (self.conf.enabled || self.conf.play_noise_when_disabled) {
            if self.conf.use_fmod {
                // start_fmod_noise(&mut self.fmod_noise_sound);
            } else {
                start_kittyaudio_noise(&mut self.noise_sound);
            }
        }
    }

    fn open_noise_toggle_toast(&self) {
        self.toasts.lock().add(Toast::info(if self.conf.play_noise {
            "Playing noise"
        } else {
            "Stopped playing noise"
        }));
    }

    #[inline]
    fn is_loading_clickpack(&self) -> bool {
        self.is_loading_clickpack.load(Ordering::Relaxed)
    }

    fn show_audio_window(&mut self, ui: &mut egui::Ui) {
        ui.add_enabled_ui(
            self.clickpack.has_noise() && !self.is_loading_clickpack(),
            |ui| {
                ui.horizontal(|ui| {
                    if ui
                        .checkbox(&mut self.conf.play_noise, "Play noise")
                        .on_disabled_hover_text("Your clickpack doesn't have a noise file")
                        .on_hover_text("Play the noise file")
                        .changed()
                    {
                        self.play_noise();
                        self.open_noise_toggle_toast();
                    }

                    if drag_value(
                        ui,
                        &mut self.conf.noise_volume,
                        "Noise volume",
                        0.0..=f64::INFINITY,
                        "",
                    )
                    .drag_stopped()
                    {
                        self.play_noise(); // restart noise
                    }
                });
            },
        );

        /*
        help_text(
            ui,
            "Use the internal audio engine for integration with internal recorders",
            |ui| {
                if ui.checkbox(&mut self.conf.use_fmod, "Use FMOD").changed() {
                    if self.conf.use_fmod {
                        log::info!("destroying kittyaudio mixer");
                        self.mixer = Mixer::new();
                    } else {
                        self.maybe_init_kittyaudio();
                    }
                    self.play_noise();
                }
            },
        );
        */
        ui.add_enabled_ui(!self.conf.use_fmod, |ui| self.show_device_switcher(ui));

        ui.separator();

        ui.collapsing("Timings", |ui| {
            let timings_copy = self.conf.timings.clone();
            let timings = &mut self.conf.timings;

            help_text(
                ui,
                "Use in-game level time instead of real time.\n\
                Less realistic with practice mode or speedhack",
                |ui| {
                    ui.checkbox(&mut self.conf.use_ingame_time, "Use in-game time");
                },
            );

            ui.separator();
            ui.label(" Enhanced Sync Recording Features");

            // Sync Mode Selection
            help_text(
                ui,
                "Choose the sync mode that best fits your use case.\n\
                Auto mode will automatically detect if you're recording or playing live",
                |ui| {
                    ui.label("Sync Mode");
                    egui::ComboBox::from_id_source("sync_mode")
                        .selected_text(format!("{:?}", self.conf.sync_mode))
                        .show_ui(ui, |ui| {
                            ui.selectable_value(&mut self.conf.sync_mode, SyncMode::Auto, "Auto");
                            ui.selectable_value(&mut self.conf.sync_mode, SyncMode::LivePlay, "Live Play");
                            ui.selectable_value(&mut self.conf.sync_mode, SyncMode::Recording, "Recording");
                            ui.selectable_value(&mut self.conf.sync_mode, SyncMode::Mixed, "Mixed");
                            ui.selectable_value(&mut self.conf.sync_mode, SyncMode::UltraSync, "Ultra Sync");
                            ui.selectable_value(&mut self.conf.sync_mode, SyncMode::Performance, "Performance");
                        });
                    
                    // Show mode description
                    ui.label(format!(" {}", self.conf.sync_mode.description()));
                },
            );

            // Auto Mode Detection
            if self.conf.sync_mode == SyncMode::Auto {
                help_text(
                    ui,
                    "Automatically detect if you're recording or playing live based on timing patterns.\n\
                    This will switch between modes dynamically for optimal performance",
                    |ui| {
                        ui.checkbox(&mut self.conf.auto_mode_detection, "Enable Auto Mode Detection");
                    },
                );
            }

            // Sync Mode Indicators
            help_text(
                ui,
                "Show current sync mode in the sync quality display.\n\
                Useful for monitoring which mode is currently active",
                |ui| {
                    ui.checkbox(&mut self.conf.sync_mode_indicators, "Show Mode Indicators");
                },
            );

            // Adaptive Buffer Sizing
            help_text(
                ui,
                "Automatically adjust buffer size based on selected sync mode.\n\
                Optimizes performance for each specific use case",
                |ui| {
                    ui.checkbox(&mut self.conf.adaptive_buffer_sizing, "Adaptive Buffer Sizing");
                },
            );

            // Real-time Mode Switching
            help_text(
                ui,
                "Allow real-time switching between sync modes.\n\
                Useful for dynamic gameplay scenarios",
                |ui| {
                    ui.checkbox(&mut self.conf.real_time_mode_switching, "Real-time Mode Switching");
                },
            );

            // Original Enhanced Sync Features
            help_text(
                ui,
                "Enable instant sync mode for ultra-responsive recording.\n\
                Provides immediate timing adjustments for perfect sync",
                |ui| {
                    ui.checkbox(&mut self.conf.instant_sync_mode, "Instant Sync Mode");
                },
            );

            help_text(
                ui,
                "Enhanced recording synchronization with advanced algorithms.\n\
                Improves sync quality for recording and live play",
                |ui| {
                    ui.checkbox(&mut self.conf.enhanced_recording_sync, "Enhanced Recording Sync");
                },
            );

            help_text(
                ui,
                "Adaptive timing correction automatically adjusts for frame drops.\n\
                Maintains consistent timing even with performance variations",
                |ui| {
                    ui.checkbox(&mut self.conf.adaptive_timing_correction, "Adaptive Timing Correction");
                },
            );

            help_text(
                ui,
                "Display real-time sync quality information in the interface.\n\
                Shows sync score and quality indicators",
                |ui| {
                    ui.checkbox(&mut self.conf.real_time_sync_display, "Real-time Sync Display");
                },
            );

            if self.conf.real_time_sync_display {
                help_text(
                    ui,
                    "Minimum sync quality threshold for good recording.\n\
                    Values below this will show warnings",
                    |ui| {
                        ui.label("Sync Quality Threshold");
                        ui.add(egui::Slider::new(&mut self.conf.sync_quality_threshold, 50.0..=100.0)
                            .suffix("%")
                            .step_by(1.0));
                    },
                );
            }
            help_text(
                ui,
                "Plays platformer left/right sounds even if your clickpack doesn't have them",
                |ui| {
                    ui.checkbox(
                        &mut self.conf.force_playing_platformer,
                        "Force playing platformer sounds",
                    );
                },
            );
            help_text(
                ui,
                "Plays player 2 sounds outside 2-player levels.\n\
                This will not have any effect if you use alternate hook!",
                |ui| {
                    ui.checkbox(
                        &mut self.conf.force_player2_sounds,
                        "Force playing player 2 sounds",
                    );
                },
            );
            help_text(
                ui,
                "Makes both platformer sounds have separate timings. Usually sounds bad",
                |ui| {
                    ui.checkbox(
                        &mut self.conf.decouple_platformer,
                        "Decouple platformer sounds",
                    );
                },
            );

            ui.separator();
            ui.label(" Enhanced Audio System Features");

            // Sync Optimized Audio
            help_text(
                ui,
                "Enable audio system optimized specifically for sync.\n\
                Provides better audio timing and synchronization",
                |ui| {
                    ui.checkbox(&mut self.conf.sync_optimized_audio, "Sync Optimized Audio");
                },
            );

            // Adaptive Audio Timing
            help_text(
                ui,
                "Automatically adjust audio timing based on performance.\n\
                Maintains consistent audio sync even with frame drops",
                |ui| {
                    ui.checkbox(&mut self.conf.adaptive_audio_timing, "Adaptive Audio Timing");
                },
            );

            // Sync Aware Volume
            help_text(
                ui,
                "Adjust volume based on sync quality.\n\
                Boosts volume for good sync, reduces for poor sync",
                |ui| {
                    ui.checkbox(&mut self.conf.sync_aware_volume, "Sync Aware Volume");
                },
            );

            // Frame Perfect Audio
            help_text(
                ui,
                "Enable frame-perfect audio processing.\n\
                Maximum precision audio timing (higher CPU usage)",
                |ui| {
                    ui.checkbox(&mut self.conf.frame_perfect_audio, "Frame Perfect Audio");
                },
            );

            // Audio Sync Correction
            help_text(
                ui,
                "Apply audio sync corrections for drift compensation.\n\
                Helps maintain perfect audio timing",
                |ui| {
                    ui.checkbox(&mut self.conf.audio_sync_correction, "Audio Sync Correction");
                },
            );

            // Real-time Audio Analysis
            help_text(
                ui,
                "Perform real-time analysis of audio performance.\n\
                Monitors and optimizes audio timing continuously",
                |ui| {
                    ui.checkbox(&mut self.conf.real_time_audio_analysis, "Real-time Audio Analysis");
                },
            );

            // Audio Buffer Settings
            if self.conf.sync_optimized_audio || self.conf.frame_perfect_audio {
                help_text(
                    ui,
                    "Audio buffer size for sync optimization.\n\
                    Smaller values = lower latency, larger values = more stability",
                    |ui| {
                        ui.label("Sync Audio Buffer Size");
                        ui.add(egui::Slider::new(&mut self.conf.sync_audio_buffer, 32..=256)
                            .step_by(32.0));
                    },
                );

                help_text(
                    ui,
                    "Audio latency for sync optimization.\n\
                    Lower values = better sync, higher values = more stability",
                    |ui| {
                        ui.label("Sync Audio Latency (ms)");
                        ui.add(egui::Slider::new(&mut self.conf.sync_audio_latency, 0.0005..=0.005)
                            .suffix(" ms")
                            .step_by(0.0001));
                    },
                );
            }
            help_text(ui, "Releases all held buttons on death", |ui| {
                ui.checkbox(
                    &mut self.conf.release_buttons_on_death,
                    "Release buttons on death",
                );
            });
            if self.conf.release_buttons_on_death {
                drag_value(
                    ui,
                    &mut self.conf.death_release_delay,
                    "Release delay (sec)",
                    0.0..=f64::INFINITY,
                    "Delay before releasing buttons on death in seconds",
                );
                ui.horizontal(|ui| {
                    drag_value(
                        ui,
                        &mut self.conf.death_release_delay_offset,
                        "+/- (sec)",
                        0.0..=f64::INFINITY,
                        "Random offset for the death release delay in seconds",
                    );
                    ui.checkbox(&mut self.conf.death_release_delay_neg, "Negative?");
                });
            }

            ui.separator();

            drag_value(
                ui,
                &mut timings.hard,
                "Hard timing",
                timings_copy.regular..=f64::INFINITY,
                "Anything above this time between clicks plays hardclicks/hardreleases",
            );
            drag_value(
                ui,
                &mut timings.regular,
                "Regular timing",
                timings_copy.soft..=timings_copy.hard,
                "Anything above this time between clicks plays clicks/releases",
            );
            drag_value(
                ui,
                &mut timings.soft,
                "Soft timing",
                0.0..=timings_copy.regular,
                "Anything above this time between clicks plays softclicks/softreleases",
            );
            ui.label(format!(
                "Any value smaller than {:.2?} plays microclicks/microreleases",
                Duration::from_secs_f64(timings.soft),
            ))
        });

        ui.collapsing("Ignored click types", |ui| {
            ui.label(
                "Ignored click types will not be played. This can be useful for \
                disabling microreleases, for example",
            );
            let i = &mut self.conf.ignored_click_types;
            ui.checkbox(&mut i.hardclicks, "Hardclicks");
            ui.checkbox(&mut i.hardreleases, "Hardreleases");
            ui.checkbox(&mut i.clicks, "Clicks");
            ui.checkbox(&mut i.releases, "Releases");
            ui.checkbox(&mut i.softclicks, "Softclicks");
            ui.checkbox(&mut i.softreleases, "Softreleases");
            ui.checkbox(&mut i.microclicks, "Microclicks");
            ui.checkbox(&mut i.microreleases, "Microreleases");
            if i.any_ignored() && ui.button("Reset").clicked() {
                *i = IgnoredClickTypes::default();
            }
        });

        ui.collapsing("Pitch variation", |ui| {
            ui.label(
                "Pitch variation can make clicks sound more realistic by \
                    changing their pitch randomly.",
            );
            ui.checkbox(&mut self.conf.pitch_enabled, "Enable pitch variation");
            ui.add_enabled_ui(self.conf.pitch_enabled, |ui| {
                let p = &mut self.conf.pitch;
                drag_value(
                    ui,
                    &mut p.from,
                    "Minimum pitch",
                    0.0..=p.to,
                    "Minimum pitch value, 1.0 means no change",
                );
                drag_value(
                    ui,
                    &mut p.to,
                    "Maximum pitch",
                    p.from..=f64::INFINITY,
                    "Maximum pitch value, 1.0 means no change",
                );
            });
        });

        ui.collapsing("Volume settings", |ui| {
            help_text(
                ui,
                "Cut overlapping click sounds,\n\
                changes the sound significantly in spams",
                |ui| ui.checkbox(&mut self.conf.cut_sounds, "Cut sounds"),
            );
            if self.conf.cut_sounds {
                help_text(ui, "Allow clicks to be cut by releases", |ui| {
                    ui.checkbox(&mut self.conf.cut_by_releases, "Cut by releases")
                });
            }
            let vol = &mut self.conf.volume_settings;
            drag_value(
                ui,
                &mut vol.global_volume,
                "Global volume",
                0.0..=f64::INFINITY,
                "Constant volume multiplier for all sounds",
            );
            drag_value(
                ui,
                &mut vol.volume_var,
                "Volume variation",
                0.0..=f64::INFINITY,
                "Random volume variation (+/-)",
            );
            drag_value(
                ui,
                &mut vol.platformer_volume_factor,
                "Platformer volume factor",
                f64::NEG_INFINITY..=f64::INFINITY,
                "Multiplier of the platformer sound volume. If this is 0.5, \
                platformer sounds will be played at half volume",
            );
        });

        ui.collapsing("Spam volume changes", |ui| {
            ui.label("This can be used to lower volume in spams");
            let vol = &mut self.conf.volume_settings;
            help_text(ui, "Apply this logic to releases", |ui| {
                ui.checkbox(&mut vol.change_releases_volume, "Change releases volume")
            });
            drag_value(
                ui,
                &mut vol.spam_time,
                "Spam time",
                0.0..=f64::INFINITY,
                "Time between clicks which are considered spam clicks",
            );
            drag_value(
                ui,
                &mut vol.spam_vol_offset_factor,
                "Spam volume offset factor",
                f64::NEG_INFINITY..=f64::INFINITY,
                "The value which the volume offset factor is multiplied by",
            );
            drag_value(
                ui,
                &mut vol.max_spam_vol_offset,
                "Maximum volume offset",
                f64::NEG_INFINITY..=f64::INFINITY,
                "The maximum value of the volume offset",
            );
        });

        ui.collapsing("Speed", |ui| {
            ui.label("Adjust audio speed/pitch");
            ui.horizontal(|ui| {
                drag_value(
                    ui,
                    &mut self.conf.click_speedhack,
                    "Click speed",
                    0.0..=f64::INFINITY,
                    "Speed multiplier for clicks/releases",
                );
                if self.conf.click_speedhack != 1.0 && ui.button("Reset").clicked() {
                    self.conf.click_speedhack = 1.0;
                }
            });
            ui.horizontal(|ui| {
                if drag_value(
                    ui,
                    &mut self.conf.noise_speedhack,
                    "Noise speed",
                    0.0..=f64::INFINITY,
                    "Speed multiplier for noise. Only useful if your clickpack has a noise file",
                )
                .drag_stopped()
                {
                    self.play_noise();
                }
                if self.conf.noise_speedhack != 1.0 && ui.button("Reset").clicked() {
                    self.conf.noise_speedhack = 1.0;
                    self.play_noise();
                }
            });
            // help_text(ui, "Synchronize click speedhack with game speed", |ui| {
            //     ui.checkbox(&mut self.conf.sync_speed_with_game, "Sync speed with game")
            // });
        });

        ui.separator();
        ui.label(" Enhanced Audio System");

        help_text(
            ui,
            "Audio quality level affects buffer size and processing.\n\
            1=Conservative, 2=Balanced, 3=Standard, 4=Performance, 5=Ultra-low latency",
            |ui| {
                ui.label("Audio Quality Level");
                ui.add(egui::Slider::new(&mut self.conf.audio_quality_level, 1..=5)
                    .step_by(1.0));

                let quality_text = match self.conf.audio_quality_level {
                    1 => "Conservative (High latency, stable)",
                    2 => "Balanced (Good compromise)",
                    3 => "Standard (Default settings)",
                    4 => "Performance (Lower latency)",
                    5 => "Ultra-low latency (Requires good hardware)",
                    _ => "Unknown",
                };
                ui.label(format!("Mode: {}", quality_text));
            },
        );

        help_text(
            ui,
            "Enhanced audio timing with adaptive buffer management.\n\
            Automatically adjusts based on quality level",
            |ui| {
                ui.checkbox(&mut self.conf.enhanced_audio_timing, "Enhanced Audio Timing");
            },
        );

        help_text(
            ui,
            "Enable advanced audio sound selection with custom sample rates.\n\
            Allows fine-tuning of audio output quality",
            |ui| {
                ui.checkbox(&mut self.conf.audio_sound_selection, "Audio Sound Selection");
            },
        );

        if self.conf.audio_sound_selection {
            help_text(
                ui,
                "Custom audio sample rate for enhanced sound quality.\n\
                Higher rates provide better quality but use more resources",
                |ui| {
                    ui.label("Sample Rate (Hz)");
                    ui.add(egui::Slider::new(&mut self.conf.audio_sample_rate, 22050..=192000)
                        .logarithmic(true)
                        .step_by(1.0));

                    let rate_text = match self.conf.audio_sample_rate {
                        22050 => "22.05 kHz (Basic)",
                        44100 => "44.1 kHz (CD Quality)",
                        48000 => "48 kHz (Professional)",
                        96000 => "96 kHz (High-res)",
                        192000 => "192 kHz (Ultra high-res)",
                        _ => "Custom",
                    };
                    ui.label(format!("Quality: {}", rate_text));
                },
            );
        }

        ui.collapsing("Advanced", |ui| {
            // let last_bufsize = self.mixer.renderer.guard().last_buffer_size;
            // ui.label(format!("Real buffer size: {last_bufsize}"));
            help_text(
                ui,
                "Keep playing noise even if the clickbot is disabled",
                |ui| {
                    ui.checkbox(&mut self.conf.play_noise_when_disabled, "Play noise when disabled");
                },
            );

            let prev_bufsize = self.conf.buffer_size;
            help_text(
                ui,
                "Audio buffer size in samples. Lower value means lower latency.\n\
                Click \"Apply\" below to apply changes (if any)",
                |ui| {
                    ui.label("Buffer size");
                },
            );
            if u32_edit_field_min1(ui, &mut self.conf.buffer_size).changed() {
                self.buffer_size_changed = prev_bufsize != self.conf.buffer_size;
            }

            if self.buffer_size_changed {
                ui.horizontal(|ui| {
                    if ui
                        .button("Apply")
                        .on_hover_text("Apply buffer size changes")
                        .clicked()
                    {
                        if !self.conf.use_fmod {
                            self.maybe_init_kittyaudio();
                            self.play_noise();
                        } else {
                            self.show_fmod_buffersize_warn = true;
                        }
                        self.buffer_size_changed = false;
                    }

                    if self.conf.buffer_size > 300_000 {
                        ui.label(
                            RichText::new("WARN: Using a high buffer size might cause instability")
                                .color(Color32::YELLOW),
                        );
                    }
                });
            }
            if self.show_fmod_buffersize_warn && self.conf.buffer_size != self.startup_buffer_size {
                ui.label(
                    RichText::new("WARN: Restart the game to apply FMOD buffer size changes")
                        .color(Color32::YELLOW),
                );
            }
            if self.conf.use_fmod && self.startup_buffer_size < 10 {
                ui.label(
                    "If you don't hear any audio, it might be because your buffer size is set too low. \
                    The recommended value for FMOD is 10."
                );
            }
        });

        ui.allocate_space(vec2(100.0, 0.0));
    }

    fn apply_config(&mut self) {
        self.maybe_init_kittyaudio();
        self.play_noise();

        #[cfg(not(feature = "geode"))]
        self.maybe_alloc_console();
    }

    fn unload_clickpack(&mut self) {
        self.clickpack = Clickpack::default();
        self.stop_noise();
    }

    fn stop_noise(&mut self) {
        let prev_play_noise = self.conf.play_noise;
        self.conf.play_noise = false;
        self.play_noise();
        self.conf.play_noise = prev_play_noise;
    }

    fn load_clickpack_thread(
        err_fn: impl Fn(anyhow::Error),
        dir: &Path,
        is_loading_clickpack: Arc<AtomicBool>,
        load_for: LoadClickpackFor,
    ) {
        is_loading_clickpack.store(true, Ordering::Relaxed);
        if load_for == LoadClickpackFor::All {
            BOT.unload_clickpack();
        } else {
            BOT.stop_noise();
        }
        let _ = BOT.load_clickpack_from_path(dir, load_for).map_err(|e| {
            log::error!("failed to load clickpack: {e}");
            err_fn(e);
        });
        BOT.play_noise();
        is_loading_clickpack.store(false, Ordering::Relaxed);
    }

    fn select_clickpack_combobox(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) {
        let ellipsis = if self.clickpack.name.len() <= 14 {
            self.clickpack.name.clone()
        } else {
            format!("{:.14}", self.clickpack.name)
        };
        egui::ComboBox::from_label("Select clickpack")
            .selected_text(ellipsis)
            .show_ui(ui, |ui| {
                for dirname in &self.clickpacks {
                    let is_loading_clickpack = self.is_loading_clickpack.clone();
                    let load_for = self.conf.load_clickpack_for;
                    let path = PathBuf::from(".dcd").join("clickpacks").join(dirname);
                    if ui
                        .selectable_label(&self.clickpack.name == dirname, dirname)
                        .clicked()
                    {
                        let modal_moved = modal.clone();
                        let dirname_moved = dirname.to_string();
                        std::thread::spawn(move || {
                            Self::load_clickpack_thread(
                                |e| {
                                    show_error_dialog(
                                        modal_moved.clone(),
                                        "Failed to load clickpack!",
                                        &e.to_string(),
                                    );
                                },
                                &path,
                                is_loading_clickpack,
                                load_for,
                            );
                            unsafe { BOT.env().env.update(ClickpackEnv::Name(dirname_moved), load_for) };
                        });
                    }
                }
            });
    }

    fn select_clickpack_button(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) -> bool {
        if !self.clickpacks.is_empty() {
            self.select_clickpack_combobox(ui, modal);
            return true;
        }
        ui.horizontal(|ui| {
            if ui
                .button("Select clickpack")
                .on_disabled_hover_text("Please wait")
                .clicked()
            {
                let is_loading_clickpack = self.is_loading_clickpack.clone();
                let load_for = self.conf.load_clickpack_for;
                std::thread::spawn(move || {
                    let Some(dir) = FileDialog::new().pick_folder() else {
                        return;
                    };
                    log::debug!("selected clickpack {dir:?}");
                    Self::load_clickpack_thread(
                        |e| {
                            show_error_dialog(
                                modal.clone(),
                                "Failed to load clickpack!",
                                &e.to_string(),
                            );
                        },
                        &dir,
                        is_loading_clickpack,
                        load_for,
                    );
                    unsafe {
                        BOT.env().env.update(ClickpackEnv::Path(dir), load_for);
                    }
                });
            }
            if self.clickpack.num_sounds != 0 {
                ui.label(format!("Selected clickpack: \"{}\"", self.clickpack.name));
            } else {
                ui.label("or put clickpacks in .dcd/clickpacks");
            }
        });
        false
    }

    fn show_select_clickpack_for_combobox(&mut self, ui: &mut egui::Ui) {
        ui.horizontal(|ui| {
            ui.label("Select clickpack for:");
            help_text(
                ui,
                "Choose a player to load the clickpack for.\n\
                E.g. if you choose Left1, the clickpack will be used for platformer sounds",
                |ui| {
                    egui::ComboBox::new("select_clickpack_for_combobox", "")
                        .selected_text(format!("{:?}", self.conf.load_clickpack_for))
                        .show_ui(ui, |ui| {
                            for load_for in [
                                LoadClickpackFor::All,
                                LoadClickpackFor::Player1,
                                LoadClickpackFor::Player2,
                                LoadClickpackFor::Left1,
                                LoadClickpackFor::Left2,
                                LoadClickpackFor::Right1,
                                LoadClickpackFor::Right2,
                            ] {
                                ui.selectable_value(
                                    &mut self.conf.load_clickpack_for,
                                    load_for,
                                    format!("{load_for:?}"),
                                );
                            }
                        });
                },
            );
        });
    }

    fn show_clickpack_window(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) {
        let is_loading_clickpack = self.is_loading_clickpack();
        if is_loading_clickpack {
            ui.horizontal(|ui| {
                ui.label("Loading clickpack");
                ui.add(egui::Spinner::new());
            });
        }

        ui.add_enabled_ui(!is_loading_clickpack, |ui| {
            if !self.clickpacks.is_empty() {
                help_text(
                    ui,
                    "If there's no folders inside .dcd/clickpacks,\n\
                    there will be an option to choose the clickpack manually",
                    |ui| {
                        ui.label("Put clickpacks in .dcd/clickpacks");
                    },
                );
            }

            let show_open_folder = |ui: &mut egui::Ui| {
                if ui
                    .button("Open folder")
                    .on_hover_text("Open .dcd/clickpacks")
                    .clicked()
                {
                    let _ = std::fs::create_dir_all(".dcd/clickpacks")
                        .map_err(|e| log::error!("failed to create .dcd/clickpacks: {e}"));
                    let _ = Command::new("explorer")
                        .arg(".dcd\\clickpacks")
                        .spawn()
                        .map_err(|e| log::error!("failed to open .dcd/clickpacks: {e}"));
                }
            };

            self.show_select_clickpack_for_combobox(ui);

            let mut is_combobox = false;
            ui.horizontal(|ui| {
                is_combobox = self.select_clickpack_button(ui, modal);
                if !self.clickpack.name.is_empty() {
                    ui.style_mut().spacing.item_spacing.x = 4.0;
                    if ui.button("").on_hover_text("Unload clickpack").clicked() {
                        self.unload_clickpack();
                        self.env.update(ClickpackEnv::None, LoadClickpackFor::All);
                    }
                }
                if is_combobox {
                    show_open_folder(ui);
                }
            });
            if !is_combobox {
                show_open_folder(ui);
            }
        });

        if self.clickpack.num_sounds != 0 {
            help_text(
                ui,
                "To add player 2 sounds, make a folder called \"player2\" \
                and put sounds for the second player there,\n\
                or use \"Select clickpack for\" to select a \
                seperate clickpack for the second player",
                |ui| {
                    ui.label(format!("{} sounds", self.clickpack.num_sounds));
                },
            );
        }
        ui.separator();
        ui.collapsing("ClickpackDB", |ui| {
            ui.label(
                "ClickpackDB is a collection of 300+ clickpacks \
                that can be easily downloaded from within dcd Live.",
            );
            if self.clickpack_db_open {
                if ui
                    .button("Close ClickpackDB")
                    .on_hover_text("This can also be done by clicking  on the ClickpackDB window")
                    .clicked()
                {
                    self.clickpack_db_open = false;
                }
            } else if ui.button("Open ClickpackDB").clicked() {
                self.clickpack_db_open = true;
            }
        });
        // ui.hyperlink_to(
        //     "Get more clickpacks in the Discord server!",
        //     "https://discord.gg/BRVVVzxESu",
        // );

        // Real-time sync display (always visible when enabled)
        if self.conf.real_time_sync_display && self.is_in_level {
            ui.separator();
            let (sync_text, sync_score) = self.calculate_sync_quality();
            ui.horizontal(|ui| {
                ui.label(" Sync Quality:");
                ui.label(sync_text);
                ui.label(format!("{:.1}%", sync_score));

                if sync_score < self.conf.sync_quality_threshold {
                    ui.label("");
                }
            });

            // Sync quality bar
            let sync_progress = sync_score / 100.0;
            let bar_color = if sync_score >= 95.0 {
                egui::Color32::GREEN
            } else if sync_score >= 85.0 {
                egui::Color32::YELLOW
            } else if sync_score >= 70.0 {
                egui::Color32::from_rgb(255, 165, 0) // Orange
            } else {
                egui::Color32::RED
            };

            ui.add(egui::ProgressBar::new(sync_progress as f32)
                .fill(bar_color)
                .text(format!("Sync: {:.1}%", sync_score)));
        }

        if !is_loading_clickpack && self.is_in_level {
            ui.collapsing("Debug", |ui| {
                ui.label("Last click times and types:");
                egui::Grid::new("times_grid")
                    .num_columns(2)
                    .min_col_width(130.0)
                    .striped(true)
                    .show(ui, |ui| {
                        for times in [
                            self.prev_times.jump,
                            self.prev_times.left,
                            self.prev_times.right,
                        ] {
                            for t in times {
                                ui.label(format!("{:.3?} | {:?}", t.time, t.typ));
                            }
                            ui.end_row();
                        }
                    });
                ui.label(format!(
                    "Last pitch: {:.4} ({}..={})",
                    self.prev_pitch, self.conf.pitch.from, self.conf.pitch.to
                ));
                ui.label(format!(
                    "Last volume: {:.4} (+/- {} * {})",
                    self.prev_volume,
                    self.conf.volume_settings.volume_var,
                    self.conf.volume_settings.global_volume
                ));
                ui.label(format!(
                    "Last spam volume offset: -{:.4}",
                    self.prev_spam_offset
                ));

                let format_path_keep_root = |path: &Path| path.to_string_lossy().replace('\\', "/");

                ui.label(format!(
                    "Clickpack path: {:?}",
                    format_path_keep_root(&self.clickpack.path)
                ));
            });
        }
    }

    fn show_clickpackdb_window(&mut self, ctx: &egui::Context, modal: Arc<Mutex<Modal>>) {
        if !self.clickpack_db_open {
            return;
        }
        if std::mem::take(&mut self.clickpack_db.has_refreshed) {
            log::debug!("doing clickpack reload for clickpackdb");
            let _ = self
                .reload_clickpacks()
                .map_err(|e| log::error!("failed to reload clickpacks for clickpackdb: {e}"));
        }
        egui::Window::new("ClickpackDB")
            .open(&mut self.clickpack_db_open)
            .show(ctx, |ui| {
                self.clickpack_db.show(ui, &ureq_get);
                if let Some(select_path) =
                    std::mem::replace(&mut self.clickpack_db.select_clickpack, None)
                {
                    self.conf.load_clickpack_for = LoadClickpackFor::All;
                    let is_loading_clickpack = self.is_loading_clickpack.clone();
                    let modal_moved = modal.clone();
                    std::thread::spawn(move || {
                        Self::load_clickpack_thread(
                            |e| {
                                show_error_dialog(
                                    modal_moved.clone(),
                                    "Failed to load clickpack!",
                                    &e.to_string(),
                                );
                            },
                            &select_path,
                            is_loading_clickpack,
                            LoadClickpackFor::All,
                        );
                        unsafe {
                            BOT.env().env.update(
                                ClickpackEnv::Name(
                                    select_path
                                        .file_name()
                                        .unwrap_or_default()
                                        .to_string_lossy()
                                        .to_string(),
                                ),
                                LoadClickpackFor::All,
                            )
                        };
                    });
                }
            });
    }

    // Audio visualization methods
    fn update_audio_visualization(&mut self, dt: f64) {
        if !self.conf.audio_visualization_enabled {
            return;
        }

        // Update visualization FPS
        self.visualization_fps = (1.0 / dt) as f32;

        // Generate mock waveform data (replace with real audio data)
        self.generate_waveform_data();
        self.generate_spectrum_data();

        // Update history
        self.update_visualization_history();
    }

    fn generate_waveform_data(&mut self) {
        // Generate mock waveform data based on current audio activity
        let sample_count = 128;
        self.audio_waveform_data.clear();
        
        for i in 0..sample_count {
            let time = i as f32 / sample_count as f32;
            let amplitude = (time * std::f32::consts::PI * 4.0).sin() * 0.5;
            
            // Add some randomness based on current audio activity
            let noise = (time * 10.0).sin() * 0.1;
            let final_amplitude = (amplitude + noise) * self.conf.visualization_scale;
            
            self.audio_waveform_data.push(final_amplitude);
        }
    }

    fn generate_spectrum_data(&mut self) {
        // Generate mock spectrum data (FFT-like)
        let bin_count = 64;
        self.audio_spectrum_data.clear();
        
        for i in 0..bin_count {
            let frequency = i as f32 / bin_count as f32;
            let amplitude = (frequency * std::f32::consts::PI * 2.0).sin() * 0.7;
            
            // Add some variation based on time
            let time_variation = (std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_millis() as f32 * 0.001 + frequency * 10.0)
                .sin() * 0.2;
            
            let final_amplitude = (amplitude + time_variation).max(0.0) * self.conf.visualization_scale;
            self.audio_spectrum_data.push(final_amplitude);
        }
    }

    fn update_visualization_history(&mut self) {
        // Keep waveform history
        if self.waveform_history.len() > 10 {
            self.waveform_history.remove(0);
        }
        self.waveform_history.push(self.audio_waveform_data.clone());

        // Keep spectrum history
        if self.spectrum_history.len() > 10 {
            self.spectrum_history.remove(0);
        }
        self.spectrum_history.push(self.audio_spectrum_data.clone());
    }

    fn draw_audio_visualization(&mut self, ui: &mut egui::Ui) {
        if !self.conf.audio_visualization_enabled {
            return;
        }

        ui.separator();
        ui.label(" Audio Visualization");

        // Waveform display
        ui.collapsing("Waveform", |ui| {
            let available_size = ui.available_size();
            let waveform_height = 60.0;
            
            let (rect, response) = ui.allocate_exact_size(
                vec2(available_size.x, waveform_height),
                egui::Sense::hover(),
            );

            // Draw waveform
            let painter = ui.painter_at(rect);
            let points: Vec<egui::Pos2> = self.audio_waveform_data
                    .iter()
                    .enumerate()
                    .map(|(i, &amplitude)| {
                        let x = rect.left() + (i as f32 / self.audio_waveform_data.len() as f32) * rect.width();
                        let y = rect.center().y + amplitude * rect.height() * 0.4;
                        egui::Pos2::new(x, y)
                    })
                    .collect();

                if points.len() > 1 {
                    painter.line_segment(
                        [points[0], points[points.len() - 1]],
                        egui::Stroke::new(2.0, egui::Color32::from_rgb(100, 200, 255)),
                    );
                }
        });

        // Spectrum display
        ui.collapsing("Spectrum", |ui| {
            let available_size = ui.available_size();
            let spectrum_height = 80.0;
            
            let (rect, response) = ui.allocate_exact_size(
                vec2(available_size.x, spectrum_height),
                egui::Sense::hover(),
            );

            // Draw spectrum bars
            let painter = ui.painter_at(rect);
                let bar_width = rect.width() / self.audio_spectrum_data.len() as f32;
                
                for (i, &amplitude) in self.audio_spectrum_data.iter().enumerate() {
                    let bar_height = amplitude * rect.height();
                    let bar_rect = egui::Rect::from_min_size(
                        egui::Pos2::new(rect.left() + i as f32 * bar_width, rect.bottom() - bar_height),
                        vec2(bar_width - 1.0, bar_height),
                    );
                    
                    let color = egui::Color32::from_rgb(
                        (amplitude * 255.0) as u8,
                        (100.0 + amplitude * 155.0) as u8,
                        255,
                    );
                    
                    painter.rect_filled(bar_rect, 0.0, color);
                }
        });

        // Visualization controls
        ui.collapsing("Controls", |ui| {
            ui.checkbox(&mut self.conf.audio_visualization_enabled, "Enable Visualization");
            ui.add(egui::Slider::new(&mut self.conf.visualization_opacity, 0.1..=1.0).text("Opacity"));
            ui.add(egui::Slider::new(&mut self.conf.visualization_scale, 0.1..=3.0).text("Scale"));
            ui.checkbox(&mut self.conf.show_audio_peaks, "Show Peaks");
            
            egui::ComboBox::from_id_source("waveform_mode")
                .selected_text(format!("{:?}", self.conf.waveform_display_mode))
                .show_ui(ui, |ui| {
                    ui.selectable_value(&mut self.conf.waveform_display_mode, WaveformDisplayMode::RealTime, "Real Time");
                    ui.selectable_value(&mut self.conf.waveform_display_mode, WaveformDisplayMode::History, "History");
                    ui.selectable_value(&mut self.conf.waveform_display_mode, WaveformDisplayMode::Peak, "Peak");
                    ui.selectable_value(&mut self.conf.waveform_display_mode, WaveformDisplayMode::Average, "Average");
                });

            egui::ComboBox::from_id_source("spectrum_mode")
                .selected_text(format!("{:?}", self.conf.spectrum_display_mode))
                .show_ui(ui, |ui| {
                    ui.selectable_value(&mut self.conf.spectrum_display_mode, SpectrumDisplayMode::Bars, "Bars");
                    ui.selectable_value(&mut self.conf.spectrum_display_mode, SpectrumDisplayMode::Line, "Line");
                    ui.selectable_value(&mut self.conf.spectrum_display_mode, SpectrumDisplayMode::Area, "Area");
                    ui.selectable_value(&mut self.conf.spectrum_display_mode, SpectrumDisplayMode::Circular, "Circular");
                });
        });
    }

    // Sync performance analytics methods
    fn update_sync_analytics(&mut self, dt: f64) {
        if !self.conf.sync_analytics_enabled {
            return;
        }

        let current_time = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs_f64();

        // Calculate current sync metrics
        let (sync_quality_str, sync_quality_score) = self.calculate_sync_quality();
        let sync_latency = self.conf.sync_audio_latency;
        let sync_accuracy = self.calculate_sync_accuracy();
        let audio_performance = self.calculate_audio_performance();
        let frame_timing = dt;

        // Create performance data point
        let performance_data = SyncPerformanceData {
            timestamp: current_time,
            sync_quality: sync_quality_score,
            sync_latency,
            sync_accuracy,
            mode: self.conf.sync_mode,
            audio_performance,
            frame_timing,
        };

        // Add to history
        self.sync_performance_history.push(performance_data);

        // Keep history manageable
        if self.sync_performance_history.len() > 1000 {
            self.sync_performance_history.remove(0);
        }

        // Update trends
        self.update_sync_trends();
        
        // Calculate performance scores
        self.calculate_performance_scores();
    }

    fn calculate_sync_accuracy(&self) -> f64 {
        // Calculate sync accuracy based on timing consistency
        if self.frame_audio_history.len() < 10 {
            return 0.0;
        }

        let recent_frames = &self.frame_audio_history[self.frame_audio_history.len().saturating_sub(10)..];
        let avg_timing = recent_frames.iter().map(|(_, t)| t).sum::<f64>() / recent_frames.len() as f64;
        
        let variance = recent_frames.iter()
            .map(|(_, t)| (t - avg_timing).powi(2))
            .sum::<f64>() / recent_frames.len() as f64;

        // Convert variance to accuracy score (0-100)
        let accuracy = (1.0 / (1.0 + variance * 1000.0)) * 100.0;
        accuracy.clamp(0.0, 100.0)
    }

    fn calculate_audio_performance(&self) -> f64 {
        // Calculate audio performance based on latency and buffer efficiency
        if self.audio_performance_history.is_empty() {
            return 0.0;
        }

        let avg_latency = self.audio_performance_history.iter().sum::<f64>() / self.audio_performance_history.len() as f64;
        let buffer_efficiency = 1.0 - (self.conf.sync_audio_buffer as f64 / 256.0);
        
        // Combine latency and buffer efficiency into performance score
        let performance = (1.0 / (1.0 + avg_latency * 1000.0)) * 70.0 + buffer_efficiency * 30.0;
        performance.clamp(0.0, 100.0)
    }

    fn update_sync_trends(&mut self) {
        // Update quality trends
        if self.sync_performance_history.len() >= 10 {
            let recent_quality: Vec<f64> = self.sync_performance_history
                .iter()
                .rev()
                .take(10)
                .map(|data| data.sync_quality)
                .collect();
            
            self.sync_quality_trends = recent_quality;
        }

        // Update latency trends
        if self.sync_performance_history.len() >= 10 {
            let recent_latency: Vec<f64> = self.sync_performance_history
                .iter()
                .rev()
                .take(10)
                .map(|data| data.sync_latency)
                .collect();
            
            self.sync_latency_trends = recent_latency;
        }

        // Update accuracy trends
        if self.sync_performance_history.len() >= 10 {
            let recent_accuracy: Vec<f64> = self.sync_performance_history
                .iter()
                .rev()
                .take(10)
                .map(|data| data.sync_accuracy)
                .collect();
            
            self.sync_accuracy_trends = recent_accuracy;
        }
    }

    fn calculate_performance_scores(&mut self) {
        if self.sync_performance_history.len() < 10 {
            return;
        }

        // Calculate overall performance score
        let recent_data = &self.sync_performance_history[self.sync_performance_history.len().saturating_sub(10)..];
        
        let avg_quality = recent_data.iter().map(|d| d.sync_quality).sum::<f64>() / recent_data.len() as f64;
        let avg_accuracy = recent_data.iter().map(|d| d.sync_accuracy).sum::<f64>() / recent_data.len() as f64;
        let avg_audio = recent_data.iter().map(|d| d.audio_performance).sum::<f64>() / recent_data.len() as f64;

        self.sync_performance_score = (avg_quality * 0.4 + avg_accuracy * 0.4 + avg_audio * 0.2).clamp(0.0, 100.0);

        // Calculate improvement rate
        if self.sync_performance_history.len() >= 20 {
            let old_data = &self.sync_performance_history[self.sync_performance_history.len().saturating_sub(20)..10];
            let new_data = &self.sync_performance_history[self.sync_performance_history.len().saturating_sub(10)..];
            
            let old_avg = old_data.iter().map(|d| d.sync_quality).sum::<f64>() / old_data.len() as f64;
            let new_avg = new_data.iter().map(|d| d.sync_quality).sum::<f64>() / new_data.len() as f64;
            
            self.sync_improvement_rate = ((new_avg - old_avg) / old_avg * 100.0).clamp(-50.0, 50.0);
        }

        // Calculate consistency score
        if self.sync_quality_trends.len() >= 10 {
            let variance = self.sync_quality_trends.iter()
                .map(|&q| (q - avg_quality).powi(2))
                .sum::<f64>() / self.sync_quality_trends.len() as f64;
            
            self.sync_consistency_score = (1.0 / (1.0 + variance * 0.1)) * 100.0;
        }
    }

    fn draw_sync_analytics(&mut self, ui: &mut egui::Ui) {
        if !self.conf.sync_analytics_enabled {
            return;
        }

        ui.separator();
        ui.label(" Sync Performance Analytics");

        // Performance overview
        ui.collapsing("Performance Overview", |ui| {
            ui.horizontal(|ui| {
                ui.vertical(|ui| {
                    ui.label(format!("Overall Score: {:.1}%", self.sync_performance_score));
                    ui.label(format!("Improvement Rate: {:.1}%", self.sync_improvement_rate));
                    ui.label(format!("Consistency: {:.1}%", self.sync_consistency_score));
                });
                
                ui.vertical(|ui| {
                    let color = if self.sync_performance_score >= 80.0 {
                        egui::Color32::GREEN
                    } else if self.sync_performance_score >= 60.0 {
                        egui::Color32::YELLOW
                    } else {
                        egui::Color32::RED
                    };
                    
                    ui.colored_label(color, format!("Status: {}", 
                        if self.sync_performance_score >= 80.0 { "Excellent" }
                        else if self.sync_performance_score >= 60.0 { "Good" }
                        else { "Needs Improvement" }
                    ));
                });
            });
        });

        // Quality trends chart
        if !self.sync_quality_trends.is_empty() {
            ui.collapsing("Quality Trends", |ui| {
                let available_size = ui.available_size();
                let chart_height = 80.0;
                
                let (rect, response) = ui.allocate_exact_size(
                    vec2(available_size.x, chart_height),
                    egui::Sense::hover(),
                );

                let painter = ui.painter_at(rect);
                    let points: Vec<egui::Pos2> = self.sync_quality_trends
                        .iter()
                        .enumerate()
                        .map(|(i, &quality)| {
                            let x = rect.left() + (i as f32 / self.sync_quality_trends.len() as f32) * rect.width();
                            let y = rect.bottom() - (quality as f32 / 100.0) * rect.height();
                            egui::Pos2::new(x, y)
                        })
                        .collect();

                    if points.len() > 1 {
                        painter.line_segment(
                            [points[0], points[points.len() - 1]],
                            egui::Stroke::new(2.0, egui::Color32::from_rgb(255, 100, 100)),
                        );
                    }
            });
        }

        // Analytics controls
        ui.collapsing("Analytics Controls", |ui| {
            ui.checkbox(&mut self.conf.sync_analytics_enabled, "Enable Analytics");
            
            if ui.button("Export Data").clicked() {
                self.export_analytics_data();
            }
            
            if ui.button("Clear History").clicked() {
                self.clear_analytics_history();
            }
        });
    }

    fn export_analytics_data(&self) {
        // Export analytics data to JSON file
        let export_data = serde_json::json!({
            "timestamp": std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs_f64(),
            "performance_history": serde_json::to_value(&self.sync_performance_history).unwrap_or_default(),
            "overall_score": self.sync_performance_score,
            "improvement_rate": self.sync_improvement_rate,
            "consistency_score": self.sync_consistency_score,
        });

        if let Ok(file) = std::fs::File::create(".dcd/analytics_export.json") {
            let _ = serde_json::to_writer_pretty(file, &export_data);
        }
    }

    fn clear_analytics_history(&mut self) {
        self.sync_performance_history.clear();
        self.sync_quality_trends.clear();
        self.sync_latency_trends.clear();
        self.sync_accuracy_trends.clear();
        self.sync_performance_score = 0.0;
        self.sync_improvement_rate = 0.0;
        self.sync_consistency_score = 0.0;
    }

    // Plugin system methods
    fn init_plugin_system(&mut self) {
        self.plugin_api_version = "1.0.0".to_string();
        
        // Create plugins directory if it doesn't exist
        let _ = std::fs::create_dir_all(".dcd/plugins");
        
        // Load existing plugins
        self.load_plugins();
    }

    fn load_plugins(&mut self) {
        let plugins_dir = std::path::Path::new(".dcd/plugins");
        if !plugins_dir.exists() {
            return;
        }

        if let Ok(entries) = std::fs::read_dir(plugins_dir) {
            for entry in entries.flatten() {
                if entry.path().is_dir() {
                    self.load_plugin_from_directory(&entry.path());
                }
            }
        }
    }

    fn load_plugin_from_directory(&mut self, plugin_dir: &std::path::Path) {
        let manifest_path = plugin_dir.join("plugin.json");
        if !manifest_path.exists() {
            return;
        }

        if let Ok(manifest_content) = std::fs::read_to_string(&manifest_path) {
            if let Ok(plugin_info) = serde_json::from_str::<PluginInfo>(&manifest_content) {
                // Check API compatibility
                if plugin_info.api_version == self.plugin_api_version {
                    self.active_plugins.push(plugin_info.name.clone());
                    
                    // Load plugin configuration
                    let config_path = plugin_dir.join("config.json");
                    if let Ok(config_content) = std::fs::read_to_string(&config_path) {
                        if let Ok(config) = serde_json::from_str(&config_content) {
                            self.plugin_configs.insert(plugin_info.name.clone(), config);
                        }
                    }
                    
                    // Register plugin hooks
                    for hook in plugin_info.hooks {
                        self.plugin_hooks.push(hook);
                    }
                }
            }
        }
    }

    fn execute_plugin_hooks(&mut self, hook_type: PluginHookType, data: serde_json::Value) {
        if !self.conf.plugins_enabled {
            return;
        }

        let relevant_hooks: Vec<PluginHook> = self.plugin_hooks
            .iter()
            .filter(|hook| hook.hook_type == hook_type && hook.enabled)
            .cloned()
            .collect();

        for hook in relevant_hooks {
            // Execute plugin hook (placeholder for actual plugin execution)
            self.execute_plugin_callback(&hook.callback, data.clone());
        }
    }

    fn execute_plugin_callback(&mut self, callback: &str, data: serde_json::Value) {
        // Placeholder for actual plugin callback execution
        // In a real implementation, this would execute the plugin's callback function
        log::debug!("Executing plugin callback: {} with data: {:?}", callback, data);
    }

    fn draw_plugin_manager(&mut self, ui: &mut egui::Ui) {
        ui.separator();
        ui.label(" Plugin System");

        ui.collapsing("Plugin Manager", |ui| {
            ui.checkbox(&mut self.conf.plugins_enabled, "Enable Plugin System");
            
            if ui.button("Reload Plugins").clicked() {
                // This would trigger plugin reload
                log::info!("Plugin reload requested");
            }
            
            if ui.button("Open Plugins Folder").clicked() {
                let _ = std::fs::create_dir_all(".dcd/plugins");
                let _ = std::process::Command::new("explorer").arg(".dcd\\plugins").spawn();
            }
        });

        // Active plugins list
        if !self.active_plugins.is_empty() {
            ui.collapsing("Active Plugins", |ui| {
                for plugin_name in &self.active_plugins {
                    ui.label(format!(" {}", plugin_name));
                }
            });
        }

        // Plugin hooks
        if !self.plugin_hooks.is_empty() {
            ui.collapsing("Plugin Hooks", |ui| {
                for hook in &self.plugin_hooks {
                    let status = if hook.enabled { "" } else { "" };
                    ui.label(format!("{} {} ({:?}) - Priority: {}", 
                        status, hook.name, hook.hook_type, hook.priority));
                }
            });
        }

        // Plugin API info
        ui.collapsing("API Information", |ui| {
            ui.label(format!("API Version: {}", self.plugin_api_version));
            ui.label("Supported Hook Types:");
            ui.label(" OnClick - Triggered on click events");
            ui.label(" OnSync - Triggered on sync events");
            ui.label(" OnAudio - Triggered on audio events");
            ui.label(" OnUI - Triggered on UI events");
            ui.label(" OnConfig - Triggered on config changes");
            ui.label(" OnUpdate - Triggered on frame updates");
        });
    }
}

impl Drop for Bot {
    fn drop(&mut self) {
        // self.unload_clickpack();
        self.release_fmod()
    }
}

#[derive(Serialize, Deserialize, Clone, PartialEq, Default, Copy, Debug)]
pub enum SyncMode {
    #[default]
    Auto,           // Auto-detect mode based on timing patterns
    LivePlay,       // Optimized for live gameplay
    Recording,      // Optimized for recording
    Mixed,          // Mixed mode for both live and recording
    UltraSync,      // Maximum sync precision (high CPU usage)
    Performance,    // Balanced performance and sync
}

impl SyncMode {
    pub fn description(&self) -> &'static str {
        match self {
            SyncMode::Auto => "Auto-detect based on timing patterns",
            SyncMode::LivePlay => "Optimized for live gameplay with responsive timing",
            SyncMode::Recording => "Optimized for recording with maximum consistency",
            SyncMode::Mixed => "Balanced mode for both live and recording",
            SyncMode::UltraSync => "Maximum sync precision (high CPU usage)",
            SyncMode::Performance => "Balanced performance and sync quality",
        }
    }

    pub fn get_correction_factor(&self) -> f64 {
        match self {
            SyncMode::Auto => 0.1,
            SyncMode::LivePlay => 0.15,
            SyncMode::Recording => 0.05,
            SyncMode::Mixed => 0.1,
            SyncMode::UltraSync => 0.2,
            SyncMode::Performance => 0.08,
        }
    }

    pub fn get_buffer_size(&self) -> u32 {
        match self {
            SyncMode::Auto => 120,
            SyncMode::LivePlay => 60,
            SyncMode::Recording => 240,
            SyncMode::Mixed => 120,
            SyncMode::UltraSync => 360,
            SyncMode::Performance => 90,
        }
    }
}

#[derive(Serialize, Deserialize, Clone, PartialEq, Default, Copy, Debug)]
pub enum WaveformDisplayMode {
    #[default]
    RealTime,
    History,
    Peak,
    Average,
}

#[derive(Serialize, Deserialize, Clone, PartialEq, Default, Copy, Debug)]
pub enum SpectrumDisplayMode {
    #[default]
    Bars,
    Line,
    Area,
    Circular,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct SyncPerformanceData {
    pub timestamp: f64,
    pub sync_quality: f64,
    pub sync_latency: f64,
    pub sync_accuracy: f64,
    pub mode: SyncMode,
    pub audio_performance: f64,
    pub frame_timing: f64,
}

impl Default for SyncPerformanceData {
    fn default() -> Self {
        Self {
            timestamp: 0.0,
            sync_quality: 0.0,
            sync_latency: 0.0,
            sync_accuracy: 0.0,
            mode: SyncMode::Auto,
            audio_performance: 0.0,
            frame_timing: 0.0,
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct PluginHook {
    pub name: String,
    pub hook_type: PluginHookType,
    pub callback: String,
    pub enabled: bool,
    pub priority: i32,
}

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub enum PluginHookType {
    OnClick,
    OnSync,
    OnAudio,
    OnUI,
    OnConfig,
    OnUpdate,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct PluginInfo {
    pub name: String,
    pub version: String,
    pub author: String,
    pub description: String,
    pub api_version: String,
    pub hooks: Vec<PluginHook>,
    pub config_schema: serde_json::Value,
}

impl Default for PluginInfo {
    fn default() -> Self {
        Self {
            name: String::new(),
            version: String::new(),
            author: String::new(),
            description: String::new(),
            api_version: "1.0.0".to_string(),
            hooks: Vec::new(),
            config_schema: serde_json::json!({}),
        }
    }
}
