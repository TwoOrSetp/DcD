#[cfg(not(feature = "geode"))]
use crate::{game::PlayLayer, hooks};

use crate::{
    clickpack::{Button, ClickType, Clickpack, LoadClickpackFor, Pitch, Timings, VolumeSettings},
    utils,
};
use anyhow::Result;
use egui::{
    emath, epaint::Shadow, vec2, Color32, DragValue, Key, KeyboardShortcut, Modifiers, RichText,
};
use egui_clickpack_db::ClickpackDb;
use egui_keybind::{Bind, Keybind, Shortcut};
use egui_modal::{Icon, Modal};
use egui_notify::{Toast, Toasts};
use kittyaudio::{Device, Mixer, PlaybackRate, SoundHandle, StreamSettings};
use once_cell::sync::Lazy;
use parking_lot::Mutex;
use rfd::FileDialog;
use serde::{Deserialize, Serialize};
use std::{
    ops::RangeInclusive,
    path::{Path, PathBuf},
    process::Command,
    sync::{
        atomic::{AtomicBool, Ordering},
        Arc,
    },
    time::{Duration, Instant},
};

#[cfg(not(feature = "geode"))]
use windows::Win32::System::Console::{AllocConsole, FreeConsole};

/// Global bot state
///
/// # Safety
/// This static is accessed from multiple contexts but is designed to be used
/// in a single-threaded environment (the main game thread). The warnings about
/// static mut references are acknowledged but the current design ensures safety
/// through careful usage patterns.
#[allow(static_mut_refs)]
pub static mut BOT: Lazy<Box<Bot>> = Lazy::new(Box::<Bot>::default);

const UI_SCALE_RANGE: RangeInclusive<f32> = 0.3..=5.0;

pub mod built_info {
    // generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/built.rs"));
}

#[derive(Serialize, Deserialize, Clone, PartialEq)]
pub struct Shortcuts {
    pub toggle_menu: Shortcut,
    pub toggle_bot: Shortcut,
    pub toggle_noise: Shortcut,
}

impl Default for Shortcuts {
    fn default() -> Self {
        Self {
            toggle_menu: Shortcut::new(
                Some(KeyboardShortcut::new(Modifiers::NONE, Key::Num1)),
                None,
            ),
            toggle_bot: Shortcut::new(
                Some(KeyboardShortcut::new(Modifiers::NONE, Key::Num2)),
                None,
            ),
            toggle_noise: Shortcut::NONE,
        }
    }
}

fn skip_serializing_selected_device(device: &str) -> bool {
    let is_default = if let Ok(name) = Device::Default.name() {
        name == device
    } else {
        false
    };
    device.is_empty() || is_default
}

#[derive(Serialize, Deserialize, Default, Clone, Debug, PartialEq)]
pub enum ClickpackEnv {
    #[default]
    None,
    Name(String),
    Path(PathBuf),
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Env {
    version: String,
    clickpack_ord: Vec<(ClickpackEnv, LoadClickpackFor)>,
    is_first_launch: bool,
    #[serde(
        default = "String::new",
        skip_serializing_if = "skip_serializing_selected_device"
    )]
    pub selected_device: String,
}

impl Default for Env {
    fn default() -> Self {
        Self {
            version: built_info::PKG_VERSION.to_string(),
            clickpack_ord: vec![(ClickpackEnv::None, LoadClickpackFor::All)],
            is_first_launch: true, // overriden later
            selected_device: String::new(),
        }
    }
}

impl Env {
    pub fn load() -> Self {
        let _ = std::fs::create_dir_all(".dcd")
            .map_err(|e| log::error!("failed to create .dcd directory: {e}"));

        let path = Path::new(".dcd/env.json");
        if let Ok(f) = std::fs::File::open(path) {
            let env = serde_json::from_reader(f);
            if let Ok(env) = env {
                return env;
            } else if let Err(e) = env {
                log::error!("failed to deserialize env: {e}");
            }
        }

        // if we're here we failed
        log::warn!("failed to deserialize env, writing defaults");
        if let Ok(f) = std::fs::File::create(path) {
            let _ = serde_json::to_writer_pretty(f, &Self::default())
                .map_err(|e| log::error!("failed to write env: {e}"));
        }

        Self::default()
    }

    pub fn save(&self) {
        log::info!("writing .dcd/env.json");
        let mut env = self.clone();
        env.version = built_info::PKG_VERSION.to_string();
        if let Ok(f) = std::fs::File::create(".dcd/env.json") {
            let _ = serde_json::to_writer_pretty(f, &env)
                .map_err(|e| log::error!("failed to write env: {e}"));
        }
    }

    pub fn update(&mut self, clickpack_env: ClickpackEnv, load_for: LoadClickpackFor) {
        match load_for {
            LoadClickpackFor::All => self.clickpack_ord = vec![(clickpack_env, load_for)],
            _ => {
                self.clickpack_ord.retain(|ord| ord.1 != load_for);
                log::info!("pushing to ord: ({clickpack_env:?}, {load_for:?})");
                self.clickpack_ord.push((clickpack_env, load_for));
            }
        }
        self.save();
    }

    // fn is_selected_by_path(&self) -> bool {
    //     self.clickpack_ord
    //         .iter()
    //         .any(|c| matches!(c.0, ClickpackEnv::Path(_)))
    // }
}

const fn true_value() -> bool {
    true
}

const fn default_buffer_size() -> u32 {
    512
}

#[inline]
fn float_one<Num: emath::Numeric>() -> Num {
    Num::from_f64(1.0)
}

// clickpack, options, audio
#[derive(Serialize, Deserialize, Clone, PartialEq, Default, Copy)]
pub enum Stage {
    #[default]
    Clickpack,
    Audio,
    Options,
}

#[derive(Serialize, Deserialize, Clone, PartialEq, Default)]
struct IgnoredClickTypes {
    hardclicks: bool,
    hardreleases: bool,
    softclicks: bool,
    softreleases: bool,
    clicks: bool,
    releases: bool,
    microclicks: bool,
    microreleases: bool,
}

impl IgnoredClickTypes {
    #[inline]
    const fn is_ignored(&self, typ: ClickType) -> bool {
        match typ {
            ClickType::HardClick => self.hardclicks,
            ClickType::HardRelease => self.hardreleases,
            ClickType::SoftClick => self.softclicks,
            ClickType::SoftRelease => self.softreleases,
            ClickType::Click => self.clicks,
            ClickType::Release => self.releases,
            ClickType::MicroClick => self.microclicks,
            ClickType::MicroRelease => self.microreleases,
            ClickType::None => true,
        }
    }

    #[inline]
    const fn any_ignored(&self) -> bool {
        self.hardclicks
            || self.hardreleases
            || self.softclicks
            || self.softreleases
            || self.clicks
            || self.releases
            || self.microclicks
            || self.microreleases
    }
}

const fn death_release_delay_default() -> f64 {
    0.001
}

const fn death_release_delay_offset_default() -> f64 {
    0.13
}

const fn default_time_smoothing_factor() -> f64 {
    0.1 // 10% smoothing for stable timing
}

const fn default_pause_detection_threshold() -> f64 {
    0.1 // 100ms threshold for detecting pauses
}

const fn default_input_latency_compensation() -> f64 {
    0.0 // No compensation by default
}

const fn default_allow_audio_finish_on_pause() -> bool {
    true // Allow audio to finish naturally when paused
}

const fn default_pause_debounce_threshold() -> f64 {
    0.05 // 50ms debounce threshold for pause state changes
}

const fn default_rapid_pause_threshold() -> u32 {
    5 // Maximum rapid pause/resume cycles before triggering audio reset
}

// Enhanced Recording Sync default values
const fn default_target_fps() -> f64 {
    60.0 // Default target FPS for sync calculations
}

const fn default_fps_compensation_factor() -> f64 {
    1.0 // No compensation by default
}

const fn default_adaptive_sync_threshold() -> f64 {
    0.016 // ~16ms threshold for adaptive sync adjustments (1 frame at 60fps)
}

#[derive(Debug, Clone)]
#[allow(dead_code)]
pub enum PendingAudioAction {
    Play { button: Button, player2: bool, push: bool, timestamp: Instant },
    Stop { immediate: bool },
    Reset,
}

#[derive(Serialize, Deserialize, Clone, Copy, PartialEq, Default)]
pub enum TimingMode {
    #[default]
    Responsive, // Prioritizes immediate audio response
    Synchronized, // Prioritizes perfect recording sync
    Hybrid, // Balances both (recommended)
}

impl TimingMode {
    const fn text(self) -> &'static str {
        match self {
            TimingMode::Responsive => "Responsive (Live Play)",
            TimingMode::Synchronized => "Synchronized (Recording)",
            TimingMode::Hybrid => "Hybrid (Balanced)",
        }
    }
}

#[derive(Serialize, Deserialize, Clone, Copy, PartialEq, Default)]
pub enum ToastVisibility {
    #[default]
    AlwaysVisible,
    VisibleWhenOpen,
    NeverVisible,
}

impl ToastVisibility {
    #[inline]
    const fn text(self) -> &'static str {
        match self {
            ToastVisibility::AlwaysVisible => "Always Visible",
            ToastVisibility::VisibleWhenOpen => "Visible in Menu",
            ToastVisibility::NeverVisible => "Never Visible",
        }
    }
}

#[derive(Serialize, Deserialize, Clone, PartialEq)]
pub struct Config {
    pub pitch_enabled: bool,
    pub pitch: Pitch,
    pub timings: Timings,
    pub volume_settings: VolumeSettings,
    #[serde(default = "Shortcuts::default")]
    pub shortcuts: Shortcuts,
    #[serde(default = "true_value")]
    pub enabled: bool,
    #[serde(default = "bool::default")]
    pub hidden: bool,
    #[serde(default = "default_buffer_size")]
    pub buffer_size: u32,
    #[serde(default = "bool::default")]
    pub play_noise: bool,
    #[serde(default = "float_one")]
    pub noise_volume: f64,
    #[serde(default = "bool::default")]
    pub force_playing_platformer: bool,
    #[serde(default = "bool::default")]
    pub use_alternate_hook: bool,
    #[serde(default = "bool::default")]
    pub show_console: bool,
    #[serde(default = "Stage::default")]
    pub stage: Stage,
    #[serde(default = "bool::default")]
    pub use_fmod: bool,
    #[serde(default = "bool::default")]
    pub cut_sounds: bool,
    #[serde(default = "bool::default")]
    pub cut_by_releases: bool,
    #[serde(default = "float_one")]
    pub click_speedhack: f64,
    // #[serde(default = "true_value")]
    // pub sync_speed_with_game: bool,
    #[serde(default = "float_one")]
    pub noise_speedhack: f64,
    #[serde(default = "LoadClickpackFor::default")]
    pub load_clickpack_for: LoadClickpackFor,
    #[serde(default = "bool::default")]
    pub decouple_platformer: bool,
    #[serde(default = "true_value")]
    pub autosave_config: bool,
    #[serde(default = "true_value")]
    pub release_buttons_on_death: bool,
    #[serde(default = "death_release_delay_default")]
    pub death_release_delay: f64,
    #[serde(default = "death_release_delay_offset_default")]
    pub death_release_delay_offset: f64,
    #[serde(default = "bool::default")]
    pub death_release_delay_neg: bool,
    #[serde(default = "bool::default")]
    pub force_player2_sounds: bool,
    #[serde(default = "bool::default")]
    pub play_noise_when_disabled: bool,
    #[serde(default = "IgnoredClickTypes::default")]
    ignored_click_types: IgnoredClickTypes,
    #[serde(default = "bool::default")]
    pub use_ingame_time: bool,
    #[serde(default = "bool::default")]
    pub enhanced_recording_sync: bool,
    #[serde(default = "default_time_smoothing_factor")]
    pub time_smoothing_factor: f64,
    #[serde(default = "default_pause_detection_threshold")]
    pub pause_detection_threshold: f64,
    #[serde(default = "true_value")]
    pub instant_audio_response: bool,
    #[serde(default = "default_input_latency_compensation")]
    pub input_latency_compensation: f64,
    #[serde(default = "TimingMode::default")]
    pub timing_mode: TimingMode,
    #[serde(default = "default_allow_audio_finish_on_pause")]
    pub allow_audio_finish_on_pause: bool,
    #[serde(default = "default_pause_debounce_threshold")]
    pub pause_debounce_threshold: f64,
    #[serde(default = "default_rapid_pause_threshold")]
    pub rapid_pause_threshold: u32,
    #[serde(default = "bool::default")]
    pub enable_audio_system_recovery: bool,
    #[serde(default = "float_one")]
    pub ui_scale: f32,
    #[serde(default)]
    pub toast_visibility: ToastVisibility,
    // Enhanced Recording Sync Features
    #[serde(default = "bool::default")]
    pub fps_sync_enabled: bool,
    #[serde(default = "default_target_fps")]
    pub target_fps: f64,
    #[serde(default = "default_fps_compensation_factor")]
    pub fps_compensation_factor: f64,
    #[serde(default = "bool::default")]
    pub advanced_sync_features: bool,
    #[serde(default = "bool::default")]
    pub frame_time_smoothing: bool,
    #[serde(default = "default_adaptive_sync_threshold")]
    pub adaptive_sync_threshold: f64,
}

impl Config {
    #[inline]
    pub fn fixup(mut self) -> Self {
        self.buffer_size = self.buffer_size.max(1);
        #[cfg(feature = "geode")]
        {
            self.show_console = false;
        }
        self.ui_scale = self
            .ui_scale
            .clamp(*UI_SCALE_RANGE.start(), *UI_SCALE_RANGE.end());
        self
    }
}

impl Default for Config {
    fn default() -> Self {
        Self {
            pitch_enabled: true,
            pitch: Pitch::default(),
            timings: Timings::default(),
            volume_settings: VolumeSettings::default(),
            shortcuts: Shortcuts::default(),
            enabled: true,
            hidden: false,
            buffer_size: default_buffer_size(),
            play_noise: false,
            noise_volume: 1.0,
            force_playing_platformer: false,
            use_alternate_hook: false,
            show_console: false,
            stage: Stage::default(),
            use_fmod: false,
            cut_sounds: false,
            cut_by_releases: false,
            click_speedhack: 1.0,
            noise_speedhack: 1.0,
            load_clickpack_for: LoadClickpackFor::All,
            decouple_platformer: false,
            autosave_config: true,
            release_buttons_on_death: true,
            death_release_delay: death_release_delay_default(),
            death_release_delay_offset: death_release_delay_offset_default(),
            death_release_delay_neg: false,
            force_player2_sounds: false,
            play_noise_when_disabled: false,
            ignored_click_types: IgnoredClickTypes::default(),
            use_ingame_time: false,
            enhanced_recording_sync: false,
            time_smoothing_factor: default_time_smoothing_factor(),
            pause_detection_threshold: default_pause_detection_threshold(),
            instant_audio_response: true,
            input_latency_compensation: default_input_latency_compensation(),
            timing_mode: TimingMode::default(),
            allow_audio_finish_on_pause: default_allow_audio_finish_on_pause(),
            pause_debounce_threshold: default_pause_debounce_threshold(),
            rapid_pause_threshold: default_rapid_pause_threshold(),
            enable_audio_system_recovery: true,
            ui_scale: 1.0,
            toast_visibility: ToastVisibility::default(),
        }
    }
}

impl Config {
    pub fn load() -> Result<Self> {
        let mut path = PathBuf::from(".dcd/");
        log::debug!("creating directory {path:?}");
        std::fs::create_dir_all(&path)?;
        path.push("config.json");

        // try to read config
        log::debug!("trying to read config at {path:?}");
        if let Ok(f) = std::fs::File::open(&path) {
            let config = serde_json::from_reader(f)
                .map_err(|e| log::error!("failed to deserialize config at {path:?}: {e}"));
            if let Ok(config) = config {
                log::debug!("successfully read config at {path:?}");
                return Ok(config);
            }
        }

        // failed to read config, write default config
        let config = Self::default();
        log::debug!("creating file {path:?}");
        let f = std::fs::File::create(&path)?;
        log::debug!("writing default config to {path:?}");
        serde_json::to_writer_pretty(f, &config)?;
        Ok(config)
    }

    pub fn save(&self) {
        let Ok(f) = std::fs::File::create(".dcd/config.json") else {
            log::error!("failed to create config.json!");
            return;
        };
        let _ = serde_json::to_writer_pretty(f, self)
            .map_err(|e| log::error!("failed to write config: {e}"))
            .map(|_| log::debug!("successfully saved config to \".dcd/config.json\""));
    }
}

#[derive(Default, Clone, Copy)]
struct ClickTime {
    time: f64,
    typ: ClickType,
}

#[derive(Default)]
pub struct ClickTimes {
    jump: [ClickTime; 2],  // 2 players
    left: [ClickTime; 2],  // 2 players
    right: [ClickTime; 2], // 2 players
}

impl ClickTimes {
    #[inline]
    fn set_time(&mut self, button: Button, player2: bool, t: ClickTime, decouple: bool) {
        match button {
            Button::Jump => self.jump[player2 as usize] = t,
            Button::Left => self.left[player2 as usize] = t,
            Button::Right => {
                // TODO:
                // WTF:  `(if decouple { self.right } else { self.left })[player2 as usize] = time``
                //       causes a Rust miscompilation if `decouple` is false???
                if decouple {
                    self.right[player2 as usize] = t;
                } else {
                    self.left[player2 as usize] = t;
                }
            }
        }
    }

    #[inline]
    const fn get_prev_time(&self, button: Button, player2: bool, decouple: bool) -> ClickTime {
        match button {
            Button::Jump => self.jump[player2 as usize],
            Button::Left => self.left[player2 as usize],
            Button::Right => {
                if decouple {
                    self.right[player2 as usize]
                } else {
                    self.left[player2 as usize]
                }
            }
        }
    }
}

pub struct Bot {
    pub conf: Config,
    pub prev_conf: Config,
    pub last_conf_save: Instant,
    pub mixer: Mixer,
    #[cfg(not(feature = "geode"))]
    pub playlayer: PlayLayer,
    pub prev_times: ClickTimes,
    pub is_loading_clickpack: Arc<AtomicBool>,
    pub prev_pitch: f64,
    pub prev_volume: f64,
    pub prev_spam_offset: f64,
    pub buffer_size_changed: bool,
    pub noise_sound: Option<SoundHandle>,
    pub clickpacks: Vec<String>,
    pub last_clickpack_reload: Instant,
    // pub system: *mut FMOD_SYSTEM,
    // pub channel: *mut FMOD_CHANNEL,
    pub env: Env,
    pub toasts: Arc<Mutex<Toasts>>,
    // pub fmod_noise_sound: *mut FMOD_CHANNEL,
    pub show_fmod_buffersize_warn: bool,
    pub startup_buffer_size: u32,
    pub is_in_level: bool,
    pub playlayer_time: f64,
    pub clickpack: Clickpack,
    pub first_launch_dialog_timeout: f32,
    pub level_start: Instant,
    // Enhanced timing for recording synchronization
    pub last_game_time: f64,
    pub last_real_time: Instant,
    pub time_offset: f64,
    pub pause_compensation: f64,
    pub time_smoothing_buffer: Vec<(f64, f64)>, // (game_time, real_time) pairs
    // Dual timing system for instant response
    pub input_timestamps: Vec<(Instant, f64)>, // (real_input_time, compensation) pairs
    pub last_input_time: Instant,
    pub audio_playback_time: f64,
    pub sync_time_cache: f64,
    pub clickpack_db: ClickpackDb,
    pub clickpack_db_open: bool,
    pub prev_scale_factor: f32,
    pub dead_timer: f32,
    pub dead_timer_limit: f32,
    pub devices: Arc<Mutex<Vec<String>>>,
    // Enhanced pause-aware audio management
    pub is_game_paused: bool,
    // Performance metrics
    pub audio_latency_ms: f64,
    pub click_processing_time_us: u64,
    pub last_performance_check: Instant,
    pub pause_detected_time: Instant,
    pub pause_state_debounce_timer: Instant,
    pub last_pause_state: bool,
    pub rapid_pause_resume_count: u32,
    pub audio_system_needs_reset: bool,
    pub pending_audio_actions: Vec<PendingAudioAction>,
    // Enhanced FPS-based sync tracking
    pub fps_history: Vec<f64>,
    pub last_frame_time: Instant,
    pub current_fps: f64,
    pub frame_time_buffer: Vec<f64>,
    pub fps_compensation_active: bool,
}

impl Default for Bot {
    fn default() -> Self {
        let conf = Config::load().unwrap_or_default().fixup();
        let startup_buffer_size = conf.buffer_size;
        let now = Instant::now();
        Self {
            conf: conf.clone(),
            prev_conf: conf,
            last_conf_save: now,
            mixer: Mixer::new(),
            #[cfg(not(feature = "geode"))]
            playlayer: PlayLayer::NULL,
            prev_times: ClickTimes::default(),
            is_loading_clickpack: Arc::new(AtomicBool::new(false)),
            prev_pitch: f64::NAN,
            prev_volume: f64::NAN,
            prev_spam_offset: f64::NAN,
            buffer_size_changed: false,
            noise_sound: None,
            clickpacks: vec![],
            last_clickpack_reload: now,
            // system: std::ptr::null_mut(),
            // channel: std::ptr::null_mut(),
            env: Env::load(),
            toasts: Arc::new(Mutex::new(Toasts::new())),
            // fmod_noise_sound: std::ptr::null_mut(),
            show_fmod_buffersize_warn: false,
            startup_buffer_size,
            is_in_level: false,
            playlayer_time: 0.0,
            clickpack: Clickpack::default(),
            first_launch_dialog_timeout: 3.0,
            level_start: now,
            // Initialize enhanced timing fields
            last_game_time: 0.0,
            last_real_time: now,
            time_offset: 0.0,
            pause_compensation: 0.0,
            time_smoothing_buffer: Vec::with_capacity(10),
            // Initialize dual timing fields
            input_timestamps: Vec::with_capacity(20),
            last_input_time: now,
            audio_playback_time: 0.0,
            sync_time_cache: 0.0,
            clickpack_db: ClickpackDb::default(),
            clickpack_db_open: false,
            prev_scale_factor: 1.0,
            dead_timer: f32::NAN,
            dead_timer_limit: 0.0,
            devices: Arc::new(Mutex::new(vec![])),
            // Initialize enhanced pause-aware audio management
            is_game_paused: false,
            pause_detected_time: now,
            pause_state_debounce_timer: now,
            last_pause_state: false,
            rapid_pause_resume_count: 0,
            audio_system_needs_reset: false,
            pending_audio_actions: Vec::new(),
            // Performance metrics
            audio_latency_ms: 0.0,
            click_processing_time_us: 0,
            last_performance_check: now,
            // Initialize FPS tracking
            fps_history: Vec::with_capacity(60), // Store last 60 FPS samples
            last_frame_time: now,
            current_fps: 60.0,
            frame_time_buffer: Vec::with_capacity(10),
            fps_compensation_active: false,
        }
    }
}

fn help_text<R>(ui: &mut egui::Ui, help: &str, add_contents: impl FnOnce(&mut egui::Ui) -> R) {
    if help.is_empty() {
        add_contents(ui); // don't show help icon if there's no help text
        return;
    }
    ui.horizontal(|ui| {
        add_contents(ui);
        ui.add_enabled_ui(false, |ui| ui.label("(?)").on_disabled_hover_text(help));
    });
}



/// Value is always min clamped with 1.
fn u32_edit_field_min1(ui: &mut egui::Ui, value: &mut u32) -> egui::Response {
    let mut tmp_value = format!("{value}");
    let res = ui.text_edit_singleline(&mut tmp_value);
    if let Ok(result) = tmp_value.parse::<u32>() {
        *value = result.max(1);
    }
    res
}

/*
#[inline]
fn gd_audio_pitch() -> f32 {
    let mut pitch = 1.0f32;
    unsafe {
        let _ = FMOD_Channel_GetPitch(
            FMODAudioEngine::shared().current_sound_channel(),
            &mut pitch,
        );
    };
    pitch
}
*/

fn show_error_dialog(modal: Arc<Mutex<Modal>>, title: &str, body: &str) {
    log::error!("{title}: {body}");
    modal
        .lock()
        .dialog()
        .with_title(title)
        .with_body(utils::capitalize_first_letter(body))
        .with_icon(Icon::Error)
        .open();
}

fn drag_value<Num: emath::Numeric>(
    ui: &mut egui::Ui,
    value: &mut Num,
    text: impl Into<String>,
    clamp_range: RangeInclusive<Num>,
    help: &str,
) -> egui::Response {
    let mut resp = None;
    help_text(ui, help, |ui| {
        resp = Some(
            ui.add(
                DragValue::new(value)
                    .clamp_range(clamp_range.clone())
                    .speed(0.01),
            ),
        );
        ui.label(
            if resp.as_ref().unwrap().dragged()
                && (clamp_range.start() == value || clamp_range.end() == value)
            {
                RichText::new(text).color(Color32::LIGHT_RED)
            } else {
                RichText::new(text)
            },
        );
    });
    resp.unwrap()
}

const USER_AGENT: &str = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/37.0.2062.94 Chrome/37.0.2062.94 Safari/537.36";

fn ureq_agent() -> ureq::Agent {
    ureq::AgentBuilder::new()
        .timeout_read(Duration::from_secs(15))
        .timeout_write(Duration::from_secs(15))
        .user_agent(USER_AGENT)
        .build()
}

fn ureq_get(url: &str) -> Result<Vec<u8>, String> {
    let mut buf = Vec::new();
    ureq_agent()
        .get(url)
        .call()
        .map_err(|e| e.to_string())?
        .into_reader()
        .read_to_end(&mut buf)
        .map_err(|_| "failed to read body".to_string())?;
    Ok(buf)
}

impl Bot {
    fn maybe_init_kittyaudio(&mut self) {
        if self.conf.use_fmod {
            return;
        }
        log::debug!("starting kittyaudio playback thread");
        self.mixer = Mixer::new();
        let device = self.get_device();

        self.mixer.init_ex(
            device,
            StreamSettings {
                buffer_size: Some(self.conf.buffer_size),
                ..Default::default()
            },
        );
    }

    pub unsafe fn init_fmod(&mut self) -> Result<()> {
        /*
        const SYSTEM_SAMPLERATE: i32 = 48_000;
        log::info!("initializing fmod system");
        if !self.system.is_null() {
            self.release_fmod();
        }

        FMOD_System_Create(&mut self.system, FMOD_VERSION).fmod_result()?;
        let extra_driver_data = FMODAudioEngine::shared().extra_driver_data();

        FMOD_System_SetSoftwareFormat(self.system, SYSTEM_SAMPLERATE, FMOD_SPEAKERMODE_STEREO, 0)
            .fmod_result()?;

        // set buffer size
        /*
        FMOD_System_SetStreamBufferSize(self.system, self.conf.buffer_size, FMOD_TIMEUNIT_PCM)
            .fmod_result()?;

        let mut numbuffers = 0i32;
        let mut bufferlength = 0u32;
        FMOD_System_GetDSPBufferSize(self.system, &mut bufferlength, &mut numbuffers)
            .fmod_result()?;
        log::info!(
            "FMOD_System_GetDSPBufferSize: bufferlength: {bufferlength}, numbuffers: {numbuffers}"
        );
        FMOD_System_SetDSPBufferSize(self.system, self.conf.buffer_size, numbuffers)
            .fmod_result()?;
        */

        // init system
        self.fmod_apply_buffer_size()?;
        FMOD_System_Init(self.system, 2048, FMOD_INIT_NORMAL, extra_driver_data).fmod_result()?;

        log::info!("successfully initialized fmod system, samplerate: {SYSTEM_SAMPLERATE}");
        */
        Ok(())
    }

    //fn fmod_apply_buffer_size(&self) -> Result<()> {
    //    /*
    //    unsafe {
    //        FMOD_System_SetStreamBufferSize(self.system, self.conf.buffer_size, FMOD_TIMEUNIT_PCM)
    //            .fmod_result()?;
    //
    //        let mut numbuffers = 0i32;
    //        let mut bufferlength = 0u32;
    //        FMOD_System_GetDSPBufferSize(self.system, &mut bufferlength, &mut numbuffers)
    //            .fmod_result()?;
    //        log::info!(
    //            "FMOD_System_GetDSPBufferSize: bufferlength: {bufferlength}, numbuffers: {numbuffers}"
    //        );
    //        FMOD_System_SetDSPBufferSize(self.system, self.conf.buffer_size, numbuffers)
    //            .fmod_result()?;
    //    }
    //    */
    //    Ok(())
    //}

    pub fn release_fmod(&mut self) {
        /*
        let _ = unsafe {
            FMOD_System_Release(self.system)
                .fmod_result()
                .map_err(|e| log::error!("failed to release fmod system: {e}"))
        };
        self.system = std::ptr::null_mut();
        */
    }

    pub fn init(&mut self) {
        {
            let devices_arc = self.devices.clone();
            std::thread::spawn(move || {
                let mut prev_devices = vec![];
                loop {
                    if unsafe { BOT.conf.use_fmod } {
                        continue;
                    }
                    if let Ok(devices) = kittyaudio::device_names() {
                        // only lock when device lists do not match
                        if devices != prev_devices {
                            log::trace!("updated device list: {devices:?}");
                            *devices_arc.lock() = devices.clone();
                            prev_devices = devices;
                        }
                    } else {
                        log::warn!("Failed to get audio device names");
                    }
                    std::thread::sleep(Duration::from_secs(4));
                }
            });
        }

        // init audio playback
        if !self.conf.use_fmod {
            self.maybe_init_kittyaudio();
        }
        unsafe {
            let _ = self
                .init_fmod()
                .map_err(|e| log::error!("failed to init fmod: {e}"));
        };

        // reload clickpacks
        let _ = self
            .reload_clickpacks()
            .map_err(|e| log::error!("failed to reload clickpacks: {e}"));

        // preload clickpack
        self.preload_clickpack();

        // init game hooks
        #[cfg(not(feature = "geode"))]
        {
            log::debug!("initializing hooks");
            unsafe { hooks::init_hooks().unwrap() };
        }
    }

    fn preload_clickpack(&mut self) {
        log::info!("preloading clickpack, order: {:?}", self.env.clickpack_ord);
        use std::thread::JoinHandle;

        let preload_clickpack = |path: PathBuf,
                                 toasts: Arc<Mutex<Toasts>>,
                                 join_handle: Option<JoinHandle<()>>,
                                 load_for: LoadClickpackFor|
         -> JoinHandle<()> {
            // wait for the last spawned thread finish first; order is important here
            // (clickpack loading is not threadsafe)
            if let Some(handle) = join_handle {
                log::info!("waiting for other preload thread to finish");
                handle.join().unwrap();
                log::info!("other preload thread finished, continuing");
            }

            let is_loading_clickpack = self.is_loading_clickpack.clone();
            std::thread::spawn(move || {
                Self::load_clickpack_thread(
                    |e| {
                        toasts
                            .lock()
                            .add(Toast::error(format!("Failed to preload clickpack: {e}")));
                    },
                    &path,
                    is_loading_clickpack,
                    load_for,
                )
            })
        };

        let mut prev_join_handle: Option<JoinHandle<()>> = None;
        for (clickpack_env, load_for) in &self.env.clickpack_ord {
            log::info!("preloading clickpack {clickpack_env:?} for {load_for:?}");
            match clickpack_env {
                ClickpackEnv::Name(name) => {
                    let mut found = false;
                    for dirname in &self.clickpacks {
                        if dirname == name {
                            prev_join_handle = Some(preload_clickpack(
                                PathBuf::from(".dcd").join("clickpacks").join(dirname),
                                self.toasts.clone(),
                                prev_join_handle,
                                *load_for,
                            ));
                            found = true;
                            break;
                        }
                    }
                    if !found {
                        self.toasts
                            .lock()
                            .add(Toast::error(format!("Clickpack \"{name}\" not found")));
                    }
                }
                ClickpackEnv::Path(path) => {
                    prev_join_handle = Some(preload_clickpack(
                        path.clone(),
                        self.toasts.clone(),
                        prev_join_handle,
                        *load_for,
                    ));
                }
                ClickpackEnv::None => log::info!("env.json doesn't specify a clickpack"),
            }
        }
        if let Some(handle) = prev_join_handle {
            std::thread::spawn(|| {
                handle.join().unwrap();
                log::info!("all clickpacks preloaded, playing noise (if any)");
                unsafe { BOT.play_noise() };
            });
        }
    }

    fn get_pitch(&self) -> f64 {
        if self.conf.pitch_enabled {
            utils::f64_range(self.conf.pitch.from..=self.conf.pitch.to)
        } else {
            1.0
        }
    }

    #[allow(unused_variables)]
    pub fn on_init(&mut self, playlayer: usize) {
        #[cfg(not(feature = "geode"))]
        {
            self.playlayer.addr = playlayer;
        }

        self.prev_times = ClickTimes::default();
        self.prev_pitch = 0.0;
        self.prev_volume = self.conf.volume_settings.global_volume;
        self.prev_spam_offset = 0.0;
        self.is_in_level = true;
        let now = Instant::now();
        self.level_start = now;
        self.dead_timer = f32::NAN;

        // Initialize enhanced timing system
        self.last_game_time = 0.0;
        self.last_real_time = now;
        self.time_offset = 0.0;
        self.pause_compensation = 0.0;
        self.time_smoothing_buffer.clear();

        // Initialize dual timing system
        self.input_timestamps.clear();
        self.last_input_time = now;
        self.audio_playback_time = 0.0;
        self.sync_time_cache = 0.0;
    }

    pub fn on_reset(&mut self) {
        let now = Instant::now();
        self.level_start = now;
        self.prev_times = ClickTimes::default();
        self.dead_timer = f32::NAN;

        // Reset enhanced timing system for level restart
        self.last_game_time = 0.0;
        self.last_real_time = now;
        self.time_offset = 0.0;
        self.pause_compensation = 0.0;
        self.time_smoothing_buffer.clear();

        // Reset dual timing system
        self.input_timestamps.clear();
        self.last_input_time = now;
        self.audio_playback_time = 0.0;
        self.sync_time_cache = 0.0;

        // Reset enhanced pause-aware audio management
        self.is_game_paused = false;
        self.pause_detected_time = now;
        self.pause_state_debounce_timer = now;
        self.last_pause_state = false;
        self.rapid_pause_resume_count = 0;
        self.audio_system_needs_reset = false;
        self.pending_audio_actions.clear();
    }

    pub fn on_exit(&mut self) {
        self.on_init(0);
        self.is_in_level = false;
        self.dead_timer = f32::NAN;
    }

    unsafe fn release_buttons(&mut self) {
        log::info!("releasing buttons on death");
        for (button, t) in [
            (Button::Jump, self.prev_times.jump),
            (Button::Left, self.prev_times.left),
            (Button::Right, self.prev_times.right),
        ] {
            for (player, time) in t.iter().enumerate() {
                if time.typ.is_click() && time.time != 0.0 {
                    self.on_action(button, player == 1, false);
                }
            }
        }
    }

    pub unsafe fn on_death(&mut self) {
        if !self.conf.release_buttons_on_death {
            return;
        }

        let mut release_delay = self.conf.death_release_delay;
        let offset = self.conf.death_release_delay_offset;

        // release all buttons that are still pressed (or do that in the future)
        if release_delay == 0.0 && offset == 0.0 {
            self.release_buttons();
        } else {
            if offset != 0.0 {
                if self.conf.death_release_delay_neg {
                    release_delay += utils::f64_range(-offset..=offset);
                } else {
                    release_delay += utils::f64_range(0.0..=offset);
                }
            }
            if release_delay <= 0.0 {
                self.release_buttons();
                return;
            }
            self.dead_timer_limit = release_delay as f32;
            self.dead_timer = 0.0;
        }
    }

    pub unsafe fn on_update(&mut self, dt: f32) {
        // Update enhanced timing state for better recording synchronization
        self.update_timing_state();

        // Check and recover audio system if needed
        self.check_and_recover_audio_system();

        // Clean up old pending audio actions (older than 500ms)
        let _now = Instant::now();
        self.pending_audio_actions.retain(|action| {
            match action {
                PendingAudioAction::Play { timestamp, .. } => {
                    timestamp.elapsed().as_millis() < 500
                }
                _ => true, // Keep non-play actions
            }
        });

        // Reset rapid pause counter if enough time has passed without rapid changes
        if self.pause_state_debounce_timer.elapsed().as_secs_f64() > 1.0 {
            self.rapid_pause_resume_count = 0;
        }

        if !self.dead_timer.is_nan() {
            self.dead_timer += dt;
            if self.dead_timer >= self.dead_timer_limit {
                self.dead_timer = f32::NAN;
                self.release_buttons();
            }
        }
    }

    #[allow(unused_mut)]
    pub unsafe fn on_action(&mut self, button: Button, mut player2: bool, push: bool) {
        if self.clickpack.num_sounds == 0 || !self.is_in_level || !self.conf.enabled {
            return;
        }

        // Enhanced pause handling with action queuing
        if self.is_game_paused && self.conf.allow_audio_finish_on_pause {
            if self.conf.enable_audio_system_recovery {
                // Queue the action for later processing when resumed
                self.pending_audio_actions.push(PendingAudioAction::Play {
                    button,
                    player2,
                    push,
                    timestamp: Instant::now(),
                });
                log::trace!("Queued audio action during pause for later processing");
            } else {
                // Original behavior: skip new audio during pause
                log::trace!("Skipping new audio during pause - allowing current sounds to finish");
            }
            return;
        }

        // Check if audio system needs recovery
        self.check_and_recover_audio_system();

        // Record input event for instant response tracking
        self.record_input_event();

        #[cfg(not(feature = "geode"))]
        if player2 && !self.playlayer.is_null()
        /* FIXME(2.206): && !self.playlayer.level_settings().is_2player() */
        {
            player2 = self.conf.force_player2_sounds;
        }
        #[cfg(not(feature = "geode"))]
        if !self.playlayer.is_null() {
            return;
        }
        if button.is_platformer()
            && !self.conf.force_playing_platformer
            && !self.clickpack.has_platformer_sounds
        {
            return;
        }

        // Dual timing system: separate audio and sync timing
        let audio_time = self.get_predictive_audio_time();
        let sync_time = self.sync_time();

        if sync_time == 0.0 {
            return;
        }

        // Use sync time for timing calculations (accuracy)
        let prev_time =
            self.prev_times
                .get_prev_time(button, player2, self.conf.decouple_platformer);
        if prev_time.typ.is_click() && push {
            return;
        }
        let dt = (sync_time - prev_time.time).abs();
        let click_type = ClickType::from_time(push, dt, &self.conf.timings);
        if self.conf.ignored_click_types.is_ignored(click_type) {
            return;
        }
        let use_fmod = self.conf.use_fmod;

        // get click
        let mut click = self
            .clickpack
            .get_random_click(click_type, player2, button)
            .sound
            .clone();
        let pitch = self.get_pitch() * self.conf.click_speedhack;
        // if self.conf.sync_speed_with_game {
        //     pitch *= gd_audio_pitch() as f64;
        // }
        if !use_fmod {
            click.set_playback_rate(PlaybackRate::Factor(pitch));
        }

        // compute & change volume
        {
            let vol = &self.conf.volume_settings;
            let mut volume = 1.0;
            if vol.volume_var != 0.0 {
                volume += utils::f64_range(-vol.volume_var..=vol.volume_var);
            }

            // calculate spam volume change
            if (push || vol.change_releases_volume) && dt < vol.spam_time && vol.enabled {
                let offset = (vol.spam_time - dt) * vol.spam_vol_offset_factor;
                self.prev_spam_offset = offset;
                volume -= offset.min(vol.max_spam_vol_offset);
            } else {
                self.prev_spam_offset = 0.0;
            }

            if button.is_platformer() {
                volume *= vol.platformer_volume_factor;
            }

            // multiply by global volume after all of the changes
            volume *= vol.global_volume;

            if !use_fmod {
                // blehh
                click.set_volume(volume as f32);
            }
            self.prev_volume = volume;
        }

        // stop all playing sounds (acb behaviour)
        // But respect pause-aware audio settings
        if !use_fmod
            && self.conf.cut_sounds
            && (!click_type.is_release() || self.conf.cut_by_releases)
            && !(self.is_game_paused && self.conf.allow_audio_finish_on_pause)
        {
            for sound in &self.mixer.renderer.guard().sounds {
                // check if this is the noise sound, we don't want to stop it
                let sound_len = sound.guard().frames.len();
                if let Some(noise_sound) = &self.noise_sound {
                    if noise_sound.guard().frames.len() == sound_len {
                        continue;
                    }
                }

                // kis!!
                sound.seek_to_end();
            }
        }
        // FIXME: temporary 2.2 fix
        self.mixer.play(click);
        /*
        if !use_fmod {
            self.mixer.play(click);
        } else {
            /*
            unsafe {
                FMOD_System_PlaySound(
                    self.system,
                    click.fmod_sound,
                    std::ptr::null_mut(),
                    0,
                    &mut self.channel,
                );
                FMOD_Channel_SetPitch(self.channel, pitch as f32);
                FMOD_Channel_SetVolume(self.channel, self.prev_volume);
                FMOD_System_Update(self.system);
            }
            */
        }
        */
        // Store timing information using sync time for accuracy
        self.prev_times.set_time(
            button,
            player2,
            ClickTime {
                time: sync_time, // Use sync time for timing calculations
                typ: click_type,
            },
            self.conf.decouple_platformer,
        );
        self.prev_pitch = pitch;

        // Cache audio playback time for diagnostics
        self.audio_playback_time = audio_time;
    }

    /// Get timing for audio playback (prioritizes responsiveness)
    #[inline]
    fn audio_time(&mut self) -> f64 {
        match self.conf.timing_mode {
            TimingMode::Responsive => {
                // Always use real-time for maximum responsiveness
                self.level_start.elapsed().as_secs_f64() + self.conf.input_latency_compensation
            }
            TimingMode::Synchronized => {
                // Use synchronized time for perfect recording sync
                self.sync_time()
            }
            TimingMode::Hybrid => {
                // Use instant response if enabled, otherwise synchronized
                if self.conf.instant_audio_response {
                    self.level_start.elapsed().as_secs_f64() + self.conf.input_latency_compensation
                } else {
                    self.sync_time()
                }
            }
        }
    }

    /// Get timing for synchronization calculations (prioritizes accuracy)
    #[inline]
    fn sync_time(&mut self) -> f64 {
        if !self.conf.use_ingame_time {
            return self.level_start.elapsed().as_secs_f64();
        }

        // Get raw game time
        let raw_game_time = {
            #[cfg(feature = "geode")]
            {
                if self.playlayer_time != 0.0 {
                    self.playlayer_time
                } else {
                    return self.level_start.elapsed().as_secs_f64();
                }
            }
            #[cfg(not(feature = "geode"))]
            {
                if !self.playlayer.is_null() {
                    self.playlayer.time()
                } else {
                    return self.level_start.elapsed().as_secs_f64();
                }
            }
        };

        // Update FPS tracking for enhanced sync
        self.update_fps_tracking();

        if !self.conf.enhanced_recording_sync && !self.conf.fps_sync_enabled && !self.conf.advanced_sync_features {
            return raw_game_time;
        }

        // Use enhanced synchronization with FPS compensation and advanced features
        self.get_enhanced_synchronized_time(raw_game_time)
    }

    /// Legacy time method for backward compatibility
    #[inline]
    #[allow(dead_code)]
    fn time(&mut self) -> f64 {
        // Use sync time for timing calculations to maintain accuracy
        self.sync_time()
    }

    /// Enhanced timing calculation for better recording synchronization
    fn get_synchronized_time(&mut self, raw_game_time: f64) -> f64 {
        let current_real_time = Instant::now();
        let real_elapsed = current_real_time.duration_since(self.last_real_time).as_secs_f64();

        // Detect potential pause/resume by checking for large time jumps
        let game_time_delta = raw_game_time - self.last_game_time;
        let is_paused = real_elapsed > self.conf.pause_detection_threshold && game_time_delta < real_elapsed * 0.5;

        // Enhanced pause state management with debouncing
        self.update_pause_state_with_debouncing(is_paused, current_real_time);

        if is_paused {
            // During pause, maintain the last known synchronized time
            return self.last_game_time + self.time_offset;
        }

        // Calculate time drift between game time and real time
        let expected_real_time = self.level_start.elapsed().as_secs_f64();
        let time_drift = raw_game_time - expected_real_time;

        // Apply smoothing to reduce timing jitter during recording
        let smoothed_time = if !self.time_smoothing_buffer.is_empty() {
            let avg_drift = self.time_smoothing_buffer.iter()
                .map(|(_, drift)| *drift)
                .sum::<f64>() / self.time_smoothing_buffer.len() as f64;

            let smoothing = self.conf.time_smoothing_factor;
            raw_game_time + (avg_drift * smoothing) + (time_drift * (1.0 - smoothing))
        } else {
            raw_game_time
        };

        smoothed_time + self.pause_compensation
    }

    /// Update timing state for enhanced synchronization
    /// This should be called regularly to maintain accurate timing data
    fn update_timing_state(&mut self) {
        if !self.conf.use_ingame_time || !self.conf.enhanced_recording_sync {
            // Even if enhanced sync is disabled, we still need to detect pauses for audio management
            self.update_pause_state_basic();
            return;
        }

        let current_real_time = Instant::now();
        let raw_game_time = {
            #[cfg(feature = "geode")]
            {
                self.playlayer_time
            }
            #[cfg(not(feature = "geode"))]
            {
                if !self.playlayer.is_null() {
                    self.playlayer.time()
                } else {
                    return;
                }
            }
        };

        // Update smoothing buffer with recent timing data
        let real_elapsed = current_real_time.duration_since(self.level_start).as_secs_f64();
        let time_drift = raw_game_time - real_elapsed;

        self.time_smoothing_buffer.push((raw_game_time, time_drift));

        // Keep buffer size manageable (last 10 samples for smoothing)
        if self.time_smoothing_buffer.len() > 10 {
            self.time_smoothing_buffer.remove(0);
        }

        // Detect and compensate for pauses
        let real_delta = current_real_time.duration_since(self.last_real_time).as_secs_f64();
        let game_delta = raw_game_time - self.last_game_time;

        let is_paused = real_delta > self.conf.pause_detection_threshold && game_delta < real_delta * 0.5;

        // Enhanced pause state management with debouncing (for enhanced timing system)
        self.update_pause_state_with_debouncing(is_paused, current_real_time);

        if is_paused {
            // Game was likely paused, accumulate pause compensation
            self.pause_compensation += real_delta - game_delta;
        }

        // Update state for next iteration
        self.last_game_time = raw_game_time;
        self.last_real_time = current_real_time;
    }

    /// Enhanced pause state management with debouncing and rapid change detection
    fn update_pause_state_with_debouncing(&mut self, is_paused: bool, current_time: Instant) {
        let debounce_elapsed = current_time.duration_since(self.pause_state_debounce_timer).as_secs_f64();

        // Check if we should apply debouncing
        let should_debounce = debounce_elapsed < self.conf.pause_debounce_threshold;

        // Detect rapid pause/resume cycles
        if is_paused != self.last_pause_state && !should_debounce {
            self.rapid_pause_resume_count += 1;
            self.pause_state_debounce_timer = current_time;

            // Check if we've exceeded the rapid pause threshold
            if self.rapid_pause_resume_count >= self.conf.rapid_pause_threshold {
                log::warn!("Rapid pause/resume cycles detected ({}), marking audio system for reset",
                          self.rapid_pause_resume_count);
                self.audio_system_needs_reset = true;
                self.rapid_pause_resume_count = 0; // Reset counter
            }
        }

        // Only update pause state if not debouncing or if it's been stable
        if !should_debounce || is_paused == self.last_pause_state {
            if is_paused && !self.is_game_paused {
                // Game just paused
                self.is_game_paused = true;
                self.pause_detected_time = current_time;
                log::debug!("Game pause detected - allowing current audio to finish");

                // If audio system recovery is enabled, handle pause more gracefully
                if self.conf.enable_audio_system_recovery && self.conf.allow_audio_finish_on_pause {
                    // Don't immediately stop sounds, let them finish naturally
                    log::debug!("Allowing current audio to finish during pause");
                }
            } else if !is_paused && self.is_game_paused {
                // Game just resumed
                self.is_game_paused = false;
                log::debug!("Game resumed - normal audio behavior restored");

                // Process any pending audio actions that were queued during pause
                if self.conf.enable_audio_system_recovery {
                    self.process_pending_audio_actions();
                }
            }

            self.last_pause_state = is_paused;
        }
    }

    /// Basic pause detection for standard timing system
    /// Used when enhanced recording sync is disabled but pause-aware audio is still needed
    fn update_pause_state_basic(&mut self) {
        if !self.conf.use_ingame_time || !self.conf.allow_audio_finish_on_pause {
            return;
        }

        let current_real_time = Instant::now();
        let raw_game_time = {
            #[cfg(feature = "geode")]
            {
                self.playlayer_time
            }
            #[cfg(not(feature = "geode"))]
            {
                if !self.playlayer.is_null() {
                    self.playlayer.time()
                } else {
                    return;
                }
            }
        };

        // Simple pause detection without the full enhanced timing system
        let real_delta = current_real_time.duration_since(self.last_real_time).as_secs_f64();
        let game_delta = raw_game_time - self.last_game_time;

        let is_paused = real_delta > self.conf.pause_detection_threshold && game_delta < real_delta * 0.5;

        // Enhanced pause state management with debouncing (for basic timing system)
        self.update_pause_state_with_debouncing(is_paused, current_real_time);

        // Update state for next iteration
        self.last_game_time = raw_game_time;
        self.last_real_time = current_real_time;
    }

    /// Update FPS tracking for enhanced sync calculations
    fn update_fps_tracking(&mut self) {
        if !self.conf.fps_sync_enabled {
            return;
        }

        let current_time = Instant::now();
        let frame_delta = current_time.duration_since(self.last_frame_time).as_secs_f64();

        if frame_delta > 0.0 {
            let current_fps = 1.0 / frame_delta;

            // Add to FPS history
            self.fps_history.push(current_fps);
            if self.fps_history.len() > 60 {
                self.fps_history.remove(0);
            }

            // Calculate smoothed FPS
            if !self.fps_history.is_empty() {
                self.current_fps = self.fps_history.iter().sum::<f64>() / self.fps_history.len() as f64;
            }

            // Add to frame time buffer for smoothing
            if self.conf.frame_time_smoothing {
                self.frame_time_buffer.push(frame_delta);
                if self.frame_time_buffer.len() > 10 {
                    self.frame_time_buffer.remove(0);
                }
            }

            // Check if FPS compensation should be active
            let fps_deviation = (self.current_fps - self.conf.target_fps).abs();
            self.fps_compensation_active = fps_deviation > self.conf.adaptive_sync_threshold * self.conf.target_fps;

            self.last_frame_time = current_time;
        }
    }

    /// Get FPS-compensated timing for enhanced recording sync
    fn get_fps_compensated_time(&mut self, base_time: f64) -> f64 {
        if !self.conf.fps_sync_enabled || !self.fps_compensation_active {
            return base_time;
        }

        // Calculate FPS compensation factor
        let fps_ratio = self.current_fps / self.conf.target_fps;
        let compensation = (fps_ratio - 1.0) * self.conf.fps_compensation_factor;

        // Apply frame time smoothing if enabled
        let smoothed_compensation = if self.conf.frame_time_smoothing && !self.frame_time_buffer.is_empty() {
            let avg_frame_time = self.frame_time_buffer.iter().sum::<f64>() / self.frame_time_buffer.len() as f64;
            let target_frame_time = 1.0 / self.conf.target_fps;
            let frame_compensation = (avg_frame_time - target_frame_time) * self.conf.fps_compensation_factor;
            (compensation + frame_compensation) * 0.5
        } else {
            compensation
        };

        base_time + (base_time * smoothed_compensation)
    }

    /// Enhanced sync with FPS compensation and advanced features
    fn get_enhanced_synchronized_time(&mut self, raw_game_time: f64) -> f64 {
        // Start with basic synchronized time
        let base_sync_time = if self.conf.enhanced_recording_sync {
            self.get_synchronized_time(raw_game_time)
        } else {
            raw_game_time
        };

        // Apply FPS compensation if enabled
        let fps_compensated_time = self.get_fps_compensated_time(base_sync_time);

        // Apply advanced sync features if enabled
        if self.conf.advanced_sync_features {
            // Additional smoothing for very stable recording sync
            let smoothing_factor = self.conf.time_smoothing_factor * 0.5; // More conservative for advanced mode
            let time_delta = fps_compensated_time - self.last_game_time;

            if time_delta.abs() < self.conf.adaptive_sync_threshold {
                // Small changes - apply heavy smoothing
                self.last_game_time + (time_delta * smoothing_factor)
            } else {
                // Large changes - less smoothing to maintain responsiveness
                fps_compensated_time
            }
        } else {
            fps_compensated_time
        }
    }

    /// Record input timestamp for instant response tracking
    fn record_input_event(&mut self) {
        let now = Instant::now();
        let compensation = self.calculate_input_compensation();

        self.input_timestamps.push((now, compensation));
        self.last_input_time = now;

        // Keep buffer size manageable (last 20 inputs for analysis)
        if self.input_timestamps.len() > 20 {
            self.input_timestamps.remove(0);
        }
    }

    /// Calculate input latency compensation based on recent input patterns
    fn calculate_input_compensation(&self) -> f64 {
        if self.input_timestamps.is_empty() {
            return self.conf.input_latency_compensation;
        }

        // Analyze recent input timing patterns to predict optimal compensation
        let recent_inputs = self.input_timestamps.iter()
            .rev()
            .take(5)
            .collect::<Vec<_>>();

        if recent_inputs.len() < 2 {
            return self.conf.input_latency_compensation;
        }

        // Calculate average time between recent inputs
        let mut total_delta = 0.0;
        for i in 1..recent_inputs.len() {
            let delta = recent_inputs[i-1].0.duration_since(recent_inputs[i].0).as_secs_f64();
            total_delta += delta;
        }
        let avg_input_rate = total_delta / (recent_inputs.len() - 1) as f64;

        // Adjust compensation based on input rate (faster inputs need less compensation)
        let base_compensation = self.conf.input_latency_compensation;
        let rate_factor = (avg_input_rate * 10.0).min(1.0); // Scale factor based on input rate

        base_compensation * rate_factor
    }

    /// Get predictive timing for immediate audio response
    fn get_predictive_audio_time(&mut self) -> f64 {
        let base_time = self.audio_time();

        if !self.conf.instant_audio_response {
            return base_time;
        }

        // Apply predictive compensation for ultra-low latency
        let compensation = self.calculate_input_compensation();
        base_time - compensation // Subtract to play audio earlier
    }

    /// Get timing diagnostics for debugging and verification
    pub fn get_timing_diagnostics(&self) -> String {
        let real_elapsed = self.level_start.elapsed().as_secs_f64();
        let game_time = {
            #[cfg(feature = "geode")]
            {
                self.playlayer_time
            }
            #[cfg(not(feature = "geode"))]
            {
                if !self.playlayer.is_null() {
                    self.playlayer.time()
                } else {
                    0.0
                }
            }
        };

        let timing_mode_str = self.conf.timing_mode.text();
        let input_compensation = self.conf.input_latency_compensation;
        let last_input_age = self.last_input_time.elapsed().as_secs_f64();

        if !self.conf.use_ingame_time {
            return format!(
                "Real-time mode:\n\
                Timing Mode: {}\n\
                Real Time: {:.3}s\n\
                Audio Time: {:.3}s\n\
                Input Compensation: {:.3}s\n\
                Last Input: {:.3}s ago\n\
                Instant Response: {}\n\
                Pause-Aware Audio: {}\n\
                Game Paused: {}",
                timing_mode_str,
                real_elapsed,
                self.audio_playback_time,
                input_compensation,
                last_input_age,
                self.conf.instant_audio_response,
                self.conf.allow_audio_finish_on_pause,
                self.is_game_paused
            );
        }

        if !self.conf.enhanced_recording_sync {
            return format!(
                "Basic in-game time mode:\n\
                Timing Mode: {}\n\
                Game Time: {:.3}s\n\
                Real Time: {:.3}s\n\
                Audio Time: {:.3}s\n\
                Drift: {:.3}s\n\
                Input Compensation: {:.3}s\n\
                Last Input: {:.3}s ago\n\
                Instant Response: {}\n\
                Pause-Aware Audio: {}\n\
                Game Paused: {}",
                timing_mode_str,
                game_time,
                real_elapsed,
                self.audio_playback_time,
                game_time - real_elapsed,
                input_compensation,
                last_input_age,
                self.conf.instant_audio_response,
                self.conf.allow_audio_finish_on_pause,
                self.is_game_paused
            );
        }

        let avg_drift = if !self.time_smoothing_buffer.is_empty() {
            self.time_smoothing_buffer.iter()
                .map(|(_, drift)| *drift)
                .sum::<f64>() / self.time_smoothing_buffer.len() as f64
        } else {
            0.0
        };

        format!(
            "Dual Timing System (Enhanced):\n\
            Timing Mode: {}\n\
            Game Time: {:.3}s\n\
            Real Time: {:.3}s\n\
            Audio Time: {:.3}s\n\
            Sync Time: {:.3}s\n\
            Raw Drift: {:.3}s\n\
            Avg Drift: {:.3}s\n\
            Pause Compensation: {:.3}s\n\
            Input Compensation: {:.3}s\n\
            Last Input: {:.3}s ago\n\
            Smoothing Factor: {:.1}%\n\
            Buffer Size: {}/10\n\
            Input Buffer: {}/20\n\
            Instant Response: {}\n\
            Pause-Aware Audio: {}\n\
            Game Paused: {}",
            timing_mode_str,
            game_time,
            real_elapsed,
            self.audio_playback_time,
            self.sync_time_cache,
            game_time - real_elapsed,
            avg_drift,
            self.pause_compensation,
            input_compensation,
            last_input_age,
            self.conf.time_smoothing_factor * 100.0,
            self.time_smoothing_buffer.len(),
            self.input_timestamps.len(),
            self.conf.instant_audio_response,
            self.conf.allow_audio_finish_on_pause,
            self.is_game_paused
        )
    }

    fn open_clickbot_toggle_toast(&self) {
        self.toasts.lock().add(Toast::info(if self.conf.enabled {
            "Enabled clickbot"
        } else {
            "Disabled clickbot"
        }));
    }

    fn reload_clickpacks(&mut self) -> Result<()> {
        let path = Path::new(".dcd/clickpacks");
        std::fs::create_dir_all(path)?;
        let dir = path.read_dir()?;
        let prev_clickpacks = std::mem::take(&mut self.clickpacks);
        for entry in dir {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                let name = path.file_name().unwrap().to_string_lossy().to_string();
                self.clickpack_db.mark_downloaded(&name, path, true);
                self.clickpacks.push(name);
            }
        }
        for prev in &prev_clickpacks {
            if !self.clickpacks.contains(prev) {
                self.clickpack_db
                    .mark_downloaded(prev, path.to_path_buf(), false);
            }
        }
        Ok(())
    }

    pub fn draw_ui(&mut self, ctx: &egui::Context) {
        // process hotkeys
        let wants_keyboard = ctx.wants_keyboard_input();
        let (toggle_menu, toggle_bot, toggle_noise) = ctx.input_mut(|i| {
            // for some reason it deadlocks when i put `ctx.wants_keyboard_input()` here?
            if wants_keyboard {
                (false, false, false)
            } else {
                (
                    self.conf.shortcuts.toggle_menu.pressed(i),
                    self.conf.shortcuts.toggle_bot.pressed(i),
                    self.conf.shortcuts.toggle_noise.pressed(i),
                )
            }
        });
        if toggle_menu {
            self.conf.hidden = !self.conf.hidden;
        }
        if toggle_bot {
            self.conf.enabled = !self.conf.enabled;
        }
        if toggle_noise {
            self.conf.play_noise = !self.conf.play_noise;
            self.play_noise();
        }

        // autosave config
        if self.conf != self.prev_conf && self.last_conf_save.elapsed() > Duration::from_secs(5) {
            self.last_conf_save = Instant::now();
            self.conf.save();
            self.prev_conf = self.conf.clone();
        }

        // change ui scale if needed
        ctx.set_zoom_factor(
            self.conf
                .ui_scale
                .clamp(*UI_SCALE_RANGE.start(), *UI_SCALE_RANGE.end()),
        );

        // dialog on first launch
        if self.env.is_first_launch {
            let modal = Modal::new(ctx, "first_launch_dialog");
            modal.show(|ui| {
                modal.title(ui, "Welcome to dcd Live!");
                modal.body_and_icon(
                    ui,
                    "This seems to be your first time using dcd Live.\n\
                    • Press 1 to open the menu\n\
                    • Press 2 to toggle the clickbot\n\
                    • Explore ClickpackDB to download new clickpacks\n\
                    You can change the hotkeys in the Options section",
                    Icon::Info,
                );
                modal.buttons(ui, |ui| {
                    if self.first_launch_dialog_timeout > 0.0 {
                        ui.add_enabled_ui(false, |ui| {
                            let _ = ui
                                .button(format!("{:.0}…", self.first_launch_dialog_timeout.ceil()));
                        });
                        self.first_launch_dialog_timeout -= ctx.input(|i| i.unstable_dt);
                    } else if ui.button("Got it").clicked() {
                        self.env.is_first_launch = false;
                        self.env.save();
                        modal.close();
                    }
                    ui.hyperlink_to("Join the Discord server!", "https://discord.gg/BRVVVzxESu");
                });
            });
            modal.open();
        }

        // process toasts, even if not open
        if toggle_bot {
            self.open_clickbot_toggle_toast();
            self.play_noise();
        }
        if toggle_noise {
            self.open_noise_toggle_toast();
        }

        // don't draw and don't reload clickpacks if not open
        if self.conf.hidden {
            if matches!(self.conf.toast_visibility, ToastVisibility::AlwaysVisible) {
                self.toasts.lock().show(ctx); // but still draw toast queue
            }
            return;
        }

        // clickpack reloading
        if self.last_clickpack_reload.elapsed() > Duration::from_secs(5) {
            let _ = self
                .reload_clickpacks()
                .map_err(|e| log::error!("failed to reload clickpacks: {e}"));
            self.last_clickpack_reload = Instant::now();
        }

        // draw overlay
        let modal = Arc::new(Mutex::new(Modal::new(ctx, "global_modal")));

        // Simple default styling
        ctx.style_mut(|s| {
            s.interaction.tooltip_delay = 0.0;
        });

        // Simple window
        egui::Window::new("DcD Live")
            .resizable(true)
            .show(ctx, |ui| {
                // Simple header
                ui.horizontal(|ui| {
                    ui.label(egui::RichText::new("DcD Live").heading());
                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                        let status_text = if self.conf.enabled { "ENABLED" } else { "DISABLED" };
                        ui.label(status_text);
                    });
                });

                ui.add_space(12.0);

                // Simple tab navigation
                ui.horizontal(|ui| {
                    ui.selectable_value(&mut self.conf.stage, Stage::Clickpack, "Clickpack");
                    ui.selectable_value(&mut self.conf.stage, Stage::Audio, "Audio");
                    ui.selectable_value(&mut self.conf.stage, Stage::Options, "Options");
                });
                ui.separator();

                ui.add_space(16.0);

                // Simple content area
                egui::ScrollArea::both()
                    .show(ui, |ui| {
                        match self.conf.stage {
                            Stage::Clickpack => self.show_clickpack_window(ui, modal.clone()),
                            Stage::Audio => {
                                // Simple main toggle
                                if ui.checkbox(&mut self.conf.enabled, "Enable DcD Live").clicked() {
                                    self.open_clickbot_toggle_toast();
                                    self.play_noise();
                                }



                                ui.add_space(16.0);
                                ui.add_enabled_ui(self.conf.enabled, |ui| {
                                    self.show_audio_window(ui);
                                });
                            }
                            Stage::Options => self.show_options_window(ui, ctx, modal.clone()),
                        };
                    });
            });

        // show clickpackdb, if open
        self.show_clickpackdb_window(ctx, modal.clone());

        // show modal & toast queue
        modal.lock().show_dialog();
        if matches!(
            self.conf.toast_visibility,
            ToastVisibility::AlwaysVisible | ToastVisibility::VisibleWhenOpen
        ) {
            self.toasts.lock().show(ctx);
        }
    }

    #[cfg(not(feature = "geode"))]
    pub fn maybe_alloc_console(&self) {
        if self.conf.show_console && unsafe { AllocConsole() }.is_ok() {
            use std::sync::Once;
            static INIT_ONCE: Once = Once::new();
            INIT_ONCE.call_once(|| {
                simple_logger::SimpleLogger::new()
                    .init()
                    .expect("failed to initialize simple_logger");
            });
        } else {
            unsafe {
                let _ = FreeConsole();
            }
        }
    }

    fn show_options_window(
        &mut self,
        ui: &mut egui::Ui,
        ctx: &egui::Context,
        modal: Arc<Mutex<Modal>>,
    ) {
        ui.collapsing("Shortcuts", |ui| {
            let mut show_shortcut = |shortcut: &mut Shortcut, id: &'static str, name: &str| {
                ui.horizontal(|ui| {
                    ui.vertical(|ui| ui.add(Keybind::new(shortcut, id).with_text(name)));
                    if *shortcut != Shortcut::NONE
                        && ui
                            .button("Clear")
                            .on_hover_text("Set the shortcut to none")
                            .clicked()
                    {
                        *shortcut = Shortcut::NONE;
                    }
                });
            };
            show_shortcut(
                &mut self.conf.shortcuts.toggle_menu,
                "toggle_menu_keybind",
                "Toggle menu",
            );
            show_shortcut(
                &mut self.conf.shortcuts.toggle_bot,
                "toggle_bot_keybind",
                "Toggle bot",
            );
            show_shortcut(
                &mut self.conf.shortcuts.toggle_noise,
                "toggle_noise_keybind",
                "Toggle noise",
            );
        });
        ui.collapsing("Configuration", |ui| {
            ui.horizontal(|ui| {
                let slider = ui.add(
                    egui::Slider::new(&mut self.conf.ui_scale, UI_SCALE_RANGE)
                        .step_by(0.001)
                        .text("UI Scale"),
                );
                if slider.clicked() {
                    self.prev_scale_factor = ctx.zoom_factor();
                }
                egui_gl_hook::set_changing_scale(
                    slider.changed()
                        || slider.clicked()
                        || slider.dragged()
                        || slider.drag_stopped()
                        || slider.has_focus(),
                    self.prev_scale_factor,
                );
                if self.conf.ui_scale != 1.0
                    && ui
                        .button("Reset")
                        .on_hover_text("Reset to 100% scale")
                        .clicked()
                {
                    self.conf.ui_scale = 1.0;
                }
            });
            // #[cfg(not(feature = "geode"))]
            ui.horizontal(|ui| {
                help_text(
                    ui,
                    "Use an alternate button hook for bot compatibility",
                    |ui| ui.checkbox(&mut self.conf.use_alternate_hook, "Use alternate hook"),
                );
            });
            #[cfg(not(feature = "geode"))]
            help_text(ui, "Show debug console", |ui| {
                if ui
                    .checkbox(&mut self.conf.show_console, "Show console")
                    .changed()
                {
                    if self.conf.show_console {
                        self.maybe_alloc_console();
                    } else {
                        let _ = unsafe { FreeConsole() };
                    }
                }
            });
            help_text(
                ui,
                "Automatically save configuration changes every 5 seconds.\n\
                If this is disabled, the config will still be saved on graceful exit",
                |ui| ui.checkbox(&mut self.conf.autosave_config, "Auto-save config"),
            );

            // Enhanced Toast Visibility section
            ui.add_space(8.0);
            ui.horizontal(|ui| {
                ui.label(egui::RichText::new("💬").size(16.0));
                ui.add_space(6.0);
                ui.vertical(|ui| {
                    ui.label(egui::RichText::new("Toast Notifications").size(13.0).strong());
                    ui.label(egui::RichText::new("Control when notifications appear").size(10.0).color(egui::Color32::from_gray(140)));
                });
            });

            ui.add_space(8.0);
            egui::ComboBox::from_label("")
                .selected_text(self.conf.toast_visibility.text())
                .width(200.0)
                .show_ui(ui, |ui| {
                    ui.selectable_value(
                        &mut self.conf.toast_visibility,
                        ToastVisibility::AlwaysVisible,
                        ToastVisibility::AlwaysVisible.text(),
                    );
                    ui.selectable_value(
                        &mut self.conf.toast_visibility,
                        ToastVisibility::VisibleWhenOpen,
                        ToastVisibility::VisibleWhenOpen.text(),
                    );
                    ui.selectable_value(
                        &mut self.conf.toast_visibility,
                        ToastVisibility::NeverVisible,
                        ToastVisibility::NeverVisible.text(),
                    );
                });

            // Enhanced configuration buttons with modern styling
            ui.add_space(16.0);
            egui::Frame::none()
                .fill(egui::Color32::from_gray(20))
                .rounding(egui::Rounding::same(8.0))
                .inner_margin(egui::Margin::same(12.0))
                .show(ui, |ui| {
                    ui.horizontal(|ui| {
                        ui.label(egui::RichText::new("⚙️").size(16.0));
                        ui.add_space(6.0);
                        ui.label(egui::RichText::new("Configuration Management").size(13.0).strong());
                    });

                    ui.add_space(12.0);

                    ui.horizontal(|ui| {
                        ui.spacing_mut().item_spacing.x = 8.0;

                        // Save button
                        if modern_button(ui, "💾 Save", egui::Color32::from_rgb(34, 197, 94), Some([80.0, 32.0].into()))
                            .on_hover_text("Save the current configuration")
                            .clicked()
                        {
                            self.conf.save();
                            self.toasts
                                .lock()
                                .add(Toast::success("Saved configuration to .dcd/config.json"));
                        }

                        // Load button
                        if modern_button(ui, "📂 Load", egui::Color32::from_rgb(100, 150, 255), Some([80.0, 32.0].into()))
                            .on_hover_text("Load the config from .dcd/config.json")
                            .clicked()
                        {
                            let conf = Config::load();
                            if let Ok(conf) = conf {
                                self.conf = conf;
                                self.apply_config();
                                self.toasts
                                    .lock()
                                    .add(Toast::success("Loaded configuration from .dcd/config.json"));
                            } else if let Err(e) = conf {
                                show_error_dialog(modal.clone(), "Failed to load config!", &e.to_string());
                            }
                        }

                        // Reset button
                        if modern_button(ui, "🔄 Reset", egui::Color32::from_rgb(239, 68, 68), Some([80.0, 32.0].into()))
                            .on_hover_text("Reset the current configuration to defaults")
                            .clicked()
                        {
                            let prev_stage = self.conf.stage;
                            self.conf = Config::default();
                            self.conf.stage = prev_stage; // don't switch current tab
                            self.apply_config();
                            self.toasts
                                .lock()
                                .add(Toast::info("Reset configuration to defaults"));
                        }

                        // Open folder button
                        if modern_button(ui, "📁 Open Folder", egui::Color32::from_rgb(156, 163, 175), Some([110.0, 32.0].into()))
                            .on_hover_text("Open .dcd folder")
                            .clicked()
                        {
                            let _ = std::fs::create_dir_all(".dcd")
                                .map_err(|e| log::error!("failed to create .dcd: {e}"));
                            let _ = Command::new("explorer").arg(".dcd").spawn().map_err(|e| {
                                show_error_dialog(modal, "Failed to open folder!", &e.to_string());
                            });
                        }
                    });
                });
        });
        ui.hyperlink_to("Join the Discord server!", "https://discord.gg/BRVVVzxESu");
        ui.allocate_space(ui.available_size() - vec2(0.0, 280.0));
    }

    fn get_device(&mut self) -> Device {
        Device::from_name(&self.env.selected_device).unwrap_or_default()
    }

    fn show_device_switcher(&mut self, ui: &mut egui::Ui) {
        ui.horizontal(|ui| {
            egui::ComboBox::from_label("Output device")
                .selected_text(&self.env.selected_device)
                .show_ui(ui, |ui| {
                    let devices = self.devices.lock().clone();
                    for device in &devices {
                        let is_selected = &self.env.selected_device == device;
                        if ui
                            .selectable_value(&mut self.env.selected_device, device.clone(), device)
                            .clicked()
                            && !is_selected
                        {
                            // start a new mixer on new device
                            log::info!("switching audio device to \"{device}\"");
                            self.maybe_init_kittyaudio();
                            self.play_noise();
                            self.env.save();
                            self.toasts
                                .lock()
                                .add(Toast::success(format!("Switched device to \"{device}\"")));
                            //kind: ToastKind::Success,
                            //text: format!("Switched device to \"{device}\"").into(),
                            //options: ToastOptions::default().duration_in_seconds(3.0),);
                        }
                    }
                })
                .response
                .on_disabled_hover_text("Not available with FMOD");
            if ui
                .button("Reset")
                .on_hover_text("Reset to the default audio device")
                .clicked()
            {
                self.mixer = Mixer::new();
                self.mixer.init();
                if let Ok(name) = Device::Default.name() {
                    self.env.selected_device = name.clone();
                    self.toasts
                        .lock()
                        .add(Toast::success(format!("Switched device to \"{name}\"")));
                }
                self.play_noise();
                self.env.save();
                log::debug!("reset audio device");
            }
        });
    }

    fn play_noise(&mut self) {
        let stop_kittyaudio_noise = |noise_sound: &mut Option<SoundHandle>| {
            if let Some(noise_sound) = noise_sound {
                noise_sound.set_playback_rate(PlaybackRate::Factor(1.0));
                noise_sound.set_loop_enabled(false);
                noise_sound.seek_to_end();
            }
            *noise_sound = None;
        };
        // let stop_fmod_noise = |fmodn: &mut *mut FMOD_CHANNEL| {
        //     unsafe { FMOD_Channel_Stop(*fmodn) };
        //     *fmodn = std::ptr::null_mut();
        // };
        let mut start_kittyaudio_noise = |noise_sound: &mut Option<SoundHandle>| {
            if let Some(mut noise) = self.clickpack.noise.clone() {
                noise.set_volume(self.conf.noise_volume as f32);
                noise.set_loop_enabled(true);
                let frames = noise.frames.len().saturating_sub(1);
                noise.set_loop_index(0..=frames);
                noise.set_playback_rate(PlaybackRate::Factor(self.conf.noise_speedhack));
                *noise_sound = Some(self.mixer.play(noise.sound));
            }
        };
        /*
        let start_fmod_noise = |fmodn: &mut *mut FMOD_CHANNEL| unsafe {
            if let Some(noise) = self.noise.clone() {
                // get sound length
                // let mut length = 0u32;
                // FMOD_Sound_GetLength(noise.fmod_sound, &mut length, FMOD_TIMEUNIT_PCM);

                // set loop points for sound
                FMOD_Sound_SetLoopCount(noise.fmod_sound, i32::MAX);
                // FMOD_Sound_SetLoopPoints(
                //     noise.fmod_sound,
                //     0,
                //     FMOD_TIMEUNIT_PCM,
                //     length,
                //     FMOD_TIMEUNIT_PCM,
                // );

                // play the sound
                FMOD_System_PlaySound(
                    self.system,
                    noise.fmod_sound,
                    std::ptr::null_mut(),
                    0,
                    fmodn,
                );

                // update channel
                FMOD_Channel_SetVolume(*fmodn, self.conf.noise_volume);
                // FMOD_Channel_SetLoopPoints(*fmodn, 0, FMOD_TIMEUNIT_PCM, 1024, FMOD_TIMEUNIT_PCM);
                FMOD_Channel_SetLoopCount(*fmodn, i32::MAX);
                FMOD_Channel_SetPitch(*fmodn, self.conf.noise_speedhack as f32);
                FMOD_System_Update(self.system);
            }
        };
        */

        stop_kittyaudio_noise(&mut self.noise_sound);
        // stop_fmod_noise(&mut self.fmod_noise_sound);

        if self.conf.play_noise && (self.conf.enabled || self.conf.play_noise_when_disabled) {
            if self.conf.use_fmod {
                // start_fmod_noise(&mut self.fmod_noise_sound);
            } else {
                start_kittyaudio_noise(&mut self.noise_sound);
            }
        }
    }

    fn open_noise_toggle_toast(&self) {
        self.toasts.lock().add(Toast::info(if self.conf.play_noise {
            "Playing noise"
        } else {
            "Stopped playing noise"
        }));
    }

    #[inline]
    fn is_loading_clickpack(&self) -> bool {
        self.is_loading_clickpack.load(Ordering::Relaxed)
    }

    fn show_audio_window(&mut self, ui: &mut egui::Ui) {
        // Simple Noise Settings
        ui.group(|ui| {
            ui.label("Noise Settings");
            ui.add_enabled_ui(
                self.clickpack.has_noise() && !self.is_loading_clickpack(),
                |ui| {
                    if ui.checkbox(&mut self.conf.play_noise, "Play noise").clicked() {
                        self.play_noise();
                        self.open_noise_toggle_toast();
                    }
                    ui.add_enabled_ui(self.conf.play_noise, |ui| {
                        ui.add(
                            egui::Slider::new(&mut self.conf.noise_volume, 0.0..=1.0)
                                .text("Volume")
                                .step_by(0.01),
                        );
                    });
                },
            );
        });

        ui.separator();

        // Simple Audio Device Settings
        ui.group(|ui| {
            ui.label("Audio Device");
            let devices = self.devices.lock();
            egui::ComboBox::from_label("Select Device")
                .selected_text(&self.env.selected_device)
                .show_ui(ui, |ui| {
                    for device in devices.iter() {
                        ui.selectable_value(&mut self.env.selected_device, device.clone(), device);
                    }
                });
        });

        ui.separator();

        // Simple Timing Settings
        ui.group(|ui| {
            ui.label("Timing Settings");

            ui.checkbox(&mut self.conf.use_ingame_time, "Use in-game time");

            // Timing Mode
            egui::ComboBox::from_label("Timing Mode")
                .selected_text(self.conf.timing_mode.text())
                .show_ui(ui, |ui| {
                    ui.selectable_value(&mut self.conf.timing_mode, TimingMode::Responsive, "Responsive");
                    ui.selectable_value(&mut self.conf.timing_mode, TimingMode::Synchronized, "Synchronized");
                    ui.selectable_value(&mut self.conf.timing_mode, TimingMode::Hybrid, "Hybrid");
                });

            ui.checkbox(&mut self.conf.instant_audio_response, "Instant Audio Response");

            ui.add(
                egui::Slider::new(&mut self.conf.input_latency_compensation, -0.1..=0.1)
                    .text("Input Latency Compensation")
                    .step_by(0.001)
                    .suffix("s"),
            );
        });

        ui.separator();

        // Enhanced Recording Sync (Simple)
        ui.group(|ui| {
            ui.label("Enhanced Recording Sync");
            ui.add_enabled_ui(self.conf.use_ingame_time, |ui| {
                ui.checkbox(&mut self.conf.enhanced_recording_sync, "Enable Enhanced Recording Sync");

                if self.conf.enhanced_recording_sync {
                    ui.add(
                        egui::Slider::new(&mut self.conf.time_smoothing_factor, 0.0..=1.0)
                            .text("Time Smoothing")
                            .step_by(0.01),
                    );
                    ui.add(
                        egui::Slider::new(&mut self.conf.pause_detection_threshold, 0.01..=1.0)
                            .text("Pause Detection Threshold")
                            .step_by(0.01)
                            .suffix("s"),
                    );
                }
            });
        });

        ui.separator();

        // FPS-Based Sync (Simple)
        ui.group(|ui| {
            ui.label("FPS-Based Sync");
            ui.checkbox(&mut self.conf.fps_sync_enabled, "Enable FPS Sync");

            if self.conf.fps_sync_enabled {
                ui.add(
                    egui::Slider::new(&mut self.conf.target_fps, 30.0..=240.0)
                        .text("Target FPS")
                        .step_by(1.0)
                        .suffix(" FPS"),
                );
                ui.label(format!("Current FPS: {:.1}", self.current_fps));

                ui.add(
                    egui::Slider::new(&mut self.conf.fps_compensation_factor, 0.0..=2.0)
                        .text("Compensation Factor")
                        .step_by(0.1),
                );

                ui.checkbox(&mut self.conf.frame_time_smoothing, "Frame Time Smoothing");
                ui.checkbox(&mut self.conf.advanced_sync_features, "Advanced Sync Features");
            }
        });

        ui.separator();

        // Audio Pause Mode
        ui.group(|ui| {
            ui.label("Audio Pause Mode");
            ui.checkbox(&mut self.conf.allow_audio_finish_on_pause, "Allow Audio Finish on Pause");
        });

        ui.separator();

        // Configuration Management
        ui.group(|ui| {
            ui.label("Configuration");
            ui.horizontal(|ui| {
                if ui.button("Save").clicked() {
                    self.conf.save();
                    self.toasts.lock().add(Toast::success("Configuration saved"));
                }
                if ui.button("Load").clicked() {
                    if let Ok(conf) = Config::load() {
                        self.conf = conf.fixup();
                        self.toasts.lock().add(Toast::success("Configuration loaded"));
                    }
                }
                if ui.button("Reset").clicked() {
                    self.conf = Config::default().fixup();
                    self.toasts.lock().add(Toast::success("Configuration reset to defaults"));
                }
            });
        });
    }

    fn show_options_window_continued(&mut self, ui: &mut egui::Ui) {
        ui.collapsing("Pitch variation", |ui| {
            ui.label(
                "Pitch variation can make clicks sound more realistic by \
                    changing their pitch randomly.",
            );
            ui.checkbox(&mut self.conf.pitch_enabled, "Enable pitch variation");
            ui.add_enabled_ui(self.conf.pitch_enabled, |ui| {
                let p = &mut self.conf.pitch;
                drag_value(
                    ui,
                    &mut p.from,
                    "Minimum pitch",
                    0.0..=p.to,
                    "Minimum pitch value, 1.0 means no change",
                );
                drag_value(
                    ui,
                    &mut p.to,
                    "Maximum pitch",
                    p.from..=f64::INFINITY,
                    "Maximum pitch value, 1.0 means no change",
                );
            });
        });

        ui.collapsing("Volume settings", |ui| {
            help_text(
                ui,
                "Cut overlapping click sounds,\n\
                changes the sound significantly in spams",
                |ui| ui.checkbox(&mut self.conf.cut_sounds, "Cut sounds"),
            );
            if self.conf.cut_sounds {
                help_text(ui, "Allow clicks to be cut by releases", |ui| {
                    ui.checkbox(&mut self.conf.cut_by_releases, "Cut by releases")
                });
            }
            let vol = &mut self.conf.volume_settings;
            drag_value(
                ui,
                &mut vol.global_volume,
                "Global volume",
                0.0..=f64::INFINITY,
                "Constant volume multiplier for all sounds",
            );
            drag_value(
                ui,
                &mut vol.volume_var,
                "Volume variation",
                0.0..=f64::INFINITY,
                "Random volume variation (+/-)",
            );
            drag_value(
                ui,
                &mut vol.platformer_volume_factor,
                "Platformer volume factor",
                f64::NEG_INFINITY..=f64::INFINITY,
                "Multiplier of the platformer sound volume. If this is 0.5, \
                platformer sounds will be played at half volume",
            );
        });

        ui.collapsing("Spam volume changes", |ui| {
            .stroke(egui::Stroke::new(1.0, egui::Color32::from_rgba_premultiplied(255, 255, 255, 20)))
            .show(ui, |ui| {
                ui.horizontal(|ui| {
                    // Modern icon with glow effect
                    let icon_rect = ui.allocate_exact_size(egui::Vec2::splat(28.0), egui::Sense::hover()).0;
                    ui.painter().circle_filled(
                        icon_rect.center(),
                        14.0,
                        egui::Color32::from_rgba_premultiplied(255, 165, 0, 40)
                    );
                    ui.painter().text(
                        icon_rect.center(),
                        egui::Align2::CENTER_CENTER,
                        "🔊",
                        egui::FontId::proportional(16.0),
                        egui::Color32::WHITE,
                    );

                    ui.add_space(12.0);
                    ui.vertical(|ui| {
                        ui.label(egui::RichText::new("Noise Settings").size(18.0).strong().color(egui::Color32::WHITE));
                        ui.label(egui::RichText::new("Configure ambient audio feedback").size(12.0).color(egui::Color32::from_gray(180)));
                    });
                });
                ui.add_space(16.0);

                ui.add_enabled_ui(
                    self.clickpack.has_noise() && !self.is_loading_clickpack(),
                    |ui| {
                        ui.horizontal(|ui| {
                            // Enhanced toggle for noise with modern styling
                            let toggle_size = egui::Vec2::new(40.0, 22.0);
                            let (rect, response) = ui.allocate_exact_size(toggle_size, egui::Sense::click());

                            if response.clicked() {
                                self.conf.play_noise = !self.conf.play_noise;
                                self.play_noise();
                                self.open_noise_toggle_toast();
                            }

                            // Enhanced toggle background
                            let rounding = egui::Rounding::same(11.0);
                            let bg_color = if self.conf.play_noise {
                                egui::Color32::from_rgb(34, 197, 94)
                            } else {
                                egui::Color32::from_gray(60)
                            };

                            // Add subtle shadow
                            let shadow_rect = rect.translate(egui::Vec2::new(0.0, 1.0));
                            ui.painter().rect_filled(shadow_rect, rounding, egui::Color32::from_black_alpha(20));
                            ui.painter().rect_filled(rect, rounding, bg_color);

                            // Enhanced knob with shadow
                            let knob_size = 16.0;
                            let knob_margin = 3.0;
                            let knob_offset = if self.conf.play_noise {
                                rect.right() - knob_size - knob_margin
                            } else {
                                rect.left() + knob_margin
                            };

                            let knob_center = egui::Pos2::new(knob_offset + knob_size/2.0, rect.center().y);

                            // Knob shadow
                            ui.painter().circle_filled(
                                knob_center + egui::Vec2::new(0.0, 1.0),
                                knob_size/2.0,
                                egui::Color32::from_black_alpha(30)
                            );

                            // Knob
                            ui.painter().circle_filled(
                                knob_center,
                                knob_size/2.0,
                                egui::Color32::WHITE
                            );

                            ui.add_space(12.0);
                            ui.vertical(|ui| {
                                ui.label(
                                    egui::RichText::new("Play Noise")
                                        .size(14.0)
                                        .strong()
                                        .color(if self.conf.play_noise { egui::Color32::WHITE } else { egui::Color32::from_gray(160) })
                                );
                                ui.label(
                                    egui::RichText::new("Background audio from clickpack")
                                        .size(10.0)
                                        .color(egui::Color32::from_gray(140))
                                );
                            });
                        });

                        if self.conf.play_noise {
                            ui.add_space(8.0);
                            ui.horizontal(|ui| {
                                ui.label("Volume:");
                                ui.add_space(4.0);
                                if drag_value(
                                    ui,
                                    &mut self.conf.noise_volume,
                                    "",
                                    0.0..=f64::INFINITY,
                                    "",
                                )
                                .drag_stopped()
                                {
                                    self.play_noise(); // restart noise
                                }
                            });
                        }
                    },
                );

                if !self.clickpack.has_noise() {
                    ui.add_space(8.0);
                    ui.horizontal(|ui| {
                        ui.label("⚠️");
                        ui.label(egui::RichText::new("No noise file in current clickpack").color(egui::Color32::from_rgb(255, 200, 100)));
                    });
                }
            });

        ui.add_space(12.0);

        /*
        help_text(
            ui,
            "Use the internal audio engine for integration with internal recorders",
            |ui| {
                if ui.checkbox(&mut self.conf.use_fmod, "Use FMOD").changed() {
                    if self.conf.use_fmod {
                        log::info!("destroying kittyaudio mixer");
                        self.mixer = Mixer::new();
                    } else {
                        self.maybe_init_kittyaudio();
                    }
                    self.play_noise();
                }
            },
        );
        */
        // Ultra-modern Audio Device Section with glassmorphism
        egui::Frame::none()
            .fill(egui::Color32::from_rgba_premultiplied(25, 30, 40, 160))
            .rounding(egui::Rounding::same(16.0))
            .inner_margin(egui::Margin::same(20.0))
            .stroke(egui::Stroke::new(1.0, egui::Color32::from_rgba_premultiplied(255, 255, 255, 20)))
            .show(ui, |ui| {
                ui.horizontal(|ui| {
                    // Modern icon with glow effect
                    let icon_rect = ui.allocate_exact_size(egui::Vec2::splat(28.0), egui::Sense::hover()).0;
                    ui.painter().circle_filled(
                        icon_rect.center(),
                        14.0,
                        egui::Color32::from_rgba_premultiplied(147, 51, 234, 40)
                    );
                    ui.painter().text(
                        icon_rect.center(),
                        egui::Align2::CENTER_CENTER,
                        "🎧",
                        egui::FontId::proportional(16.0),
                        egui::Color32::WHITE,
                    );

                    ui.add_space(12.0);
                    ui.vertical(|ui| {
                        ui.label(egui::RichText::new("Audio Device").size(18.0).strong().color(egui::Color32::WHITE));
                        ui.label(egui::RichText::new("Select your preferred output device").size(12.0).color(egui::Color32::from_gray(180)));
                    });
                });
                ui.add_space(16.0);
                ui.add_enabled_ui(!self.conf.use_fmod, |ui| self.show_device_switcher(ui));
            });

        ui.add_space(20.0);

        // Ultra-modern Timing Settings Section with glassmorphism
        egui::Frame::none()
            .fill(egui::Color32::from_rgba_premultiplied(25, 30, 40, 160))
            .rounding(egui::Rounding::same(16.0))
            .inner_margin(egui::Margin::same(20.0))
            .stroke(egui::Stroke::new(1.0, egui::Color32::from_rgba_premultiplied(255, 255, 255, 20)))
            .show(ui, |ui| {
                ui.horizontal(|ui| {
                    // Modern icon with glow effect
                    let icon_rect = ui.allocate_exact_size(egui::Vec2::splat(28.0), egui::Sense::hover()).0;
                    ui.painter().circle_filled(
                        icon_rect.center(),
                        14.0,
                        egui::Color32::from_rgba_premultiplied(59, 130, 246, 40)
                    );
                    ui.painter().text(
                        icon_rect.center(),
                        egui::Align2::CENTER_CENTER,
                        "⏱️",
                        egui::FontId::proportional(16.0),
                        egui::Color32::WHITE,
                    );

                    ui.add_space(12.0);
                    ui.vertical(|ui| {
                        ui.label(egui::RichText::new("Timing Settings").size(18.0).strong().color(egui::Color32::WHITE));
                        ui.label(egui::RichText::new("Precision audio timing controls").size(12.0).color(egui::Color32::from_gray(180)));
                    });

                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                        // Modern help button with glow
                        let help_size = egui::Vec2::splat(24.0);
                        let (help_rect, help_response) = ui.allocate_exact_size(help_size, egui::Sense::click());

                        if help_response.hovered() {
                            ui.painter().circle_filled(
                                help_rect.center(),
                                12.0,
                                egui::Color32::from_rgba_premultiplied(59, 130, 246, 40)
                            );
                        }

                        ui.painter().circle_filled(
                            help_rect.center(),
                            10.0,
                            egui::Color32::from_rgba_premultiplied(59, 130, 246, 180)
                        );

                        ui.painter().text(
                            help_rect.center(),
                            egui::Align2::CENTER_CENTER,
                            "ℹ️",
                            egui::FontId::proportional(12.0),
                            egui::Color32::WHITE,
                        );

                        if help_response.clicked() {
                            // Could show help dialog
                        }

                        help_response.on_hover_text("Timing configuration help");
                    });
                });
                ui.add_space(16.0);

                self.show_timing_controls(ui);
            });

        ui.add_space(12.0);
    }

    fn show_timing_controls(&mut self, ui: &mut egui::Ui) {
        // Enhanced timing mode selector with modern design
        ui.vertical(|ui| {
            ui.label(egui::RichText::new("Timing Mode").size(15.0).strong().color(egui::Color32::WHITE));
            ui.add_space(8.0);

            // Modern timing mode cards
            ui.horizontal(|ui| {
                for (mode, title, desc, color) in [
                    (TimingMode::Responsive, "Responsive", "Live Play", egui::Color32::from_rgb(34, 197, 94)),
                    (TimingMode::Hybrid, "Hybrid", "Balanced", egui::Color32::from_rgb(100, 150, 255)),
                    (TimingMode::Synchronized, "Synchronized", "Recording", egui::Color32::from_rgb(147, 51, 234)),
                ] {
                    let selected = self.conf.timing_mode == mode;
                    let card_size = egui::Vec2::new(100.0, 60.0);
                    let (card_rect, card_response) = ui.allocate_exact_size(card_size, egui::Sense::click());

                    if card_response.clicked() {
                        self.conf.timing_mode = mode;
                    }

                    // Card background with selection state
                    let bg_color = if selected {
                        color
                    } else if card_response.hovered() {
                        egui::Color32::from_rgba_premultiplied(color.r(), color.g(), color.b(), 60)
                    } else {
                        egui::Color32::from_rgba_premultiplied(40, 45, 55, 180)
                    };

                    ui.painter().rect_filled(card_rect, egui::Rounding::same(8.0), bg_color);

                    if selected {
                        ui.painter().rect_stroke(
                            card_rect,
                            egui::Rounding::same(8.0),
                            egui::Stroke::new(2.0, egui::Color32::WHITE)
                        );
                    }

                    // Card content
                    let text_color = if selected { egui::Color32::WHITE } else { egui::Color32::from_gray(200) };
                    ui.painter().text(
                        card_rect.center() - egui::Vec2::new(0.0, 8.0),
                        egui::Align2::CENTER_CENTER,
                        title,
                        egui::FontId::proportional(12.0),
                        text_color,
                    );
                    ui.painter().text(
                        card_rect.center() + egui::Vec2::new(0.0, 8.0),
                        egui::Align2::CENTER_CENTER,
                        desc,
                        egui::FontId::proportional(10.0),
                        if selected { egui::Color32::from_gray(220) } else { egui::Color32::from_gray(160) },
                    );

                    ui.add_space(4.0);
                }
            });
        });

        ui.add_space(16.0);

        // Enhanced in-game time toggle with modern design
        ui.horizontal(|ui| {
            let toggle_size = egui::Vec2::new(40.0, 22.0);
            let (rect, response) = ui.allocate_exact_size(toggle_size, egui::Sense::click());

            if response.clicked() {
                self.conf.use_ingame_time = !self.conf.use_ingame_time;
            }

            // Enhanced toggle background
            let rounding = egui::Rounding::same(11.0);
            let bg_color = if self.conf.use_ingame_time {
                egui::Color32::from_rgb(34, 197, 94)
            } else {
                egui::Color32::from_gray(60)
            };

            // Add subtle shadow
            let shadow_rect = rect.translate(egui::Vec2::new(0.0, 1.0));
            ui.painter().rect_filled(shadow_rect, rounding, egui::Color32::from_black_alpha(20));
            ui.painter().rect_filled(rect, rounding, bg_color);

            // Enhanced knob with shadow
            let knob_size = 16.0;
            let knob_margin = 3.0;
            let knob_offset = if self.conf.use_ingame_time {
                rect.right() - knob_size - knob_margin
            } else {
                rect.left() + knob_margin
            };

            let knob_center = egui::Pos2::new(knob_offset + knob_size/2.0, rect.center().y);

            // Knob shadow
            ui.painter().circle_filled(
                knob_center + egui::Vec2::new(0.0, 1.0),
                knob_size/2.0,
                egui::Color32::from_black_alpha(30)
            );

            // Knob
            ui.painter().circle_filled(
                knob_center,
                knob_size/2.0,
                egui::Color32::WHITE
            );

            ui.add_space(12.0);
            ui.vertical(|ui| {
                ui.label(
                    egui::RichText::new("Use In-Game Time")
                        .size(14.0)
                        .strong()
                        .color(if self.conf.use_ingame_time { egui::Color32::WHITE } else { egui::Color32::from_gray(160) })
                );
                ui.label(
                    egui::RichText::new("Better for practice mode & speedhack")
                        .size(10.0)
                        .color(egui::Color32::from_gray(140))
                );
            });
        });

            // Store the value to avoid borrowing issues
            let use_ingame_time = self.conf.use_ingame_time;

        // Enhanced recording synchronization section
        ui.add_enabled_ui(use_ingame_time, |ui| {
            ui.add_space(12.0);

            // Enhanced Recording Sync toggle with modern styling
            ui.horizontal(|ui| {
                let toggle_size = egui::Vec2::new(40.0, 22.0);
                let (rect, response) = ui.allocate_exact_size(toggle_size, egui::Sense::click());

                if response.clicked() {
                    self.conf.enhanced_recording_sync = !self.conf.enhanced_recording_sync;
                }

                // Enhanced toggle background
                let rounding = egui::Rounding::same(11.0);
                let bg_color = if self.conf.enhanced_recording_sync {
                    egui::Color32::from_rgb(34, 197, 94)
                } else {
                    egui::Color32::from_gray(60)
                };

                // Add subtle shadow
                let shadow_rect = rect.translate(egui::Vec2::new(0.0, 1.0));
                ui.painter().rect_filled(shadow_rect, rounding, egui::Color32::from_black_alpha(20));
                ui.painter().rect_filled(rect, rounding, bg_color);

                // Enhanced knob with shadow
                let knob_size = 16.0;
                let knob_margin = 3.0;
                let knob_offset = if self.conf.enhanced_recording_sync {
                    rect.right() - knob_size - knob_margin
                } else {
                    rect.left() + knob_margin
                };

                let knob_center = egui::Pos2::new(knob_offset + knob_size/2.0, rect.center().y);

                // Knob shadow
                ui.painter().circle_filled(
                    knob_center + egui::Vec2::new(0.0, 1.0),
                    knob_size/2.0,
                    egui::Color32::from_black_alpha(30)
                );

                // Knob
                ui.painter().circle_filled(
                    knob_center,
                    knob_size/2.0,
                    egui::Color32::WHITE
                );

                ui.add_space(12.0);
                ui.vertical(|ui| {
                    ui.label(
                        egui::RichText::new("Enhanced Recording Sync")
                            .size(14.0)
                            .strong()
                            .color(if self.conf.enhanced_recording_sync { egui::Color32::WHITE } else { egui::Color32::from_gray(160) })
                    );
                    ui.label(
                        egui::RichText::new("Reduces audio desync in recordings")
                            .size(10.0)
                            .color(egui::Color32::from_gray(140))
                    );
                });
            });

            if self.conf.enhanced_recording_sync {
                ui.add_space(12.0);

                // Enhanced advanced timing controls in a modern sub-frame
                egui::Frame::none()
                    .fill(egui::Color32::from_gray(16))
                    .rounding(egui::Rounding::same(8.0))
                    .inner_margin(egui::Margin::same(14.0))
                    .stroke(egui::Stroke::new(1.0, egui::Color32::from_gray(35)))
                    .show(ui, |ui| {
                        ui.horizontal(|ui| {
                            ui.label(egui::RichText::new("⚙️").size(16.0));
                            ui.add_space(6.0);
                            ui.label(egui::RichText::new("Advanced Timing Controls").size(14.0).strong().color(egui::Color32::WHITE));
                        });
                        ui.add_space(12.0);

                        // Enhanced Time Smoothing control
                        egui::Frame::none()
                            .fill(egui::Color32::from_gray(20))
                            .rounding(egui::Rounding::same(6.0))
                            .inner_margin(egui::Margin::same(10.0))
                            .show(ui, |ui| {
                                ui.horizontal(|ui| {
                                    ui.vertical(|ui| {
                                        ui.label(egui::RichText::new("Time Smoothing").size(12.0).strong());
                                        ui.label(egui::RichText::new("Reduces timing jitter").size(10.0).color(egui::Color32::from_gray(140)));
                                    });
                                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                        if ui.add(
                                            egui::Button::new("?")
                                                .fill(egui::Color32::from_gray(40))
                                                .rounding(egui::Rounding::same(4.0))
                                                .min_size(egui::Vec2::new(20.0, 20.0))
                                        ).on_hover_text("0.0 = no smoothing, 1.0 = maximum smoothing\nHigher values provide more stable timing but may feel less responsive").clicked() {
                                            // Help button clicked - could show detailed help dialog
                                        }
                                        ui.add_space(8.0);
                                        ui.add(
                                            egui::Slider::new(&mut self.conf.time_smoothing_factor, 0.0..=1.0)
                                                .step_by(0.01)
                                                .show_value(true)
                                        );
                                    });
                                });
                            });

                        ui.add_space(8.0);

                        // Enhanced Pause Detection control
                        egui::Frame::none()
                            .fill(egui::Color32::from_gray(20))
                            .rounding(egui::Rounding::same(6.0))
                            .inner_margin(egui::Margin::same(10.0))
                            .show(ui, |ui| {
                                ui.horizontal(|ui| {
                                    ui.vertical(|ui| {
                                        ui.label(egui::RichText::new("Pause Detection").size(12.0).strong());
                                        ui.label(egui::RichText::new("Threshold in seconds").size(10.0).color(egui::Color32::from_gray(140)));
                                    });
                                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                        if ui.add(
                                            egui::Button::new("?")
                                                .fill(egui::Color32::from_gray(40))
                                                .rounding(egui::Rounding::same(4.0))
                                                .min_size(egui::Vec2::new(20.0, 20.0))
                                        ).on_hover_text("Threshold for detecting game pauses\nLower values detect shorter pauses but may cause false positives").clicked() {
                                            // Help button clicked - could show detailed help dialog
                                        }
                                        ui.add_space(8.0);
                                        ui.add(
                                            egui::Slider::new(&mut self.conf.pause_detection_threshold, 0.01..=1.0)
                                                .step_by(0.01)
                                                .show_value(true)
                                                .suffix("s")
                                        );
                                    });
                                });
                            });
                    });
            }
        });

        ui.add_space(16.0);

        // FPS-Based Sync Controls
        egui::Frame::none()
            .fill(egui::Color32::from_rgba_premultiplied(25, 40, 35, 160))
            .rounding(egui::Rounding::same(12.0))
            .inner_margin(egui::Margin::same(16.0))
            .stroke(egui::Stroke::new(1.0, egui::Color32::from_rgba_premultiplied(34, 197, 94, 30)))
            .show(ui, |ui| {
                ui.horizontal(|ui| {
                    ui.label(egui::RichText::new("📊").size(18.0));
                    ui.add_space(8.0);
                    ui.label(egui::RichText::new("FPS-Based Sync").size(16.0).strong().color(egui::Color32::WHITE));
                });
                ui.add_space(12.0);

                // FPS Sync Enable toggle
                ui.horizontal(|ui| {
                    let toggle_size = egui::Vec2::new(44.0, 24.0);
                    let (rect, response) = ui.allocate_exact_size(toggle_size, egui::Sense::click());

                    if response.clicked() {
                        self.conf.fps_sync_enabled = !self.conf.fps_sync_enabled;
                    }

                    // Enhanced toggle background with FPS theme
                    let rounding = egui::Rounding::same(12.0);
                    let bg_color = if self.conf.fps_sync_enabled {
                        egui::Color32::from_rgb(34, 197, 94)
                    } else {
                        egui::Color32::from_gray(60)
                    };

                    ui.painter().rect_filled(rect, rounding, bg_color);

                    // Toggle knob with glow effect
                    let knob_radius = 9.0;
                    let knob_x = if self.conf.fps_sync_enabled {
                        rect.right() - knob_radius - 3.0
                    } else {
                        rect.left() + knob_radius + 3.0
                    };
                    let knob_center = egui::Pos2::new(knob_x, rect.center().y);

                    // Glow effect
                    if self.conf.fps_sync_enabled {
                        ui.painter().circle_filled(knob_center, knob_radius + 2.0, egui::Color32::from_rgba_premultiplied(34, 197, 94, 40));
                    }

                    // Main knob
                    ui.painter().circle_filled(knob_center, knob_radius, egui::Color32::WHITE);

                    ui.add_space(12.0);
                    ui.vertical(|ui| {
                        ui.label(
                            egui::RichText::new("FPS Sync")
                                .size(14.0)
                                .strong()
                                .color(if self.conf.fps_sync_enabled { egui::Color32::WHITE } else { egui::Color32::from_gray(160) })
                        );
                        ui.label(
                            egui::RichText::new("Sync audio timing with frame rate")
                                .size(10.0)
                                .color(egui::Color32::from_gray(140))
                        );
                    });
                });

                if self.conf.fps_sync_enabled {
                    ui.add_space(12.0);

                    // FPS sync controls in a sub-frame
                    egui::Frame::none()
                        .fill(egui::Color32::from_gray(16))
                        .rounding(egui::Rounding::same(8.0))
                        .inner_margin(egui::Margin::same(14.0))
                        .stroke(egui::Stroke::new(1.0, egui::Color32::from_gray(35)))
                        .show(ui, |ui| {
                            ui.horizontal(|ui| {
                                ui.label(egui::RichText::new("🎯").size(16.0));
                                ui.add_space(6.0);
                                ui.label(egui::RichText::new("FPS Sync Settings").size(14.0).strong().color(egui::Color32::WHITE));
                            });
                            ui.add_space(12.0);

                            // Target FPS control
                            egui::Frame::none()
                                .fill(egui::Color32::from_gray(20))
                                .rounding(egui::Rounding::same(6.0))
                                .inner_margin(egui::Margin::same(10.0))
                                .show(ui, |ui| {
                                    ui.horizontal(|ui| {
                                        ui.vertical(|ui| {
                                            ui.label(egui::RichText::new("Target FPS").size(12.0).strong());
                                            ui.label(egui::RichText::new(format!("Current: {:.1}", self.current_fps)).size(10.0).color(egui::Color32::from_gray(140)));
                                        });
                                        ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                            ui.add(
                                                egui::Slider::new(&mut self.conf.target_fps, 30.0..=240.0)
                                                    .step_by(1.0)
                                                    .show_value(true)
                                                    .suffix(" FPS")
                                            );
                                        });
                                    });
                                });

                            ui.add_space(8.0);

                            // FPS Compensation Factor control
                            egui::Frame::none()
                                .fill(egui::Color32::from_gray(20))
                                .rounding(egui::Rounding::same(6.0))
                                .inner_margin(egui::Margin::same(10.0))
                                .show(ui, |ui| {
                                    ui.horizontal(|ui| {
                                        ui.vertical(|ui| {
                                            ui.label(egui::RichText::new("Compensation Factor").size(12.0).strong());
                                            ui.label(egui::RichText::new("Strength of FPS compensation").size(10.0).color(egui::Color32::from_gray(140)));
                                        });
                                        ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                            ui.add(
                                                egui::Slider::new(&mut self.conf.fps_compensation_factor, 0.0..=2.0)
                                                    .step_by(0.1)
                                                    .show_value(true)
                                            );
                                        });
                                    });
                                });

                            ui.add_space(8.0);

                            // Advanced FPS features
                            ui.horizontal(|ui| {
                                // Frame Time Smoothing toggle
                                let toggle_size = egui::Vec2::new(32.0, 18.0);
                                let (rect, response) = ui.allocate_exact_size(toggle_size, egui::Sense::click());

                                if response.clicked() {
                                    self.conf.frame_time_smoothing = !self.conf.frame_time_smoothing;
                                }

                                let bg_color = if self.conf.frame_time_smoothing {
                                    egui::Color32::from_rgb(34, 197, 94)
                                } else {
                                    egui::Color32::from_gray(50)
                                };

                                ui.painter().rect_filled(rect, egui::Rounding::same(9.0), bg_color);

                                let knob_radius = 6.0;
                                let knob_x = if self.conf.frame_time_smoothing {
                                    rect.right() - knob_radius - 2.0
                                } else {
                                    rect.left() + knob_radius + 2.0
                                };
                                let knob_center = egui::Pos2::new(knob_x, rect.center().y);
                                ui.painter().circle_filled(knob_center, knob_radius, egui::Color32::WHITE);

                                ui.add_space(8.0);
                                ui.label(egui::RichText::new("Frame Time Smoothing").size(12.0));

                                ui.add_space(16.0);

                                // Advanced Sync Features toggle
                                let (rect, response) = ui.allocate_exact_size(toggle_size, egui::Sense::click());

                                if response.clicked() {
                                    self.conf.advanced_sync_features = !self.conf.advanced_sync_features;
                                }

                                let bg_color = if self.conf.advanced_sync_features {
                                    egui::Color32::from_rgb(147, 51, 234)
                                } else {
                                    egui::Color32::from_gray(50)
                                };

                                ui.painter().rect_filled(rect, egui::Rounding::same(9.0), bg_color);

                                let knob_x = if self.conf.advanced_sync_features {
                                    rect.right() - knob_radius - 2.0
                                } else {
                                    rect.left() + knob_radius + 2.0
                                };
                                let knob_center = egui::Pos2::new(knob_x, rect.center().y);
                                ui.painter().circle_filled(knob_center, knob_radius, egui::Color32::WHITE);

                                ui.add_space(8.0);
                                ui.label(egui::RichText::new("Advanced Sync").size(12.0));
                            });
                        });
                }
            });

        ui.add_space(16.0);

        // Enhanced Audio Pause Mode Controls
        egui::Frame::none()
            .fill(egui::Color32::from_rgba_premultiplied(30, 35, 45, 160))
            .rounding(egui::Rounding::same(12.0))
            .inner_margin(egui::Margin::same(16.0))
            .stroke(egui::Stroke::new(1.0, egui::Color32::from_rgba_premultiplied(255, 255, 255, 15)))
            .show(ui, |ui| {
                ui.horizontal(|ui| {
                    ui.label(egui::RichText::new("⏸️").size(18.0));
                    ui.add_space(8.0);
                    ui.label(egui::RichText::new("Audio Pause Mode").size(16.0).strong().color(egui::Color32::WHITE));
                });
                ui.add_space(12.0);

                // Allow Audio Finish on Pause toggle
                ui.horizontal(|ui| {
                    let toggle_size = egui::Vec2::new(44.0, 24.0);
                    let (rect, response) = ui.allocate_exact_size(toggle_size, egui::Sense::click());

                    if response.clicked() {
                        self.conf.allow_audio_finish_on_pause = !self.conf.allow_audio_finish_on_pause;
                    }

                    // Modern toggle with glow
                    let rounding = egui::Rounding::same(12.0);
                    let (bg_color, glow_color) = if self.conf.allow_audio_finish_on_pause {
                        (egui::Color32::from_rgb(16, 185, 129), egui::Color32::from_rgba_premultiplied(16, 185, 129, 40))
                    } else {
                        (egui::Color32::from_rgba_premultiplied(75, 85, 99, 180), egui::Color32::TRANSPARENT)
                    };

                    if self.conf.allow_audio_finish_on_pause {
                        ui.painter().rect_filled(rect.expand(2.0), rounding, glow_color);
                    }

                    ui.painter().rect_filled(rect, rounding, bg_color);

                    // Floating knob
                    let knob_size = 18.0;
                    let knob_margin = 3.0;
                    let knob_travel = rect.width() - knob_size - (knob_margin * 2.0);
                    let progress = if self.conf.allow_audio_finish_on_pause { 1.0 } else { 0.0 };
                    let knob_x = rect.left() + knob_margin + (knob_travel * progress);
                    let knob_center = egui::Pos2::new(knob_x + knob_size/2.0, rect.center().y);

                    ui.painter().circle_filled(knob_center, knob_size/2.0, egui::Color32::WHITE);

                    ui.add_space(16.0);
                    ui.vertical(|ui| {
                        ui.label(
                            egui::RichText::new("Allow Audio Finish on Pause")
                                .size(14.0)
                                .strong()
                                .color(if self.conf.allow_audio_finish_on_pause { egui::Color32::from_rgb(16, 185, 129) } else { egui::Color32::from_gray(180) })
                        );
                        ui.label(
                            egui::RichText::new(if self.conf.allow_audio_finish_on_pause { "Sounds continue during pause" } else { "Sounds stop immediately on pause" })
                                .size(11.0)
                                .color(egui::Color32::from_gray(160))
                        );
                    });
                });

                ui.add_space(12.0);

                // Audio System Recovery toggle
                ui.horizontal(|ui| {
                    let toggle_size = egui::Vec2::new(44.0, 24.0);
                    let (rect, response) = ui.allocate_exact_size(toggle_size, egui::Sense::click());

                    if response.clicked() {
                        self.conf.enable_audio_system_recovery = !self.conf.enable_audio_system_recovery;
                    }

                    // Modern toggle with glow
                    let rounding = egui::Rounding::same(12.0);
                    let (bg_color, glow_color) = if self.conf.enable_audio_system_recovery {
                        (egui::Color32::from_rgb(59, 130, 246), egui::Color32::from_rgba_premultiplied(59, 130, 246, 40))
                    } else {
                        (egui::Color32::from_rgba_premultiplied(75, 85, 99, 180), egui::Color32::TRANSPARENT)
                    };

                    if self.conf.enable_audio_system_recovery {
                        ui.painter().rect_filled(rect.expand(2.0), rounding, glow_color);
                    }

                    ui.painter().rect_filled(rect, rounding, bg_color);

                    // Floating knob
                    let knob_size = 18.0;
                    let knob_margin = 3.0;
                    let knob_travel = rect.width() - knob_size - (knob_margin * 2.0);
                    let progress = if self.conf.enable_audio_system_recovery { 1.0 } else { 0.0 };
                    let knob_x = rect.left() + knob_margin + (knob_travel * progress);
                    let knob_center = egui::Pos2::new(knob_x + knob_size/2.0, rect.center().y);

                    ui.painter().circle_filled(knob_center, knob_size/2.0, egui::Color32::WHITE);

                    ui.add_space(16.0);
                    ui.vertical(|ui| {
                        ui.label(
                            egui::RichText::new("Audio System Recovery")
                                .size(14.0)
                                .strong()
                                .color(if self.conf.enable_audio_system_recovery { egui::Color32::from_rgb(59, 130, 246) } else { egui::Color32::from_gray(180) })
                        );
                        ui.label(
                            egui::RichText::new(if self.conf.enable_audio_system_recovery { "Automatic recovery from audio issues" } else { "Basic audio handling" })
                                .size(11.0)
                                .color(egui::Color32::from_gray(160))
                        );
                    });
                });

                // Pause debounce settings (when audio system recovery is enabled)
                if self.conf.enable_audio_system_recovery {
                    ui.add_space(12.0);
                    ui.separator();
                    ui.add_space(8.0);

                    ui.label(egui::RichText::new("Advanced Pause Settings").size(13.0).strong().color(egui::Color32::WHITE));
                    ui.add_space(8.0);

                    // Pause debounce threshold
                    ui.horizontal(|ui| {
                        ui.label("Pause Debounce:");
                        ui.add(
                            egui::Slider::new(&mut self.conf.pause_debounce_threshold, 0.01..=1.0)
                                .step_by(0.01)
                                .show_value(true)
                                .suffix("s")
                        );
                    });

                    ui.add_space(4.0);

                    // Rapid pause threshold
                    ui.horizontal(|ui| {
                        ui.label("Rapid Pause Limit:");
                        ui.add(
                            egui::Slider::new(&mut self.conf.rapid_pause_threshold, 1..=20)
                                .show_value(true)
                                .suffix(" cycles")
                        );
                    });
                }
            });

        ui.add_space(16.0);

        // Enhanced Audio Preferences Section
        self.show_enhanced_audio_preferences(ui);

        // Add dual timing controls
        // self.show_dual_timing_controls(ui);

        // Add pause-aware audio controls
        // self.show_pause_aware_audio_controls(ui);

        // Add additional audio controls
        // self.show_additional_audio_controls(ui);
    }

    fn show_enhanced_audio_preferences(&mut self, ui: &mut egui::Ui) {
        egui::Frame::none()
            .fill(egui::Color32::from_rgba_premultiplied(25, 30, 40, 160))
            .rounding(egui::Rounding::same(16.0))
            .inner_margin(egui::Margin::same(20.0))
            .stroke(egui::Stroke::new(1.0, egui::Color32::from_rgba_premultiplied(255, 255, 255, 20)))
            .show(ui, |ui| {
                ui.horizontal(|ui| {
                    // Modern icon with glow effect
                    let icon_rect = ui.allocate_exact_size(egui::Vec2::splat(28.0), egui::Sense::hover()).0;
                    ui.painter().circle_filled(
                        icon_rect.center(),
                        14.0,
                        egui::Color32::from_rgba_premultiplied(236, 72, 153, 40)
                    );
                    ui.painter().text(
                        icon_rect.center(),
                        egui::Align2::CENTER_CENTER,
                        "🎛️",
                        egui::FontId::proportional(16.0),
                        egui::Color32::WHITE,
                    );

                    ui.add_space(12.0);
                    ui.vertical(|ui| {
                        ui.label(egui::RichText::new("Audio Preferences").size(18.0).strong().color(egui::Color32::WHITE));
                        ui.label(egui::RichText::new("Advanced audio customization options").size(12.0).color(egui::Color32::from_gray(180)));
                    });
                });

                ui.add_space(16.0);

                // Enhanced Volume Controls
                ui.vertical(|ui| {
                    ui.label(egui::RichText::new("Volume Controls").size(15.0).strong().color(egui::Color32::WHITE));
                    ui.add_space(8.0);

                    // Global Volume with modern slider
                    ui.horizontal(|ui| {
                        ui.label("Global Volume:");
                        ui.add_space(8.0);
                        ui.add(
                            egui::Slider::new(&mut self.conf.volume_settings.global_volume, 0.0..=2.0)
                                .step_by(0.01)
                                .show_value(true)
                                .suffix("×")
                        );
                    });

                    ui.add_space(6.0);

                    // Volume Variation
                    ui.horizontal(|ui| {
                        ui.label("Volume Variation:");
                        ui.add_space(8.0);
                        ui.add(
                            egui::Slider::new(&mut self.conf.volume_settings.volume_var, 0.0..=1.0)
                                .step_by(0.01)
                                .show_value(true)
                                .suffix("±")
                        );
                    });

                    ui.add_space(6.0);

                    // Platformer Volume Factor
                    ui.horizontal(|ui| {
                        ui.label("Platformer Volume:");
                        ui.add_space(8.0);
                        ui.add(
                            egui::Slider::new(&mut self.conf.volume_settings.platformer_volume_factor, 0.0..=2.0)
                                .step_by(0.01)
                                .show_value(true)
                                .suffix("×")
                        );
                    });
                });

                ui.add_space(16.0);

                // Enhanced Audio Behavior Options
                ui.vertical(|ui| {
                    ui.label(egui::RichText::new("Audio Behavior").size(15.0).strong().color(egui::Color32::WHITE));
                    ui.add_space(8.0);

                    // Instant Audio Response toggle
                    ui.horizontal(|ui| {
                        let toggle_size = egui::Vec2::new(44.0, 24.0);
                        let (rect, response) = ui.allocate_exact_size(toggle_size, egui::Sense::click());

                        if response.clicked() {
                            self.conf.instant_audio_response = !self.conf.instant_audio_response;
                        }

                        // Modern toggle
                        let rounding = egui::Rounding::same(12.0);
                        let (bg_color, glow_color) = if self.conf.instant_audio_response {
                            (egui::Color32::from_rgb(236, 72, 153), egui::Color32::from_rgba_premultiplied(236, 72, 153, 40))
                        } else {
                            (egui::Color32::from_rgba_premultiplied(75, 85, 99, 180), egui::Color32::TRANSPARENT)
                        };

                        if self.conf.instant_audio_response {
                            ui.painter().rect_filled(rect.expand(2.0), rounding, glow_color);
                        }

                        ui.painter().rect_filled(rect, rounding, bg_color);

                        // Floating knob
                        let knob_size = 18.0;
                        let knob_margin = 3.0;
                        let knob_travel = rect.width() - knob_size - (knob_margin * 2.0);
                        let progress = if self.conf.instant_audio_response { 1.0 } else { 0.0 };
                        let knob_x = rect.left() + knob_margin + (knob_travel * progress);
                        let knob_center = egui::Pos2::new(knob_x + knob_size/2.0, rect.center().y);

                        ui.painter().circle_filled(knob_center, knob_size/2.0, egui::Color32::WHITE);

                        ui.add_space(16.0);
                        ui.vertical(|ui| {
                            ui.label(
                                egui::RichText::new("Instant Audio Response")
                                    .size(14.0)
                                    .strong()
                                    .color(if self.conf.instant_audio_response { egui::Color32::from_rgb(236, 72, 153) } else { egui::Color32::from_gray(180) })
                            );
                            ui.label(
                                egui::RichText::new(if self.conf.instant_audio_response { "Zero-latency audio feedback" } else { "Standard audio timing" })
                                    .size(11.0)
                                    .color(egui::Color32::from_gray(160))
                            );
                        });
                    });

                    ui.add_space(8.0);

                    // Input Latency Compensation
                    ui.horizontal(|ui| {
                        ui.label("Input Latency Compensation:");
                        ui.add_space(8.0);
                        ui.add(
                            egui::Slider::new(&mut self.conf.input_latency_compensation, -0.1..=0.1)
                                .step_by(0.001)
                                .show_value(true)
                                .suffix("s")
                        );
                    });
                });
            });
    }

    /*fn show_additional_audio_controls(&mut self, ui: &mut egui::Ui) {
        // Additional Audio Settings Section
        egui::Frame::none()
            .fill(egui::Color32::from_gray(18))
            .rounding(egui::Rounding::same(8.0))
            .inner_margin(egui::style::Margin::same(12.0))
            .show(ui, |ui| {
                ui.label(egui::RichText::new("🎮 Additional Settings").size(16.0).strong());
                ui.add_space(8.0);

                help_text(
                    ui,
                    "Plays platformer left/right sounds even if your clickpack doesn't have them",
                    |ui| {
                        ui.checkbox(
                            &mut self.conf.force_playing_platformer,
                            "Force playing platformer sounds",
                        );
                    },
                );

                help_text(
                    ui,
                    "Plays player 2 sounds outside 2-player levels.\n\
                    This will not have any effect if you use alternate hook!",
                    |ui| {
                        ui.checkbox(
                            &mut self.conf.force_player2_sounds,
                            "Force playing player 2 sounds",
                        );
                    },
                );

                help_text(
                    ui,
                    "Makes both platformer sounds have separate timings. Usually sounds bad",
                    |ui| {
                        ui.checkbox(
                            &mut self.conf.decouple_platformer,
                            "Decouple platformer sounds",
                        );
                    },
                );

                help_text(ui, "Releases all held buttons on death", |ui| {
                    ui.checkbox(
                        &mut self.conf.release_buttons_on_death,
                        "Release buttons on death",
                    );
                });

                if self.conf.release_buttons_on_death {
                    ui.indent("death_release_settings", |ui| {
                        drag_value(
                            ui,
                            &mut self.conf.death_release_delay,
                            "Release delay (sec)",
                            0.0..=f64::INFINITY,
                            "Delay before releasing buttons on death in seconds",
                        );
                        ui.horizontal(|ui| {
                            drag_value(
                                ui,
                                &mut self.conf.death_release_delay_offset,
                                "+/- (sec)",
                                0.0..=f64::INFINITY,
                                "Random offset for the death release delay in seconds",
                            );
                            ui.checkbox(&mut self.conf.death_release_delay_neg, "Negative?");
                        });
                    });
                }
            });

        ui.add_space(12.0);

        // Timing Values Section
        egui::Frame::none()
            .fill(egui::Color32::from_gray(18))
            .rounding(egui::Rounding::same(8.0))
            .inner_margin(egui::style::Margin::same(12.0))
            .show(ui, |ui| {
                ui.label(egui::RichText::new("⏰ Timing Values").size(16.0).strong());
                ui.add_space(8.0);

                // Timing values section - moved to end to avoid borrowing conflicts
                let timings_copy = self.conf.timings.clone();
                drag_value(
                    ui,
                    &mut self.conf.timings.hard,
                    "Hard timing",
                    timings_copy.regular..=f64::INFINITY,
                    "Anything above this time between clicks plays hardclicks/hardreleases",
                );
                drag_value(
                    ui,
                    &mut self.conf.timings.regular,
                    "Regular timing",
                    timings_copy.soft..=timings_copy.hard,
                    "Anything above this time between clicks plays clicks/releases",
                );
                drag_value(
                    ui,
                    &mut self.conf.timings.soft,
                    "Soft timing",
                    0.0..=timings_copy.regular,
                    "Anything above this time between clicks plays softclicks/softreleases",
                );
                ui.label(format!(
                    "Any value smaller than {:.2?} plays microclicks/microreleases",
                    Duration::from_secs_f64(self.conf.timings.soft),
                ));
            });

        ui.add_space(12.0);

        // Ignored Click Types Section
        egui::Frame::none()
            .fill(egui::Color32::from_gray(18))
            .rounding(egui::Rounding::same(8.0))
            .inner_margin(egui::style::Margin::same(12.0))
            .show(ui, |ui| {
                ui.label(egui::RichText::new("🚫 Ignored Click Types").size(16.0).strong());
                ui.add_space(8.0);

                ui.label(
                    "Ignored click types will not be played. This can be useful for \
                    disabling microreleases, for example",
                );
                ui.add_space(8.0);

                let i = &mut self.conf.ignored_click_types;
                ui.columns(2, |columns| {
                    columns[0].checkbox(&mut i.hardclicks, "Hardclicks");
                    columns[1].checkbox(&mut i.hardreleases, "Hardreleases");
                    columns[0].checkbox(&mut i.clicks, "Clicks");
                    columns[1].checkbox(&mut i.releases, "Releases");
                    columns[0].checkbox(&mut i.softclicks, "Softclicks");
                    columns[1].checkbox(&mut i.softreleases, "Softreleases");
                    columns[0].checkbox(&mut i.microclicks, "Microclicks");
                    columns[1].checkbox(&mut i.microreleases, "Microreleases");
                });

                if i.any_ignored() {
                    ui.add_space(8.0);
                    if ui.button("Reset All").clicked() {
                        *i = IgnoredClickTypes::default();
                    }
                }
            });
    }*/

    /*fn show_pause_aware_audio_controls(&mut self, ui: &mut egui::Ui) {
        // Enhanced pause-aware audio controls
        ui.add_space(12.0);
        ui.separator();
        ui.label(egui::RichText::new("Pause-Aware Audio System").strong());

        help_text(
            ui,
            "When enabled, currently playing clickpack audio will continue to play naturally when the game is paused,\n\
            rather than being immediately cut off. New audio will not start during pause.\n\
            This prevents jarring audio cutoffs during pause/resume cycles and improves the overall audio experience.",
            |ui| {
                ui.checkbox(&mut self.conf.allow_audio_finish_on_pause, "Allow Audio to Finish on Pause");
            },
        );

        help_text(
            ui,
            "Enables advanced audio system recovery features that handle rapid pause/resume cycles more gracefully.\n\
            This includes action queuing during pauses and automatic audio system reset when needed.",
            |ui| {
                ui.checkbox(&mut self.conf.enable_audio_system_recovery, "Enable Audio System Recovery");
            },
        );

        ui.add_enabled_ui(self.conf.enable_audio_system_recovery, |ui| {
            help_text(
                ui,
                "Time threshold for debouncing pause state changes to prevent audio instability.\n\
                Lower values are more responsive but may cause issues with rapid pause/resume cycles.",
                |ui| {
                    drag_value(
                        ui,
                        &mut self.conf.pause_debounce_threshold,
                        "Pause Debounce Threshold (s)",
                        0.01..=0.5,
                        "",
                    );
                },
            );

            help_text(
                ui,
                "Maximum number of rapid pause/resume cycles before triggering an audio system reset.\n\
                This prevents audio system instability during very rapid state changes.",
                |ui| {
                    ui.horizontal(|ui| {
                        ui.add(
                            egui::DragValue::new(&mut self.conf.rapid_pause_threshold)
                                .clamp_range(3..=20)
                                .speed(0.1),
                        );
                        ui.label("Rapid Pause Threshold");
                    });
                },
            );
        });
    }*/

    /*fn show_dual_timing_controls(&mut self, ui: &mut egui::Ui) {
        // Dual Timing System Controls
        ui.add_space(12.0);
        ui.separator();
        ui.label(egui::RichText::new("Dual Timing System").strong());

        help_text(
            ui,
            "Controls how audio timing is handled for different use cases:\n\
            • Responsive: Prioritizes immediate audio feedback (best for live play)\n\
            • Synchronized: Prioritizes perfect recording sync (best for videos)\n\
            • Hybrid: Balances both based on other settings (recommended)",
            |ui| {
                egui::ComboBox::from_label("Timing Mode")
                    .selected_text(self.conf.timing_mode.text())
                    .show_ui(ui, |ui| {
                        ui.selectable_value(
                            &mut self.conf.timing_mode,
                            TimingMode::Responsive,
                            TimingMode::Responsive.text(),
                        );
                        ui.selectable_value(
                            &mut self.conf.timing_mode,
                            TimingMode::Synchronized,
                            TimingMode::Synchronized.text(),
                        );
                        ui.selectable_value(
                            &mut self.conf.timing_mode,
                            TimingMode::Hybrid,
                            TimingMode::Hybrid.text(),
                        );
                    });
            },
        );

        help_text(
            ui,
            "Enables instantaneous audio response that bypasses smoothing for immediate feedback.\n\
            When enabled, audio plays immediately upon button press with 0ms delay.\n\
            Disable for perfect recording synchronization at the cost of slight input delay.",
            |ui| {
                ui.checkbox(&mut self.conf.instant_audio_response, "Instant Audio Response");
            },
        );

        help_text(
            ui,
            "Compensates for input latency by playing audio slightly earlier.\n\
            Positive values play audio earlier, negative values play audio later.\n\
            Adjust based on your system's input latency characteristics.",
            |ui| {
                drag_value(
                    ui,
                    &mut self.conf.input_latency_compensation,
                    "Input Latency Compensation (s)",
                    -0.1..=0.1,
                    "",
                );
            },
        );

        // Show timing diagnostics button
        if ui.button("Show Timing Diagnostics").clicked() {
            let diagnostics = self.get_timing_diagnostics();
            log::info!("Timing Diagnostics:\n{}", diagnostics);
            self.toasts.lock().add(Toast::info("Timing diagnostics logged to console"));
        }

        // Show audio system diagnostics button
        if ui.button("Show Audio System Status").clicked() {
            let audio_status = self.get_audio_system_status();
            log::info!("Audio System Status:\n{}", audio_status);
            self.toasts.lock().add(Toast::info("Audio system status logged to console"));
        }
    }*/

    fn show_options_window_continued(&mut self, ui: &mut egui::Ui) {
        ui.collapsing("Pitch variation", |ui| {
            ui.label(
                "Pitch variation can make clicks sound more realistic by \
                    changing their pitch randomly.",
            );
            ui.checkbox(&mut self.conf.pitch_enabled, "Enable pitch variation");
            ui.add_enabled_ui(self.conf.pitch_enabled, |ui| {
                let p = &mut self.conf.pitch;
                drag_value(
                    ui,
                    &mut p.from,
                    "Minimum pitch",
                    0.0..=p.to,
                    "Minimum pitch value, 1.0 means no change",
                );
                drag_value(
                    ui,
                    &mut p.to,
                    "Maximum pitch",
                    p.from..=f64::INFINITY,
                    "Maximum pitch value, 1.0 means no change",
                );
            });
        });

        ui.collapsing("Volume settings", |ui| {
            help_text(
                ui,
                "Cut overlapping click sounds,\n\
                changes the sound significantly in spams",
                |ui| ui.checkbox(&mut self.conf.cut_sounds, "Cut sounds"),
            );
            if self.conf.cut_sounds {
                help_text(ui, "Allow clicks to be cut by releases", |ui| {
                    ui.checkbox(&mut self.conf.cut_by_releases, "Cut by releases")
                });
            }
            let vol = &mut self.conf.volume_settings;
            drag_value(
                ui,
                &mut vol.global_volume,
                "Global volume",
                0.0..=f64::INFINITY,
                "Constant volume multiplier for all sounds",
            );
            drag_value(
                ui,
                &mut vol.volume_var,
                "Volume variation",
                0.0..=f64::INFINITY,
                "Random volume variation (+/-)",
            );
            drag_value(
                ui,
                &mut vol.platformer_volume_factor,
                "Platformer volume factor",
                f64::NEG_INFINITY..=f64::INFINITY,
                "Multiplier of the platformer sound volume. If this is 0.5, \
                platformer sounds will be played at half volume",
            );
        });

        ui.collapsing("Spam volume changes", |ui| {
            ui.label("This can be used to lower volume in spams");
            let vol = &mut self.conf.volume_settings;
            help_text(ui, "Apply this logic to releases", |ui| {
                ui.checkbox(&mut vol.change_releases_volume, "Change releases volume")
            });
            drag_value(
                ui,
                &mut vol.spam_time,
                "Spam time",
                0.0..=f64::INFINITY,
                "Time between clicks which are considered spam clicks",
            );
            drag_value(
                ui,
                &mut vol.spam_vol_offset_factor,
                "Spam volume offset factor",
                f64::NEG_INFINITY..=f64::INFINITY,
                "The value which the volume offset factor is multiplied by",
            );
            drag_value(
                ui,
                &mut vol.max_spam_vol_offset,
                "Maximum volume offset",
                f64::NEG_INFINITY..=f64::INFINITY,
                "The maximum value of the volume offset",
            );
        });

        ui.collapsing("Speed", |ui| {
            ui.label("Adjust audio speed/pitch");
            ui.horizontal(|ui| {
                drag_value(
                    ui,
                    &mut self.conf.click_speedhack,
                    "Click speed",
                    0.0..=f64::INFINITY,
                    "Speed multiplier for clicks/releases",
                );
                if self.conf.click_speedhack != 1.0 && ui.button("Reset").clicked() {
                    self.conf.click_speedhack = 1.0;
                }
            });
            ui.horizontal(|ui| {
                if drag_value(
                    ui,
                    &mut self.conf.noise_speedhack,
                    "Noise speed",
                    0.0..=f64::INFINITY,
                    "Speed multiplier for noise. Only useful if your clickpack has a noise file",
                )
                .drag_stopped()
                {
                    self.play_noise();
                }
                if self.conf.noise_speedhack != 1.0 && ui.button("Reset").clicked() {
                    self.conf.noise_speedhack = 1.0;
                    self.play_noise();
                }
            });
            // help_text(ui, "Synchronize click speedhack with game speed", |ui| {
            //     ui.checkbox(&mut self.conf.sync_speed_with_game, "Sync speed with game")
            // });
        });

        ui.collapsing("Advanced", |ui| {
            // let last_bufsize = self.mixer.renderer.guard().last_buffer_size;
            // ui.label(format!("Real buffer size: {last_bufsize}"));
            help_text(
                ui,
                "Keep playing noise even if the clickbot is disabled",
                |ui| {
                    ui.checkbox(&mut self.conf.play_noise_when_disabled, "Play noise when disabled");
                },
            );

            let prev_bufsize = self.conf.buffer_size;
            help_text(
                ui,
                "Audio buffer size in samples. Lower value means lower latency.\n\
                Click \"Apply\" below to apply changes (if any)",
                |ui| {
                    ui.label("Buffer size");
                },
            );
            if u32_edit_field_min1(ui, &mut self.conf.buffer_size).changed() {
                self.buffer_size_changed = prev_bufsize != self.conf.buffer_size;
            }

            if self.buffer_size_changed {
                ui.horizontal(|ui| {
                    if ui
                        .button("Apply")
                        .on_hover_text("Apply buffer size changes")
                        .clicked()
                    {
                        if !self.conf.use_fmod {
                            self.maybe_init_kittyaudio();
                            self.play_noise();
                        } else {
                            self.show_fmod_buffersize_warn = true;
                        }
                        self.buffer_size_changed = false;
                    }

                    if self.conf.buffer_size > 300_000 {
                        ui.label(
                            RichText::new("WARN: Using a high buffer size might cause instability")
                                .color(Color32::YELLOW),
                        );
                    }
                });
            }
            if self.show_fmod_buffersize_warn && self.conf.buffer_size != self.startup_buffer_size {
                ui.label(
                    RichText::new("WARN: Restart the game to apply FMOD buffer size changes")
                        .color(Color32::YELLOW),
                );
            }
            if self.conf.use_fmod && self.startup_buffer_size < 10 {
                ui.label(
                    "If you don't hear any audio, it might be because your buffer size is set too low. \
                    The recommended value for FMOD is 10."
                );
            }
        });

        ui.allocate_space(vec2(100.0, 0.0));
    }

    fn apply_config(&mut self) {
        self.maybe_init_kittyaudio();
        self.play_noise();

        #[cfg(not(feature = "geode"))]
        self.maybe_alloc_console();
    }

    fn unload_clickpack(&mut self) {
        self.clickpack = Clickpack::default();
        self.stop_noise();
    }

    fn stop_noise(&mut self) {
        let prev_play_noise = self.conf.play_noise;
        self.conf.play_noise = false;
        self.play_noise();
        self.conf.play_noise = prev_play_noise;
    }

    /// Reset the audio system to recover from issues during rapid pause/resume cycles
    fn reset_audio_system(&mut self) {
        log::info!("Resetting audio system due to rapid pause/resume cycles");

        // Stop all currently playing sounds immediately
        self.stop_all_sounds_immediately();

        // Reinitialize the mixer
        if !self.conf.use_fmod {
            self.maybe_init_kittyaudio();
        }

        // Reset audio state
        self.audio_system_needs_reset = false;
        self.rapid_pause_resume_count = 0;
        self.pending_audio_actions.clear();

        // Restart noise if it was playing
        self.play_noise();

        log::info!("Audio system reset completed");
    }

    /// Stop all sounds immediately without seeking to end (for emergency reset)
    fn stop_all_sounds_immediately(&mut self) {
        if !self.conf.use_fmod {
            // Create a new mixer to immediately stop all sounds
            let old_mixer = std::mem::replace(&mut self.mixer, Mixer::new());
            drop(old_mixer); // This will stop all sounds immediately
        }

        // Reset noise sound handle
        self.noise_sound = None;
    }

    /// Process pending audio actions that were queued during pause states
    fn process_pending_audio_actions(&mut self) {
        if self.pending_audio_actions.is_empty() {
            return;
        }

        log::debug!("Processing {} pending audio actions", self.pending_audio_actions.len());

        let actions = std::mem::take(&mut self.pending_audio_actions);
        let mut processed_count = 0;

        for action in actions {
            match action {
                PendingAudioAction::Play { button, player2, push, timestamp } => {
                    // Only process recent actions (within 150ms for better responsiveness)
                    if timestamp.elapsed().as_millis() < 150 {
                        unsafe { self.on_action(button, player2, push); }
                        processed_count += 1;
                    }
                }
                PendingAudioAction::Stop { immediate } => {
                    if immediate {
                        self.stop_all_sounds_immediately();
                    } else {
                        self.stop_noise();
                    }
                    processed_count += 1;
                }
                PendingAudioAction::Reset => {
                    self.reset_audio_system();
                    processed_count += 1;
                }
            }
        }

        if processed_count > 0 {
            log::debug!("Processed {} audio actions after resume", processed_count);
        }
    }

    /// Check if audio system recovery is needed and perform it
    fn check_and_recover_audio_system(&mut self) {
        if !self.conf.enable_audio_system_recovery {
            return;
        }

        if self.audio_system_needs_reset {
            self.reset_audio_system();
        }

        // Process any pending actions
        self.process_pending_audio_actions();
    }

    /// Get comprehensive audio system status for diagnostics
    fn get_audio_system_status(&self) -> String {
        let mut status = String::new();

        status.push_str("=== Audio System Status ===\n");
        status.push_str(&format!("Game Paused: {}\n", self.is_game_paused));
        status.push_str(&format!("Audio System Needs Reset: {}\n", self.audio_system_needs_reset));
        status.push_str(&format!("Rapid Pause/Resume Count: {}\n", self.rapid_pause_resume_count));
        status.push_str(&format!("Pending Audio Actions: {}\n", self.pending_audio_actions.len()));
        status.push_str(&format!("Last Pause State: {}\n", self.last_pause_state));

        let debounce_elapsed = self.pause_state_debounce_timer.elapsed().as_millis();
        status.push_str(&format!("Debounce Timer Elapsed: {}ms\n", debounce_elapsed));

        let pause_elapsed = self.pause_detected_time.elapsed().as_millis();
        status.push_str(&format!("Time Since Last Pause Detection: {}ms\n", pause_elapsed));

        status.push_str("\n=== Configuration ===\n");
        status.push_str(&format!("Allow Audio Finish on Pause: {}\n", self.conf.allow_audio_finish_on_pause));
        status.push_str(&format!("Enable Audio System Recovery: {}\n", self.conf.enable_audio_system_recovery));
        status.push_str(&format!("Pause Detection Threshold: {:.3}s\n", self.conf.pause_detection_threshold));
        status.push_str(&format!("Pause Debounce Threshold: {:.3}s\n", self.conf.pause_debounce_threshold));
        status.push_str(&format!("Rapid Pause Threshold: {}\n", self.conf.rapid_pause_threshold));

        status.push_str("\n=== Audio Engine ===\n");
        status.push_str(&format!("Using FMOD: {}\n", self.conf.use_fmod));
        status.push_str(&format!("Buffer Size: {}\n", self.conf.buffer_size));
        status.push_str(&format!("Cut Sounds: {}\n", self.conf.cut_sounds));
        status.push_str(&format!("Noise Sound Active: {}\n", self.noise_sound.is_some()));

        if !self.conf.use_fmod {
            let renderer_guard = self.mixer.renderer.guard();
            status.push_str(&format!("Active Sounds: {}\n", renderer_guard.sounds.len()));
        }

        status
    }

    /// Force immediate audio system recovery (emergency reset)
    /// This can be called externally when audio issues are detected
    #[allow(dead_code)]
    pub fn force_audio_system_recovery(&mut self) {
        log::warn!("Forcing immediate audio system recovery");

        // Mark for immediate reset
        self.audio_system_needs_reset = true;
        self.rapid_pause_resume_count = self.conf.rapid_pause_threshold;

        // Clear all pending actions to prevent conflicts
        self.pending_audio_actions.clear();

        // Perform immediate recovery
        self.check_and_recover_audio_system();

        log::info!("Emergency audio system recovery completed");
    }

    fn load_clickpack_thread(
        err_fn: impl Fn(anyhow::Error),
        dir: &Path,
        is_loading_clickpack: Arc<AtomicBool>,
        load_for: LoadClickpackFor,
    ) {
        unsafe {
            is_loading_clickpack.store(true, Ordering::Relaxed);
            if load_for == LoadClickpackFor::All {
                BOT.unload_clickpack();
            } else {
                BOT.stop_noise();
            }
            let _ = BOT.clickpack.load_from_path(dir, load_for).map_err(|e| {
                log::error!("failed to load clickpack: {e}");
                err_fn(e);
            });
            BOT.play_noise();
            is_loading_clickpack.store(false, Ordering::Relaxed);
        }
    }

    fn select_clickpack_combobox(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) {
        let ellipsis = if self.clickpack.name.len() <= 14 {
            self.clickpack.name.clone()
        } else {
            format!("{:.14}…", self.clickpack.name)
        };
        egui::ComboBox::from_label("Select clickpack")
            .selected_text(ellipsis)
            .show_ui(ui, |ui| {
                for dirname in &self.clickpacks {
                    let is_loading_clickpack = self.is_loading_clickpack.clone();
                    let load_for = self.conf.load_clickpack_for;
                    let path = PathBuf::from(".dcd").join("clickpacks").join(dirname);
                    if ui
                        .selectable_label(&self.clickpack.name == dirname, dirname)
                        .clicked()
                    {
                        let modal_moved = modal.clone();
                        let dirname_moved = dirname.to_string();
                        std::thread::spawn(move || {
                            Self::load_clickpack_thread(
                                |e| {
                                    show_error_dialog(
                                        modal_moved.clone(),
                                        "Failed to load clickpack!",
                                        &e.to_string(),
                                    );
                                },
                                &path,
                                is_loading_clickpack,
                                load_for,
                            );
                            unsafe { BOT.env.update(ClickpackEnv::Name(dirname_moved), load_for) };
                        });
                    }
                }
            });
    }

    fn select_clickpack_button(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) -> bool {
        if !self.clickpacks.is_empty() {
            self.select_clickpack_combobox(ui, modal);
            return true;
        }
        ui.horizontal(|ui| {
            if ui
                .button("Select clickpack")
                .on_disabled_hover_text("Please wait…")
                .clicked()
            {
                let is_loading_clickpack = self.is_loading_clickpack.clone();
                let load_for = self.conf.load_clickpack_for;
                std::thread::spawn(move || {
                    let Some(dir) = FileDialog::new().pick_folder() else {
                        return;
                    };
                    log::debug!("selected clickpack {dir:?}");
                    Self::load_clickpack_thread(
                        |e| {
                            show_error_dialog(
                                modal.clone(),
                                "Failed to load clickpack!",
                                &e.to_string(),
                            );
                        },
                        &dir,
                        is_loading_clickpack,
                        load_for,
                    );
                    unsafe {
                        BOT.env.update(ClickpackEnv::Path(dir), load_for);
                    }
                });
            }
            if self.clickpack.num_sounds != 0 {
                ui.label(format!("Selected clickpack: \"{}\"", self.clickpack.name));
            } else {
                ui.label("…or put clickpacks in .dcd/clickpacks");
            }
        });
        false
    }

    fn show_select_clickpack_for_combobox(&mut self, ui: &mut egui::Ui) {
        ui.horizontal(|ui| {
            ui.label("Select clickpack for:");
            help_text(
                ui,
                "Choose a player to load the clickpack for.\n\
                E.g. if you choose Left1, the clickpack will be used for platformer sounds",
                |ui| {
                    egui::ComboBox::new("select_clickpack_for_combobox", "")
                        .selected_text(format!("{:?}", self.conf.load_clickpack_for))
                        .show_ui(ui, |ui| {
                            for load_for in [
                                LoadClickpackFor::All,
                                LoadClickpackFor::Player1,
                                LoadClickpackFor::Player2,
                                LoadClickpackFor::Left1,
                                LoadClickpackFor::Left2,
                                LoadClickpackFor::Right1,
                                LoadClickpackFor::Right2,
                            ] {
                                ui.selectable_value(
                                    &mut self.conf.load_clickpack_for,
                                    load_for,
                                    format!("{load_for:?}"),
                                );
                            }
                        });
                },
            );
        });
    }

    fn show_clickpack_window(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) {
        let is_loading_clickpack = self.is_loading_clickpack();

        // Ultra-modern loading indicator with glassmorphism and animations
        if is_loading_clickpack {
            egui::Frame::none()
                .fill(egui::Color32::from_rgba_premultiplied(25, 30, 40, 180))
                .rounding(egui::Rounding::same(20.0))
                .inner_margin(egui::Margin::same(40.0))
                .stroke(egui::Stroke::new(1.0, egui::Color32::from_rgba_premultiplied(255, 255, 255, 30)))
                .show(ui, |ui| {
                    ui.vertical_centered(|ui| {
                        ui.add_space(20.0);

                        // Ultra-modern animated loading spinner with glow
                        let spinner_size = 48.0;
                        let (rect, _) = ui.allocate_exact_size(egui::Vec2::splat(spinner_size), egui::Sense::hover());
                        let time = ui.input(|i| i.time);
                        let rotation = time as f32 * 3.0;

                        // Glow effect background
                        let center = rect.center();
                        ui.painter().circle_filled(
                            center,
                            spinner_size/2.0 + 8.0,
                            egui::Color32::from_rgba_premultiplied(100, 150, 255, 20)
                        );

                        // Draw modern animated spinner with multiple rings
                        let radius = spinner_size / 2.0 - 4.0;
                        for i in 0..8 {
                            let angle = rotation + (i as f32 * std::f32::consts::PI / 4.0);
                            let alpha = ((i as f32 / 8.0) * 255.0) as u8;
                            let color = egui::Color32::from_rgba_unmultiplied(100, 150, 255, alpha);

                            let start = center + egui::Vec2::new(angle.cos(), angle.sin()) * (radius - 8.0);
                            let end = center + egui::Vec2::new(angle.cos(), angle.sin()) * radius;

                            ui.painter().line_segment([start, end], egui::Stroke::new(3.0, color));
                        }

                        ui.add_space(16.0);
                        ui.label(
                            egui::RichText::new("Loading Clickpack")
                                .size(18.0)
                                .strong()
                                .color(egui::Color32::WHITE)
                        );
                        ui.label(
                            egui::RichText::new("Please wait while the clickpack is being loaded...")
                                .size(12.0)
                                .color(egui::Color32::from_gray(160))
                        );
                        ui.add_space(16.0);
                    });
                });
            return;
        }

        ui.add_enabled_ui(!is_loading_clickpack, |ui| {
            // Enhanced info section with modern card design and better visual hierarchy
            if !self.clickpacks.is_empty() {
                egui::Frame::none()
                    .fill(egui::Color32::from_gray(24))
                    .rounding(egui::Rounding::same(12.0))
                    .inner_margin(egui::Margin::same(16.0))
                    .stroke(egui::Stroke::new(1.0, egui::Color32::from_rgb(100, 150, 255)))
                    .show(ui, |ui| {
                        ui.horizontal(|ui| {
                            // Enhanced icon with background
                            egui::Frame::none()
                                .fill(egui::Color32::from_rgb(100, 150, 255))
                                .rounding(egui::Rounding::same(8.0))
                                .inner_margin(egui::Margin::same(8.0))
                                .show(ui, |ui| {
                                    ui.label(egui::RichText::new("💡").size(16.0));
                                });

                            ui.add_space(12.0);
                            ui.vertical(|ui| {
                                ui.label(
                                    egui::RichText::new("Clickpack Directory")
                                        .size(14.0)
                                        .strong()
                                        .color(egui::Color32::WHITE)
                                );
                                ui.add_space(4.0);
                                ui.label(
                                    egui::RichText::new("Put clickpacks in .dcd/clickpacks")
                                        .size(11.0)
                                        .color(egui::Color32::from_gray(180))
                                );
                                ui.label(
                                    egui::RichText::new("If no folders exist, manual selection will be available")
                                        .size(11.0)
                                        .color(egui::Color32::from_gray(160))
                                );
                            });
                        });
                    });
                ui.add_space(16.0);
            }

            let show_open_folder = |ui: &mut egui::Ui| {
                if ui
                    .button("Open folder")
                    .on_hover_text("Open .dcd/clickpacks")
                    .clicked()
                {
                    let _ = std::fs::create_dir_all(".dcd/clickpacks")
                        .map_err(|e| log::error!("failed to create .dcd/clickpacks: {e}"));
                    let _ = Command::new("explorer")
                        .arg(".dcd\\clickpacks")
                        .spawn()
                        .map_err(|e| log::error!("failed to open .dcd/clickpacks: {e}"));
                }
            };

            self.show_select_clickpack_for_combobox(ui);

            let mut is_combobox = false;
            ui.horizontal(|ui| {
                is_combobox = self.select_clickpack_button(ui, modal);
                if !self.clickpack.name.is_empty() {
                    ui.style_mut().spacing.item_spacing.x = 4.0;
                    if ui.button("🗙").on_hover_text("Unload clickpack").clicked() {
                        self.unload_clickpack();
                        self.env.update(ClickpackEnv::None, LoadClickpackFor::All);
                    }
                }
                if is_combobox {
                    show_open_folder(ui);
                }
            });
            if !is_combobox {
                show_open_folder(ui);
            }
        });

        if self.clickpack.num_sounds != 0 {
            help_text(
                ui,
                "To add player 2 sounds, make a folder called \"player2\" \
                and put sounds for the second player there,\n\
                or use \"Select clickpack for\" to select a \
                seperate clickpack for the second player",
                |ui| {
                    ui.label(format!("{} sounds", self.clickpack.num_sounds));
                },
            );
        }
        ui.add_space(16.0);

        // Ultra-modern ClickpackDB section with glassmorphism and gradient
        egui::Frame::none()
            .fill(egui::Color32::from_rgba_premultiplied(25, 30, 40, 160))
            .rounding(egui::Rounding::same(16.0))
            .inner_margin(egui::Margin::same(20.0))
            .stroke(egui::Stroke::new(1.0, egui::Color32::from_rgba_premultiplied(255, 255, 255, 20)))
            .show(ui, |ui| {
                ui.horizontal(|ui| {
                    // Modern icon with animated glow
                    let icon_rect = ui.allocate_exact_size(egui::Vec2::splat(32.0), egui::Sense::hover()).0;
                    let time = ui.input(|i| i.time);
                    let pulse = (time * 2.0).sin() * 0.3 + 0.7;

                    ui.painter().circle_filled(
                        icon_rect.center(),
                        16.0 * pulse as f32,
                        egui::Color32::from_rgba_premultiplied(255, 193, 7, 30)
                    );
                    ui.painter().circle_filled(
                        icon_rect.center(),
                        14.0,
                        egui::Color32::from_rgba_premultiplied(255, 193, 7, 60)
                    );
                    ui.painter().text(
                        icon_rect.center(),
                        egui::Align2::CENTER_CENTER,
                        "🗃️",
                        egui::FontId::proportional(18.0),
                        egui::Color32::WHITE,
                    );

                    ui.add_space(16.0);
                    ui.vertical(|ui| {
                        ui.label(egui::RichText::new("ClickpackDB").size(20.0).strong().color(egui::Color32::WHITE));
                        ui.label(egui::RichText::new("Browse 300+ premium clickpacks online").size(13.0).color(egui::Color32::from_gray(180)));
                    });
                });

                ui.add_space(16.0);

                ui.label(
                    egui::RichText::new("ClickpackDB is a curated collection of 300+ high-quality clickpacks that can be instantly downloaded and used within DcD Live.")
                        .size(13.0)
                        .color(egui::Color32::from_gray(200))
                );

                ui.add_space(16.0);

                ui.horizontal(|ui| {
                    if self.clickpack_db_open {
                        // Modern close button with glow
                        let close_size = egui::Vec2::new(140.0, 36.0);
                        let (close_rect, close_response) = ui.allocate_exact_size(close_size, egui::Sense::click());

                        if close_response.hovered() {
                            ui.painter().rect_filled(
                                close_rect.expand(2.0),
                                egui::Rounding::same(12.0),
                                egui::Color32::from_rgba_premultiplied(239, 68, 68, 40)
                            );
                        }

                        ui.painter().rect_filled(
                            close_rect,
                            egui::Rounding::same(10.0),
                            egui::Color32::from_rgb(239, 68, 68)
                        );

                        ui.painter().text(
                            close_rect.center(),
                            egui::Align2::CENTER_CENTER,
                            "✖ Close ClickpackDB",
                            egui::FontId::proportional(13.0),
                            egui::Color32::WHITE,
                        );

                        if close_response.clicked() {
                            self.clickpack_db_open = false;
                        }
                        close_response.on_hover_text("This can also be done by clicking ✖ on the ClickpackDB window");
                    } else {
                        // Modern open button with gradient and glow
                        let open_size = egui::Vec2::new(160.0, 40.0);
                        let (open_rect, open_response) = ui.allocate_exact_size(open_size, egui::Sense::click());

                        // Glow effect
                        if open_response.hovered() {
                            ui.painter().rect_filled(
                                open_rect.expand(3.0),
                                egui::Rounding::same(14.0),
                                egui::Color32::from_rgba_premultiplied(100, 150, 255, 60)
                            );
                        }

                        // Gradient background
                        ui.painter().rect_filled(
                            open_rect,
                            egui::Rounding::same(12.0),
                            egui::Color32::from_rgb(100, 150, 255)
                        );

                        // Highlight
                        ui.painter().rect_filled(
                            egui::Rect::from_min_size(open_rect.min, egui::Vec2::new(open_rect.width(), open_rect.height() * 0.4)),
                            egui::Rounding { nw: 12.0, ne: 12.0, sw: 0.0, se: 0.0 },
                            egui::Color32::from_rgba_premultiplied(255, 255, 255, 30)
                        );

                        ui.painter().text(
                            open_rect.center(),
                            egui::Align2::CENTER_CENTER,
                            "🚀 Open ClickpackDB",
                            egui::FontId::proportional(14.0),
                            egui::Color32::WHITE,
                        );

                        if open_response.clicked() {
                            self.clickpack_db_open = true;
                        }
                    }
                });
            });
        // ui.hyperlink_to(
        //     "Get more clickpacks in the Discord server!",
        //     "https://discord.gg/BRVVVzxESu",
        // );

        if !is_loading_clickpack && self.is_in_level {
            ui.add_space(16.0);

            // Enhanced Debug section with modern card design
            egui::Frame::none()
                .fill(egui::Color32::from_gray(24))
                .rounding(egui::Rounding::same(12.0))
                .inner_margin(egui::Margin::same(16.0))
                .stroke(egui::Stroke::new(1.0, egui::Color32::from_gray(40)))
                .show(ui, |ui| {
                    ui.horizontal(|ui| {
                        ui.label(egui::RichText::new("🐛").size(20.0));
                        ui.add_space(8.0);
                        ui.vertical(|ui| {
                            ui.label(egui::RichText::new("Debug Information").size(16.0).strong().color(egui::Color32::WHITE));
                            ui.label(egui::RichText::new("Real-time audio feedback data").size(11.0).color(egui::Color32::from_gray(160)));
                        });
                    });

                    ui.add_space(16.0);

                    // Click Times Section
                    egui::Frame::none()
                        .fill(egui::Color32::from_gray(20))
                        .rounding(egui::Rounding::same(8.0))
                        .inner_margin(egui::Margin::same(12.0))
                        .show(ui, |ui| {
                            ui.label(egui::RichText::new("⏱️ Last Click Times & Types").size(14.0).strong());
                            ui.add_space(8.0);

                            egui::Grid::new("times_grid")
                                .num_columns(2)
                                .min_col_width(130.0)
                                .striped(true)
                                .show(ui, |ui| {
                                    for times in [
                                        ("Jump", self.prev_times.jump),
                                        ("Left", self.prev_times.left),
                                        ("Right", self.prev_times.right),
                                    ].iter() {
                                        ui.label(egui::RichText::new(times.0).strong().color(egui::Color32::from_gray(200)));
                                        for t in times.1 {
                                            ui.label(
                                                egui::RichText::new(format!("{:.3?} | {:?}", t.time, t.typ))
                                                    .color(egui::Color32::from_gray(180))
                                                    .monospace()
                                            );
                                        }
                                        ui.end_row();
                                    }
                                });
                        });

                    ui.add_space(12.0);

                    // Audio Parameters Section
                    egui::Frame::none()
                        .fill(egui::Color32::from_gray(20))
                        .rounding(egui::Rounding::same(8.0))
                        .inner_margin(egui::Margin::same(12.0))
                        .show(ui, |ui| {
                            ui.label(egui::RichText::new("🎵 Audio Parameters").size(14.0).strong());
                            ui.add_space(8.0);

                            ui.horizontal(|ui| {
                                ui.vertical(|ui| {
                                    ui.label(egui::RichText::new("Pitch").strong().color(egui::Color32::from_gray(200)));
                                    ui.label(
                                        egui::RichText::new(format!("{:.4}", self.prev_pitch))
                                            .monospace()
                                            .color(egui::Color32::from_rgb(100, 150, 255))
                                    );
                                    ui.label(
                                        egui::RichText::new(format!("Range: {:.2}..={:.2}", self.conf.pitch.from, self.conf.pitch.to))
                                            .size(10.0)
                                            .color(egui::Color32::from_gray(140))
                                    );
                                });

                                ui.add_space(20.0);

                                ui.vertical(|ui| {
                                    ui.label(egui::RichText::new("Volume").strong().color(egui::Color32::from_gray(200)));
                                    ui.label(
                                        egui::RichText::new(format!("{:.4}", self.prev_volume))
                                            .monospace()
                                            .color(egui::Color32::from_rgb(34, 197, 94))
                                    );
                                    ui.label(
                                        egui::RichText::new(format!("Var: ±{:.2} × {:.2}", self.conf.volume_settings.volume_var, self.conf.volume_settings.global_volume))
                                            .size(10.0)
                                            .color(egui::Color32::from_gray(140))
                                    );
                                });

                                ui.add_space(20.0);

                                ui.vertical(|ui| {
                                    ui.label(egui::RichText::new("Spam Offset").strong().color(egui::Color32::from_gray(200)));
                                    ui.label(
                                        egui::RichText::new(format!("-{:.4}", self.prev_spam_offset))
                                            .monospace()
                                            .color(egui::Color32::from_rgb(239, 68, 68))
                                    );
                                });
                            });
                        });

                    ui.add_space(12.0);

                    // Clickpack Info Section
                    egui::Frame::none()
                        .fill(egui::Color32::from_gray(20))
                        .rounding(egui::Rounding::same(8.0))
                        .inner_margin(egui::Margin::same(12.0))
                        .show(ui, |ui| {
                            ui.label(egui::RichText::new("📁 Clickpack Path").size(14.0).strong());
                            ui.add_space(8.0);

                            let format_path_keep_root = |path: &Path| path.to_string_lossy().replace('\\', "/");
                            ui.label(
                                egui::RichText::new(format_path_keep_root(&self.clickpack.path))
                                    .monospace()
                                    .color(egui::Color32::from_gray(180))
                            );
                        });
                });
        }
    }

    fn show_clickpackdb_window(&mut self, ctx: &egui::Context, modal: Arc<Mutex<Modal>>) {
        if !self.clickpack_db_open {
            return;
        }
        if std::mem::take(&mut self.clickpack_db.has_refreshed) {
            log::debug!("doing clickpack reload for clickpackdb");
            let _ = self
                .reload_clickpacks()
                .map_err(|e| log::error!("failed to reload clickpacks for clickpackdb: {e}"));
        }
        egui::Window::new("ClickpackDB")
            .open(&mut self.clickpack_db_open)
            .show(ctx, |ui| {
                self.clickpack_db.show(ui, &ureq_get);
                if let Some(select_path) =
                    std::mem::replace(&mut self.clickpack_db.select_clickpack, None)
                {
                    self.conf.load_clickpack_for = LoadClickpackFor::All;
                    let is_loading_clickpack = self.is_loading_clickpack.clone();
                    let modal_moved = modal.clone();
                    std::thread::spawn(move || {
                        Self::load_clickpack_thread(
                            |e| {
                                show_error_dialog(
                                    modal_moved.clone(),
                                    "Failed to load clickpack!",
                                    &e.to_string(),
                                );
                            },
                            &select_path,
                            is_loading_clickpack,
                            LoadClickpackFor::All,
                        );
                        unsafe {
                            BOT.env.update(
                                ClickpackEnv::Name(
                                    select_path
                                        .file_name()
                                        .unwrap_or_default()
                                        .to_string_lossy()
                                        .to_string(),
                                ),
                                LoadClickpackFor::All,
                            )
                        };
                    });
                }
            });
    }
}

impl Drop for Bot {
    fn drop(&mut self) {
        // self.unload_clickpack();
        self.release_fmod()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_enhanced_timing_basic() {
        let mut bot = Bot::default();
        bot.conf.use_ingame_time = true;
        bot.conf.enhanced_recording_sync = true;
        bot.conf.time_smoothing_factor = 0.1;
        bot.conf.pause_detection_threshold = 0.1;

        // Initialize timing
        bot.on_init(0);

        // Simulate some time passing
        thread::sleep(Duration::from_millis(50));
        bot.playlayer_time = 0.05; // 50ms game time

        // Update timing state
        bot.update_timing_state();

        // Get synchronized time
        let sync_time = bot.get_synchronized_time(0.05);

        // Should be close to the game time
        assert!((sync_time - 0.05).abs() < 0.01, "Synchronized time should be close to game time");
    }

    #[test]
    fn test_pause_detection() {
        let mut bot = Bot::default();
        bot.conf.use_ingame_time = true;
        bot.conf.enhanced_recording_sync = true;
        bot.conf.pause_detection_threshold = 0.05; // 50ms threshold

        bot.on_init(0);

        // Simulate initial state
        bot.last_game_time = 1.0;
        bot.last_real_time = Instant::now() - Duration::from_millis(200); // 200ms ago

        // Simulate pause (game time didn't advance much, but real time did)
        bot.playlayer_time = 1.01; // Only 10ms game time passed

        let sync_time = bot.get_synchronized_time(1.01);

        // During pause, should maintain stable timing
        assert!(sync_time > 0.0, "Should maintain positive time during pause");
    }

    #[test]
    fn test_enhanced_pause_aware_audio() {
        let mut bot = Bot::default();
        bot.conf.use_ingame_time = true;
        bot.conf.allow_audio_finish_on_pause = true;
        bot.conf.enable_audio_system_recovery = true;
        bot.conf.pause_detection_threshold = 0.05; // 50ms threshold
        bot.conf.pause_debounce_threshold = 0.03; // 30ms debounce
        bot.conf.rapid_pause_threshold = 3;

        bot.on_init(0);

        // Initially not paused
        assert!(!bot.is_game_paused, "Should not be paused initially");
        assert_eq!(bot.rapid_pause_resume_count, 0, "Should have no rapid pause count initially");

        // Simulate pause detection
        bot.last_game_time = 1.0;
        bot.last_real_time = Instant::now() - Duration::from_millis(200); // 200ms ago
        bot.playlayer_time = 1.01; // Only 10ms game time passed

        // Update timing state to detect pause
        bot.update_timing_state();

        // Should now be detected as paused
        assert!(bot.is_game_paused, "Should detect pause state");

        // Test rapid pause/resume detection
        for _ in 0..4 {
            // Simulate rapid state changes
            std::thread::sleep(Duration::from_millis(10));
            bot.update_pause_state_with_debouncing(!bot.is_game_paused, Instant::now());
        }

        // Should trigger audio system reset due to rapid changes
        assert!(bot.audio_system_needs_reset || bot.rapid_pause_resume_count >= bot.conf.rapid_pause_threshold,
                "Should detect rapid pause/resume cycles");

        // Test pending action queuing
        bot.is_game_paused = true;
        bot.pending_audio_actions.push(PendingAudioAction::Play {
            button: crate::clickpack::Button::Jump,
            player2: false,
            push: true,
            timestamp: Instant::now(),
        });

        assert_eq!(bot.pending_audio_actions.len(), 1, "Should have queued action");

        // Test audio system recovery
        bot.check_and_recover_audio_system();

        // After recovery, system should be stable
        if bot.audio_system_needs_reset {
            bot.reset_audio_system();
            assert!(!bot.audio_system_needs_reset, "Audio system should be reset");
            assert_eq!(bot.rapid_pause_resume_count, 0, "Rapid pause count should be reset");
        }

        // Simulate resume
        bot.last_real_time = Instant::now() - Duration::from_millis(50); // 50ms ago
        bot.playlayer_time = 1.1; // Normal game time progression

        // Update timing state to detect resume
        bot.update_timing_state();

        // Should now be detected as resumed
        assert!(!bot.is_game_paused, "Should detect resume state");
    }

    #[test]
    fn test_timing_diagnostics() {
        let mut bot = Bot::default();
        bot.conf.use_ingame_time = true;
        bot.conf.enhanced_recording_sync = true;

        let diagnostics = bot.get_timing_diagnostics();
        assert!(diagnostics.contains("Dual Timing System"), "Should show dual timing system diagnostics");

        bot.conf.enhanced_recording_sync = false;
        let diagnostics = bot.get_timing_diagnostics();
        assert!(diagnostics.contains("Basic in-game time mode"), "Should show basic mode diagnostics");

        bot.conf.use_ingame_time = false;
        let diagnostics = bot.get_timing_diagnostics();
        assert!(diagnostics.contains("Real-time mode"), "Should show real-time mode diagnostics");
    }

    #[test]
    fn test_dual_timing_modes() {
        let mut bot = Bot::default();
        bot.conf.use_ingame_time = true;
        bot.conf.instant_audio_response = true;
        bot.conf.input_latency_compensation = 0.01;

        bot.on_init(0);

        // Test responsive mode
        bot.conf.timing_mode = TimingMode::Responsive;
        let audio_time = bot.audio_time();
        let sync_time = bot.sync_time();

        // In responsive mode, audio time should be real-time based
        assert!((audio_time - bot.level_start.elapsed().as_secs_f64()).abs() < 0.1);

        // Test synchronized mode
        bot.conf.timing_mode = TimingMode::Synchronized;
        bot.playlayer_time = 1.0;
        let sync_audio_time = bot.audio_time();

        // In synchronized mode, audio time should match sync time
        assert!((sync_audio_time - bot.sync_time()).abs() < 0.1);
    }

    #[test]
    fn test_input_compensation() {
        let mut bot = Bot::default();
        bot.conf.instant_audio_response = true;
        bot.conf.input_latency_compensation = 0.05;

        bot.on_init(0);

        // Record some input events
        bot.record_input_event();
        thread::sleep(Duration::from_millis(10));
        bot.record_input_event();

        let compensation = bot.calculate_input_compensation();
        assert!(compensation >= 0.0, "Compensation should be non-negative");
        assert!(compensation <= 0.1, "Compensation should be reasonable");

        // Test predictive timing
        let predictive_time = bot.get_predictive_audio_time();
        let base_time = bot.audio_time();

        // Predictive time should be slightly earlier than base time
        assert!(predictive_time <= base_time, "Predictive time should be earlier or equal to base time");
    }
}
